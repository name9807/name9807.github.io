<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="呼佳慧"/><meta name="copyright" content="呼佳慧"/><meta name="theme-color" content="#FFB347"/><meta name="format-detection" content="telephone=no"/><meta name="keywords" content="Hexo Theme MEOW"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><meta name="application-name" content="计算机网络/25/8 | 随便写吧"/><meta name="apple-mobile-web-app-title" content="计算机网络/25/8 | 随便写吧"/><meta name="apple-mobile-web-app-status-bar-style" content="#FFB347"/><link rel="canonical" href="https://name9807.github.io/2025/08/26/计算机网络-25-8/"/><meta name="description" content="计算机网络网络设备 网卡(有线、无线)：无线网卡有电磁信号频率。设备带宽bps：每秒传输1000m 路由器：具有wifi功能。 光猫：调制解调器，将光信号调制成电信号（光纤的）。运营商（ISP）安装，一般也自带wifi功能，但是信号不是很好，所以需要买一个路由器 交换机：多用于企业中，有很多插口，可以提供多个终端设备上网 核心交换机：更贵的交换机，负责链接其他底下的交换机。  理解OSI七层...">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络&#x2F;25&#x2F;8 | 随便写吧">
<meta property="og:url" content="https://name9807.github.io/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/index.html">
<meta property="og:site_name" content="随便写吧">
<meta property="og:description" content="计算机网络网络设备 网卡(有线、无线)：无线网卡有电磁信号频率。设备带宽bps：每秒传输1000m 路由器：具有wifi功能。 光猫：调制解调器，将光信号调制成电信号（光纤的）。运营商（ISP）安装，一般也自带wifi功能，但是信号不是很好，所以需要买一个路由器 交换机：多用于企业中，有很多插口，可以提供多个终端设备上网 核心交换机：更贵的交换机，负责链接其他底下的交换机。  理解OSI七层...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://name9807.github.io/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/assets/images/Hexo-Theme-MEOW.png">
<meta property="article:published_time" content="2025-08-26T09:13:20.000Z">
<meta property="article:modified_time" content="2025-09-27T12:46:06.291Z">
<meta property="article:author" content="呼佳慧">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://name9807.github.io/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/assets/images/Hexo-Theme-MEOW.png"><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="revisit-after" content="1 days"/><title>计算机网络/25/8 | 随便写吧</title><link rel="shortcut icon" href="/assets/images/Hexo-Theme-MEOW.ico"><link rel="preconnect" href="/assets"/><link rel="preconnect" href="assets"/>
<link rel="stylesheet" href="/css/style.css">
<link rel="prefetch" href="/"/><link rel="prefetch" href="/archives"/><link rel="prefetch" href="/tags"/><meta name="generator" content="Hexo 7.1.1"></head><body bg-style="none"><header><div id="navbar"><div id="nav-info"><a id="site-icon" href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a id="site-name" href="/" title="主页"><div>随便写吧</div><img src="/assets/images/svg/uc/uc-home.svg" class="icon noview" alt="Icon"></a></div><div id="nav-menu"></div><div id="nav-function"><div id="menu-btn"><a href="javascript:void(0);" title="打开菜单"><img src="/assets/images/svg/uc/uc-menu.svg" class="icon noview" alt="Icon"></a></div></div></div></header><div id="menu-aside"><div id="menu-aside-container"><div id="menu-aside-info"><a href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a href="/" title="主页">随便写吧</a></div><hr/></div></div><main><div class="banner"><div class="banner-info"><div class="banner-avatar"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Avatar"/></div><div class="banner-title">「 MEOW 」</div></div></div><div class="post-container"><div class="post-main"><div class="post-content"><h1 class="post-title">计算机网络/25/8</h1><div class="post-author"><span>作者: 呼佳慧</span></div><div class="post-meta"><div class="post-info"><div class="post-date"><div class="post-pubdate"><img src="/assets/images/svg/ta/ta-pubdate.svg" class="icon noview" alt="Icon"><span>发表于2025-08-26</span></div><div class="post-update"><img src="/assets/images/svg/ta/ta-update.svg" class="icon noview" alt="Icon"><span>更新于2025-10-15</span></div></div><div class="post-read"></div></div><div class="post-attribute"></div></div><div class="post markdown" indent="false"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><ul>
<li>网卡(有线、无线)：无线网卡有电磁信号频率。设备带宽bps：每秒传输1000m</li>
<li>路由器：具有wifi功能。</li>
<li>光猫：调制解调器，将光信号调制成电信号（光纤的）。运营商（ISP）安装，一般也自带wifi功能，但是信号不是很好，所以需要买一个路由器</li>
<li>交换机：多用于企业中，有很多插口，可以提供多个终端设备上网</li>
<li>核心交换机：更贵的交换机，负责链接其他底下的交换机。</li>
</ul>
<h2 id="理解OSI七层协议"><a href="#理解OSI七层协议" class="headerlink" title="理解OSI七层协议"></a>理解OSI七层协议</h2><p>最早期的电脑的交互，只能依靠两个主机之间插上<strong>双绞线</strong>。后来为了满足多台主机交互，设计出了集线器。</p>
<p>而为了区分连接了<strong>集线器</strong>上的电脑，产生了<strong>mac地址</strong>。</p>
<blockquote>
<p>mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
</blockquote>
<p>集线器通过广播，比对消息上的源目的mac地址，进行收发消息。</p>
<p>但是规模变大后，依靠广播传递，会引起广播风暴，造成网络拥塞。于是产生了<strong>ip地址</strong>。</p>
<blockquote>
<p>例：10.100.122.0&#x2F;24</p>
<ul>
<li>网络号：<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码，子网掩码与ip地址进行与运算，结果就是网络号</li>
<li>主机号：将子网掩码取反后和ip地址进行按位与。</li>
</ul>
<p>然后寻址的过程中,先匹配到网络号—-找到同一子网   然后再找到对应的主机。</p>
</blockquote>
<p>集线器不能满足需求之后，将集线器升级成为了<strong>交换机</strong>带有DHCP功能，所有插入到这个交换机上的电脑会被单独分发一个ip地址，用来划分广播域。</p>
<p>广播域被划分后，只能在自己的交换机内广播，为了能够发给别的交换机，产生了<strong>路由器</strong>来管理这些交换机，从此通过ip地址来进行寻找主机，发现不是同一网络段时，通过路由器转发到对应的地址段的交换机，（通过记录或者广播。</p>
<p><strong>arp协议</strong>：到达交换机之后，交换机会记录mac地址和ip地址对应的缓存表，更新时交换机发送arp广播数据包，每一个主机都会将自己的mac地址发送给交换机。</p>
<p>ipv4 不够用了，随着主机数变多，ip地址不够用了，解决方式：</p>
<ul>
<li>ipv6地址：修改起来比较困难</li>
<li>采用内网ip和公网ip：给路由器一个公网ip地址，而连接路由器的设备分配私网ip地址，不能直接上网，都要通过路由器（NAT网络地址转换，数据包携带有目标ip地址，源ip地址，还有自己的私网ip地址）。</li>
</ul>
<p>接着数据包经过路由跳转，路由计算选择最佳跳转路径到达目的主机。服务器路由器可以做一个端口映射，找某端口就直接找响应的服务器主机。</p>
<h2 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><u>传输层的由来</u>：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机吗，但是只找到主机有用吗，是不是程序之间进行的沟通啊像QQ、浏览器和京东服务器，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p>
<p>那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是<strong>端口</strong>，端口即应用程序与网卡关联的编号。</p>
<p><strong>传输层功能</strong>：建立端口到端口的通信(端对端通信)</p>
<p>补充：端口范围0-65535，0-1023为系统占用端口</p>
<p><em><strong>tcp协议</strong></em>：</p>
<p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃</li>
</ul>
<p>(TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作<strong>套接字</strong>（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。)</p>
<p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个<strong>全双工</strong> (full-duplex，双方都可以收发消息) 的通信。</p>
<p>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>以太网头</th>
<th>ip 头</th>
<th>tcp头</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>20字节</td>
<td>理论上可以无限长，但是为了保证效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割，在传输层进行分片。1460</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>以太网头</th>
<th>ip头</th>
<th>udp头</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>8个字节</td>
<td>总长度不超过65,535字节，正好放进一个IP数据包。</td>
</tr>
</tbody></table></div>
<h4 id="tcp报文"><a href="#tcp报文" class="headerlink" title="tcp报文"></a>tcp报文</h4><p>　　　　<img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/988061-20180907175054154-1471843746.png"  class="" title="img"></p>
<p> <strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。<br><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。<br><strong>控制位：</strong></p>
<ul>
<li>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li>
<li>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li>SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。<br>  为什么需要 TCP 协议？ TCP 工作在哪一层？</li>
</ul>
<h4 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h4><img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/image-20250828232753124.png"  class="" title="image-20250828232753124">

<ul>
<li>目标和源端口：告诉UDP协议应该将报文发到哪个进程</li>
<li>包长度：保存UDP总长度</li>
<li>校验和：防止受损</li>
</ul>
<h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><ul>
<li><p>UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p>
</li>
<li><p>TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p>
</li>
</ul>
<p>常用的端口号：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody><tr>
<td>熟知端口</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td></td>
<td></td>
</tr>
</tbody></table></div>
<h4 id="tcp三次握手和四次挥手"><a href="#tcp三次握手和四次挥手" class="headerlink" title="tcp三次握手和四次挥手"></a>tcp三次握手和四次挥手</h4><p><strong>三次握手：</strong></p>
<ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<p><strong>四次挥手</strong>：</p>
<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。服务端也可以主动关闭，一个流程。</p>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/ContractedBlock-17563608085474.gif"  class="" title="img"> View Code

<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>　　　　TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 </p>
<p>　　　　<img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/1036857-20161008185648160-191189690.png"  class="" title="img"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/988061-20180903180410254-588107395.png"  class="" title="img"></h3><img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/ContractedBlock-17563608085474.gif"  class="" title="img"> 为什么三次握手但是四次挥手

<h3 id="2-3-5-应用层"><a href="#2-3-5-应用层" class="headerlink" title="2.3.5 应用层"></a>2.3.5 应用层</h3><p>　　　　应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 </p>
<p>　　　　应用层功能：规定应用程序的数据格式。</p>
<p>　　　　例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p> 　　　<img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/1036857-20161008190023098-992049015.png"  class="" title="img"></p>
<p> 　　　</p>
<p>　　　　<img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/988061-20180903154726160-661452116.png"  class="" title="img"></p>
<h3 id="2-3-6-socket"><a href="#2-3-6-socket" class="headerlink" title="2.3.6 socket"></a>2.3.6 socket</h3><p>　　　　我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p>
<p>　　　　能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP&#x2F;IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p>
<p>　　　　<img   lazyload src="/assets/images/Meow-Loading.webp" data-lazy-src="/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/1036857-20161013091647484-1707663286.png"  class="" title="img"></p>
<p>　　　　socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读&#x2F;写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>接收、添加ip地址，遵循ip协议。IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p>　<em><strong>IP协议：</strong></em></p>
<ul>
<li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li>
<li>范围0.0.0.0-255.255.255.255 (4个点分十进制，也就是4个8位二进制数)</li>
<li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li>
</ul>
<p>　　ipv6，通过上面可以看出，ip紧缺，所以为了满足更多ip需要，出现了ipv6协议：6个冒号分割的16进制数表示，这个应该是将来的趋势，但是ipv4还是用的最多的，因为我们一般一个公司就一个对外的IP地址，我们所有的机器上网都走这一个IP出口。</p>
<p><strong>ip地址分成两部分</strong></p>
<ul>
<li>网络部分：标识子网</li>
<li>主机部分：标识主机</li>
</ul>
<p>注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网。</p>
<blockquote>
<p>例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网</p>
</blockquote>
<p><em><strong>子网掩码</strong></em></p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p> 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<blockquote>
<p>例：已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？</p>
<p>两者与子网掩码分别进行AND运算，</p>
<p>　　172.16.10.1：10101100.00010000.00001010.000000001</p>
<p>　　255255.255.255.0:11111111.11111111.11111111.00000000</p>
<p>　　AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p>
<p>　　172.16.10.2：10101100.00010000.00001010.000000010</p>
<p>　　255.255.255.0:11111111.11111111.11111111.00000000</p>
<p>　　AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p>
<p>　　结果都是172.16.10.0，因此它们在同一个子网络。</p>
</blockquote>
<p><em><strong>ip数据包</strong></em></p>
<p>ip数据包也分为head和data部分，直接放入以太网包的data部分 </p>
<div class="table-container"><table>
<thead>
<tr>
<th>以太网头</th>
<th>ip 头</th>
<th>ip数据</th>
</tr>
</thead>
<tbody><tr>
<td>由数据链路层添加</td>
<td>长度为20到60字节</td>
<td>最长为65,515字节</td>
</tr>
</tbody></table></div>
<p> 而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<p> <em><strong>ARP协议</strong></em></p>
<p><em>ARP协议的划分</em>：按照5层模型属于网络层，按照七层模型属于数据链路层。</p>
<p>arp协议由来：计算机通信基本靠基于mac的广播方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送。计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议。</p>
<p>arp协议功能：广播的方式发送数据包，接收到数据包的目标主机发送自己的mac地址，并收录缓存表。然后在数据包上标上目标主机mac地址，进行广播发送。</p>
<blockquote>
<p> 协议工作方式：每台主机ip都是已知的（我只知道我的局域网ip地址，要给一个非同一网络的我不知道ip地址的电脑发消息，怎么办：NET穿透）</p>
<p>例如：主机172.16.10.10&#x2F;24访问172.16.10.11&#x2F;24</p>
<p>　　一：首先通过ip地址和子网掩码区分出自己所处的子网</p>
<div class="table-container"><table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody><tr>
<td>同一子网</td>
<td>目标主机mac，目标主机ip</td>
</tr>
<tr>
<td>不同子网</td>
<td>网关mac，目标主机ip</td>
</tr>
</tbody></table></div>
<p>二：分析172.16.10.10&#x2F;24与172.16.10.11&#x2F;24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)</p>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>源mac</th>
<th>目标mac</th>
<th>源ip</th>
<th>目标ip</th>
<th>数据部分</th>
</tr>
</thead>
<tbody><tr>
<td>发送端主机</td>
<td>发送端mac</td>
<td>FF:FF:FF:FF:FF:FF</td>
<td>172.16.10.10&#x2F;24</td>
<td>172.16.10.11&#x2F;24</td>
<td>数据</td>
</tr>
</tbody></table></div>
<p>三：这个包会以广播的方式在发送端所处的子网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac</p>
</blockquote>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思</p>
<p>数据链路层的功能：定义了电信号的分组方式</p>
<hr>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>解决信号转换问题，基本都是数字信号，二进制数据控制的电路信号，电磁信号。</p>
</div><div class="post-reward"><div class="post-reward-btn" title="赞赏作者"><img src="/assets/images/svg/uc/uc-gift.svg" class="icon noview" alt="Icon"><span></span></div><div class="post-reward-content"><div class="post-reward-text"></div><div class="post-reward-list"><a href="/null" target="_blank">致谢名单</a></div></div></div><div class="post-copyright"><div class="post-copyright-info">本作品由 呼佳慧 于 2025-08-26 17:13:20 发布</div><div class="post-copyright-link"><span>作品地址：<a href="https://name9807.github.io/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/">计算机网络/25/8</a></span><button class="copy-text" type="button" data-text="https://name9807.github.io/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/">复制</button></div><div class="post-copyright-detail">除特别声明外，本站作品均采用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/' title='Attribution-NonCommercial-ShareAlike' target='_blank'>CC BY-NC-SA 4.0</a> 许可协议，转载请注明来自 <a href='/'>随便写吧</a></div><img class="post-copyright-icon noview" src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></div><div class="post-tail-tags"></div></div><aside id="post-sidebar" status="show"><div id="toc-container"><div class="toc-title"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"><span>目录</span></div><div class="toc-content" id="toc-div"><ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-list-text">计算机网络</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="toc-list-text">网络设备</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E7%90%86%E8%A7%A3OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-list-text">理解OSI七层协议</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-list-text">七层模型</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-list-text">应用层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-list-text">表示层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-list-text">会话层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-list-text">传输层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link"><span class="toc-list-text"></span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-3-5-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-list-text">2.3.5 应用层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#2-3-6-socket"><span class="toc-list-text">2.3.6 socket</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-list-text">网络层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-list-text">数据链路层</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-list-text">物理层</span></a></li></ol></li></ol></li></ol></div></div></aside></div></div><div id="toolbar" hide=""><div id="toolbar-setting-container" hide=""><div class="toolbar-item"><button id="tool-color-mode" title="深色模式" type="button"><img src="/assets/images/svg/ta/ta-moon.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button class="copy-text" id="tool-share" title="分享" type="button" data-text="https://name9807.github.io/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/"><img src="/assets/images/svg/ta/ta-share.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-plus" title="放大字体" type="button"><img src="/assets/images/svg/ta/ta-text-plus.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-minus" title="缩小字体" type="button"><img src="/assets/images/svg/ta/ta-text-minus.svg" class="icon noview" alt="Icon"></button></div></div><div class="toolbar-container"><div class="toolbar-item"><button id="tool-setting" title="设置" type="button"><img src="/assets/images/svg/ta/ta-setting.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-toc" title="目录" type="button"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-gototop" title="返回顶部" type="button"><img src="/assets/images/svg/ta/ta-up.svg" class="icon noview" alt="Icon"></button></div></div></div></main><footer><div class="footer"><div id="footer-copyright">© 2024 - 2025 <span>💗</span> <a href="/null">呼佳慧</a></div><div id="footer-info"><div id="footer-framework">🚀本站由 <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/chanwj/hexo-theme-meow" title="3.1.0" target="_blank">Meow</a> 强力驱动</div><div id="footer-runtime"><span id="runtime" data-startdate="2024-04-02T22:16:20.000Z">🌻已稳定运行.年.月.天</span></div></div></div></footer><div class="scripts"><script>const GLOBALCONFIG = {
  root: '/',
  toolbar: true,
  lazyload_src: '/assets/images/Meow-Loading.webp',
  friends: false,
  codeblock: true,
  share_text: '🐱Share From Meow',
  onblur_title: 'Please Come Back～✧(´▽`ʃ♡ƪ)',
  mouse_click: false,
  notify:{
    enable: false,
    info: '复制成功～转载请标注本文地址',
    f12_info: '开发者模式已打开，请遵循本站版权协议'
  },
  search: {
    enable: false,
    path: 'search.json',
    local: {
      top_n_per_article: 1,
      preload: false
    }
  },
  encrypt: false,
};
</script><script>if (!localStorage.getItem('color-mode')) {
  localStorage.setItem('color-mode', 'light' || 'light');
}
document.body.setAttribute('data-mode', localStorage.getItem('color-mode'));
</script>
<script src="/js/theme/tools/utils.js"></script>

<script src="/js/plugins/dist/lazyload.min.js"></script>

<script src="/js/plugins/view-image.min.js"></script>
<script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/main.js" type="module"></script>
</div></body></html>