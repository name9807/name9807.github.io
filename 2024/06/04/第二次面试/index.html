<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="呼佳慧"/><meta name="copyright" content="呼佳慧"/><meta name="theme-color" content="#FFB347"/><meta name="format-detection" content="telephone=no"/><meta name="keywords" content="Hexo Theme MEOW"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><meta name="application-name" content="第二次面试 | 随便写吧"/><meta name="apple-mobile-web-app-title" content="第二次面试 | 随便写吧"/><meta name="apple-mobile-web-app-status-bar-style" content="#FFB347"/><link rel="canonical" href="https://name9807.github.io/2024/06/04/第二次面试/"/><meta name="description" content="HTML部分 前端的发展历史  前端技术的发展历史可以概括为以下几个阶段：  静态页面时代（1990s）：在互联网初期，网页主要是由HTML（Hypertext Markup Language）构成，呈现为静态页面，内容和样式都比较简单。 动态网页时代（2000s）：随着JavaScript（JS）的兴起，网页开始呈现出动态效果。AJAX（Asynchronous JavaScript an...">
<meta property="og:type" content="article">
<meta property="og:title" content="第二次面试 | 随便写吧">
<meta property="og:url" content="https://name9807.github.io/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="随便写吧">
<meta property="og:description" content="HTML部分 前端的发展历史  前端技术的发展历史可以概括为以下几个阶段：  静态页面时代（1990s）：在互联网初期，网页主要是由HTML（Hypertext Markup Language）构成，呈现为静态页面，内容和样式都比较简单。 动态网页时代（2000s）：随着JavaScript（JS）的兴起，网页开始呈现出动态效果。AJAX（Asynchronous JavaScript an...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://name9807.github.io/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/assets/images/Hexo-Theme-MEOW.png">
<meta property="article:published_time" content="2024-06-04T12:52:47.000Z">
<meta property="article:modified_time" content="2025-09-17T09:19:14.382Z">
<meta property="article:author" content="呼佳慧">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://name9807.github.io/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/assets/images/Hexo-Theme-MEOW.png"><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="revisit-after" content="1 days"/><title>第二次面试 | 随便写吧</title><link rel="shortcut icon" href="/assets/images/Hexo-Theme-MEOW.ico"><link rel="preconnect" href="/assets"/><link rel="preconnect" href="assets"/>
<link rel="stylesheet" href="/css/style.css">
<link rel="prefetch" href="/"/><link rel="prefetch" href="/archives"/><link rel="prefetch" href="/tags"/><meta name="generator" content="Hexo 7.1.1"></head><body bg-style="none"><header><div id="navbar"><div id="nav-info"><a id="site-icon" href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a id="site-name" href="/" title="主页"><div>随便写吧</div><img src="/assets/images/svg/uc/uc-home.svg" class="icon noview" alt="Icon"></a></div><div id="nav-menu"></div><div id="nav-function"><div id="menu-btn"><a href="javascript:void(0);" title="打开菜单"><img src="/assets/images/svg/uc/uc-menu.svg" class="icon noview" alt="Icon"></a></div></div></div></header><div id="menu-aside"><div id="menu-aside-container"><div id="menu-aside-info"><a href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a href="/" title="主页">随便写吧</a></div><hr/></div></div><main><div class="banner"><div class="banner-info"><div class="banner-avatar"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Avatar"/></div><div class="banner-title">「 MEOW 」</div></div></div><div class="post-container"><div class="post-main"><div class="post-content"><h1 class="post-title">第二次面试</h1><div class="post-author"><span>作者: 呼佳慧</span></div><div class="post-meta"><div class="post-info"><div class="post-date"><div class="post-pubdate"><img src="/assets/images/svg/ta/ta-pubdate.svg" class="icon noview" alt="Icon"><span>发表于2024-06-04</span></div><div class="post-update"><img src="/assets/images/svg/ta/ta-update.svg" class="icon noview" alt="Icon"><span>更新于2025-10-21</span></div></div><div class="post-read"></div></div><div class="post-attribute"><div class="post-categories"><img src="/assets/images/svg/ta/ta-category.svg" class="icon noview" alt="Icon"><span><a class="post-categories-link" href="/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/">面试记录</a></span></div></div></div><div class="post markdown" indent="false"><h1 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h1><ol>
<li><p>前端的发展历史</p>
<p> 前端技术的发展历史可以概括为以下几个阶段：</p>
<ol>
<li><strong>静态页面时代（1990s）</strong>：在互联网初期，网页主要是由HTML（Hypertext Markup Language）构成，呈现为静态页面，内容和样式都比较简单。</li>
<li><strong>动态网页时代（2000s）</strong>：随着JavaScript（JS）的兴起，网页开始呈现出动态效果。AJAX（Asynchronous JavaScript and XML）技术的出现使得网页能够异步加载数据，提升了用户体验。同时，CSS（Cascading Style Sheets）的发展也为网页提供了更丰富的样式设计能力。</li>
<li><strong>RIA（Rich Internet Application）时代（2000s）</strong>：随着Flash和Silverlight等技术的出现，网页应用的交互性和多媒体性得到了大幅提升，使得网页应用能够更接近传统桌面应用的体验。</li>
<li><strong>移动优先时代（2010s至今）</strong>：随着智能手机和平板电脑的普及，移动端访问网页的比例逐渐增加。响应式设计（Responsive Web Design）和移动端优化成为前端开发的重要趋势。同时，HTML5、CSS3以及ES6（ECMAScript 2015）等新技术的出现，为前端开发提供了更多功能和性能上的支持。</li>
<li><strong>现代前端框架时代（2010s至今）</strong>：出现了一系列前端框架和库，如AngularJS、React、Vue.js等，它们提供了更高效、更灵活的开发方式，大大提升了前端开发的效率和可维护性。同时，前端工程化（如Webpack、Babel等）和组件化（如Web Components）也成为了前端开发的重要实践。</li>
<li><strong>WebAssembly时代（2010s至今）</strong>：WebAssembly（简称Wasm）是一种可以在网页浏览器中运行的低级字节码格式，可以让开发者使用其他编程语言（如C++、Rust等）编写高性能的Web应用。WebAssembly的出现为前端开发带来了全新的可能性，使得前端应用能够更加强大和复杂。</li>
</ol>
<p> 随着技术的不断发展和演进，前端开发也在不断变化和完善，成为了互联网应用开发中不可或缺的重要组成部分。</p>
</li>
<li><p>html5新特性</p>
<ol start="3">
<li><p><strong>语义化标签</strong>：引入了一些新的语义化标签，如 <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>等，使得页面结构更清晰。</p>
</li>
<li><p><strong>多媒体支持</strong>：增强了对多媒体内容的支持，包括 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签，可以直接在网页中嵌入音频和视频。</p>
</li>
<li><p><strong>Canvas绘图</strong>：引入了 <code>&lt;canvas&gt;</code> 标签，使得在网页中可以通过JavaScript进行动态绘图。</p>
</li>
<li><p><strong>SVG支持</strong>：增强了对SVG（可缩放矢量图形）的支持，可以将SVG作为图像嵌入到HTML文档中，并通过CSS和JavaScript进行控制。</p>
</li>
<li><p><strong>表单控件</strong>：引入了新的表单输入类型，如 <code>&lt;input type=&quot;date&quot;&gt;</code>, <code>&lt;input type=&quot;email&quot;&gt;</code>等，以及新的表单属性，如 <code>required</code>, <code>placeholder</code>等，提高了表单的功能和用户体验。</p>
</li>
<li><p><strong>本地存储</strong>：引入了本地存储技术，包括LocalStorage和SessionStorage，使得网页可以在客户端存储数据，提高了网页的性能和用户体验。</p>
</li>
<li><p><strong>Web Workers</strong>：引入了Web Workers，使得网页可以在后台运行多线程JavaScript代码，提高了网页的性能和响应能力。</p>
</li>
<li><p><strong>地理位置</strong>：引入了地理位置API，使得网页可以获取用户的地理位置信息，用于定位服务和个性化内容。</p>
</li>
<li><p><strong>WebSockets</strong>：引入了WebSockets，使得网页可以建立持久的双向通信连接，实现实时数据传输。</p>
</li>
<li><p><strong>拖放</strong>：引入了拖放API，使得网页可以实现拖放操作，提高了用户与网页的交互体验。</p>
</li>
</ol>
</li>
<li><p>如何理解html语义化</p>
<p> HTML语义化是指在编写HTML代码时，使用恰当的HTML元素来表达文档的结构和含义，以使页面结构清晰、易于理解，并且对搜索引擎和辅助技术（如屏幕阅读器）友好。这意味着使用适合内容的语义元素，如<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;aside&gt;</code>等，而不是仅仅依赖于<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>元素来定义页面结构。</p>
<p> 通过语义化HTML，可以提高页面的可访问性、搜索引擎优化（SEO），以及代码的可维护性。例如，使用<code>&lt;nav&gt;</code>元素来表示导航菜单，使用<code>&lt;footer&gt;</code>元素来表示页面底部，使用<code>&lt;article&gt;</code>元素来包含独立的文章内容等，都能够更清晰地传达页面的意图和结构。</p>
</li>
<li><p>前端数据持久化存储 </p>
<p> 前端数据持久性存储是指在客户端（如浏览器）中存储数据，使其在页面重新加载、关闭或重新打开后仍然保持可用状态的能力。在前端开发中，有几种常见的方式来实现数据的持久性存储：<br> Cookies（Cookie）：Cookies是存储在用户计算机上的小型文本文件，可以通过浏览器发送给服务器。Cookies通常用于存储少量的数据，并且有大小限制（通常为4KB）。虽然Cookies在某些情况下是一种方便的持久性存储方式，但它们不适合存储大量数据，并且受到安全性和隐私性的限制。<br> Web Storage（Web存储）：Web Storage包括了两种机制：Session Storage和Local Storage。它们都允许在浏览器中存储键值对，并且具有较高的存储容量（通常为5MB）。Session Storage存储的数据在当前会话结束后被清除，而Local Storage存储的数据则会持久保存，直到用户手动清除或网站清除为止。<br> IndexedDB（索引数据库）：IndexedDB是一个浏览器内置的NoSQL数据库，允许在客户端存储大量结构化数据，并支持复杂的查询。IndexedDB提供了比Web Storage更强大的功能，但也更复杂一些，需要一定的学习和开发成本。<br> Cache API（缓存API）：Cache API允许开发者在浏览器中缓存网络请求的响应，以便在之后的访问中提供离线访问和快速加载。虽然缓存API通常用于缓存网络资源而不是用户数据，但也可以用于实现一些简单的数据持久性存储。<br> 选择合适的前端数据持久性存储方式取决于项目需求、数据量、安全性要求以及对于功能和复杂度的需求。</p>
</li>
</ol>
<h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><ol>
<li><p>用css实现三角形<br> border,clip-path:poligon,线性渐变</p>
</li>
<li><p>position的情况</p>
<ol>
<li><strong>static（默认值）</strong>：元素遵循正常文档流，即元素出现在文档中的位置。</li>
<li><strong>relative</strong>：元素相对于其正常位置进行定位，但是在布局中仍然占据原本的空间。</li>
<li><strong>absolute</strong>：元素相对于其最近的已定位（position不是static）的祖先元素进行定位，如果不存在已定位的祖先元素，则相对于初始包含块（通常是文档的视口）进行定位。元素脱离文档流，不占据空间。</li>
<li><strong>fixed</strong>：元素相对于视口进行定位，即无论页面滚动与否，元素始终位于固定的位置。也是脱离文档流的位置。</li>
<li><strong>sticky</strong>：元素根据用户的滚动位置在父元素内定位。它的行为就像position:relative;当元素在屏幕中时（即元素的位置距离顶部的距离小于或等于指定的top值），它的行为就像position:fixed;直到达到指定的位置。</li>
</ol>
</li>
<li><p>flex十个属性</p>
</li>
<li><p>重绘和回流</p>
<p> <strong>重绘 （</strong>**<code>Redraw</code>**<strong>）</strong>：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）。</p>
<p> 例如：修改元素的填充颜色，会触发重绘。</p>
<p> <strong>回流（重排）（</strong>**<code>Reflow</code>**<strong>）</strong>：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点）。</p>
<p> 例如：改元素的宽高，会触发重排。</p>
</li>
</ol>
<h1 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h1><ol>
<li><p>数组和字符串方法8个</p>
</li>
<li><p>数组方法<br>1. push,pop<br>2. shift,unshift<br>3. splice,reverse<br>4. join连成字符串<br>5. length,at,indexof<br>6. map带有返回值,foreach不带返回值<br>7. filter<br>8. refuce,升序对每个数组元素调用回调函数,回调中两个参数,第一个是上一次调用的返回值,第二个事数组元素当前值-&gt;与其他<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95">迭代方法</a>不同，<code>reduce()</code> 不接受 <code>thisArg</code> 参数。<code>callbackFn</code> 调用时始终以 <code>undefined</code> 作为 <code>this</code> 的值，如果 <code>callbackFn</code> 未处于严格模式，则该值将被替换为 <code>globalThis</code>。<br>9. sort原地对数组排序韩慧该数组的引用<br><br><br> function(a, b){return a-b}升序<br> function(a, b){return b-a}降序</p>
<ol start="2">
<li><p>字符串方法</p>
</li>
<li><p>字符串拼接concat(适用于数组)</p>
</li>
<li><p>字符串切片方法</p>
<ol>
<li><p>slice传入起始位置和末位置,负数表示倒数第几位,,start大于end会返回空串</p>
</li>
<li><p>substr传入两个参数第一个是起始位置,第二个是截取长度</p>
</li>
<li><p>substring两个参数第一个是起始位置和末尾,start大于end会交换位置,不接受负数参数</p>
</li>
</ol>
</li>
<li><p>split将字符串打碎成数组</p>
</li>
<li><p>tolowerCase,toUpperCase大小写转换</p>
</li>
<li><p>includes检查字符串是否有,两个参数,第一个子串内容,第二个搜索起始位置,返回bool</p>
</li>
</ol>
</li>
<li><p>数组去重,要求严格</p>
</li>
</ol>
<ul>
<li>最简单的是用集合,还可以用splice,错在j的位置不对</li>
</ul>
<ol start="5">
<li><p>在arr的原型上添加each的方法</p>
</li>
<li><p>调用栈和调用位置,</p>
<ol>
<li>调用栈：为了到达当前执行位置所调用的所有函数</li>
<li>调用位置：函数被调用的位置，当前正在执行的函数的前一个调用中</li>
</ol>
</li>
<li><p>全部隐士类型转化</p>
</li>
</ol>
<p>  ​	在相等运算中,有bool,bool值先转化成数字</p>
<p>  ​	空数组和空对象相加都转换成字符串,空数组转换成空串,对象转换”[objec Object]”</p>
<p>  ​	空数组本身在js中被认为是真的,而在比较运算时转换空串或0都被被视为假</p>
<p>  ​	在空数组相加时,空数组与布尔值相加时都会转换成字符串,拼串</p>
<p>  ​	数字家字符串,将数字转换为字符串,数字减字符串,字符串变数字,能变就转,不能变就nan</p>
<p>  ​	首先，让我们分解表达式 <code>!+[]</code>：</p>
<pre><code>1. `[]` 表示一个空数组。
2. `+[]` 将空数组转换为数字。空数组经过类型转换后，会变成数字 `0`。
3. `!+[]` 对数字 `0` 进行逻辑非操作。在 JavaScript 中，逻辑非操作符 `!` 会将其操作数转换为布尔值，并返回其相反值。由于 `0` 被视为假值，所以 `!0` 的结果是 `true`。
</code></pre>
<p>  所以，<code>!+[]</code> 返回的结果是 <code>true</code>。</p>
<p>  ​	当数组参与比较时:<br>            1. 如果另一个操作数是字符串,数组转化为字符串[1,2,3]-&gt;”1,2,3”<br>            2.  如果另一个操作数是数字,数组转化为数字<br>      		- 数组为空转换为0<br>        		- 包含一个元素,这个元素被作为数字值<br>          		- 包含多个元素,不确定</p>
<h4 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h4><p>在 JavaScript 中，闭包是指在一个函数内部定义的函数可以访问到该函数作用域内的变量，即使在外部函数执行完毕后仍然可以访问到这些变量。当内层函数执行完毕时，外层函数的作用域并不会被立即销毁，只有当不存在对外层函数作用域内变量的引用时，外层函数的作用域才会被垃圾回收</p>
<p>原题目:</p>
<div class="code-container" code-lang="Javascript"><div class="codebox"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a++</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">out</span>()()</span><br><span class="line"><span class="title function_">out</span>()()</span><br><span class="line"><span class="keyword">let</span> x = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">x</span>()</span><br><span class="line"><span class="title function_">x</span>()</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li>在这个题目中执行out()()的时候先执行外层函数,此时存在a&#x3D;10,接着执行内层函数,这时外层函数变量a仍然可以访问,而外层函数本身不可访问,外层函数被销毁,a没有被销毁,此时a++是11</li>
<li>out()()执行完毕后这两个函数内都被销毁,而再次执行时,会重新产生这个a,依然是10+1&#x3D;11</li>
<li>而当x成为这个内层函数的引用是,由于这个引用一直存在,所以这个a没有被销毁,所以会累加11,12</li>
<li>只有当x&#x3D;null类似的东西写了之后才可以释放a</li>
</ul>
<h4 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h4><ol>
<li><p>标记清除:</p>
<p> 它的基本原理是通过标记在执行上下文中仍然可访问的对象，然后清除未标记的对象。垃圾回收器会从根部对象开始遍历内存中的对象，标记所有可以访问的对象，然后清除未被标记的对象，即认定为垃圾。</p>
</li>
<li><p>引用计数:</p>
<p> 它的原理是通过跟踪每个对象被引用的次数来判断对象是否可以被回收。当一个对象的引用计数变为零时，表示该对象不再被引用，可以被垃圾回收器回收。</p>
</li>
</ol>
<p>原题同上</p>
<h4 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h4><ol>
<li>默认绑定:无法使用其他规则,一般是直接调用</li>
<li>隐式绑定:函数调用中的this绑定到调用这个函数的这个上下文对象<br> 隐式丢失:如果为函数创建别名或者在别的函数中作为回调函数被调用,就会丢失,绑定全局,但是如果是在对象中的属性名调用不会丢失</li>
<li>显示绑定:<ul>
<li>硬绑定:通过bind将对象绑定到该函数,以后无论怎么调用,this都不变bind,this被绑定给特定对象,但是可以被覆盖call,apply(apply是接受参数数组)</li>
</ul>
</li>
<li>new绑定:在js中,new执行的机制是先创建一个空对象,再进行原型的连接,并且将新对象绑定到函数调用的this</li>
<li>特例:<ul>
<li>null或undefined没有包装类,所以采用显示绑定会被忽略,实际采用默认绑定规则</li>
<li>间接引用(p.foo &#x3D; o.<strong>foo</strong>)(); <em>&#x2F;&#x2F; 2</em>,其实this是window</li>
<li>软绑定,其实是特例<strong>并不是和硬绑定</strong>相对,他可以当应用默认绑定时改成指定的this</li>
<li>箭头函数根据外层作用域决定this</li>
</ul>
</li>
</ol>
<p>原题</p>
<div class="code-container" code-lang="Javascript"><div class="codebox"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn1&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&quot;outer&quot;</span>,</span><br><span class="line">  fn1,</span><br><span class="line">  <span class="attr">fn2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn2&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fn4</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn4&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fn5</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn5&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">fn6</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn6&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">fn6</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;demo&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">demo</span>(); </span><br><span class="line">    <span class="keyword">var</span> demo2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;demo2&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">demo2</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn1</span>(); <span class="comment">//fn1  obj </span></span><br><span class="line">obj.<span class="title function_">fn2</span>(); <span class="comment">// fn2 obj</span></span><br><span class="line">obj.<span class="title function_">fn4</span>();<span class="comment">//fn4 window</span></span><br><span class="line">obj.<span class="title function_">fn5</span>(); <span class="comment">//fn5 obj;  fn6 obj;---因为箭头函数指向父作用域this </span></span><br><span class="line"><span class="comment">//demo undefined; demo2 undefined</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<h4 id="js包装类"><a href="#js包装类" class="headerlink" title="js包装类"></a>js包装类</h4><p>在JavaScript中，包装类（Wrapper Class）是一种特殊的对象，它们用来给基本数据类型（如字符串、数字和布尔值）提供对象形式的方法和属性。JavaScript中的基本数据类型是原始值，它们是不可变的，因此无法直接调用方法或访问属性。为了解决这个问题，JavaScript引入了包装类，它们在使用基本数据类型时会自动创建，并且可以提供一些额外的方法和属性。</p>
<p>当我们在基本数据类型上调用方法或访问属性时，JavaScript会自动将其转换为相应的包装类对象，执行操作后再转换回原始值。这个过程称为自动装箱和拆箱</p>
<p>只有null和undefined没有包装类</p>
<h4 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h4><h3 id="节流（Throttling）："><a href="#节流（Throttling）：" class="headerlink" title="节流（Throttling）："></a>节流（Throttling）：</h3><p>节流是指限制函数的执行频率，确保函数在一定时间间隔内只执行一次。它适用于需要在用户频繁触发事件时控制函数执行的情况，比如滚动事件或者鼠标移动事件。节流可以防止函数被频繁调用，从而减少性能开销。</p>
<h3 id="防抖（Debouncing）："><a href="#防抖（Debouncing）：" class="headerlink" title="防抖（Debouncing）："></a>防抖（Debouncing）：</h3><p>防抖是指在函数连续触发的情况下，只有在某个时间段内没有新的触发事件发生时，才执行该函数。它适用于需要等待用户停止某个连续操作后再执行某个函数的情况，比如搜索框输入事件或者窗口大小改变事件。防抖可以避免函数被频繁调用，提高性能和用户体验。</p>
<h4 id="可迭代性"><a href="#可迭代性" class="headerlink" title="可迭代性"></a>可迭代性</h4><p>生成器函数:</p>
<p><code>function*</code> 是 JavaScript 中的一个语法，用于定义一个生成器函数（Generator Function）。生成器函数是一种特殊类型的函数，可以通过 <code>yield</code> 关键字来暂停执行，并在需要时恢复执行。生成器函数使用 <code>function*</code> 关键字进行定义，并在函数体内部使用 <code>yield</code> 关键字来产生（yield）一个序列的值。这使得生成器函数能够以惰性的方式生成一系列的值，而不需要一次性将它们全部计算出来，这对于处理大量数据或者需要按需获取值的情况非常有用。</p>
<p>以下是一个简单的生成器函数示例：</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码function* generatorFunction() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建生成器对象</span><br><span class="line">const generator = generatorFunction();</span><br><span class="line"></span><br><span class="line">// 通过调用 next() 方法逐个获取生成器函数产生的值</span><br><span class="line">console.log(generator.next().value); // 输出: 1</span><br><span class="line">console.log(generator.next().value); // 输出: 2</span><br><span class="line">console.log(generator.next().value); // 输出: 3</span><br><span class="line">console.log(generator.next().value); // 输出: undefined，因为已经没有更多的值了</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>在上面的示例中，<code>generatorFunction</code> 是一个生成器函数，它通过 <code>yield</code> 关键字产生了三个值。通过调用 <code>generator.next()</code> 方法可以逐个获取这些值，每次调用 <code>next()</code> 方法都会从上一次暂停的地方继续执行，直到函数执行完成或者遇到 <code>return</code> 语句。</p>
<p>生成器函数的另一个特点是可以通过 <code>yield*</code> 关键字委托给另一个生成器函数或可迭代对象，从而实现更复杂的生成器行为。</p>
<p>在 JavaScript 中，<code>for...in</code> 是一种用于遍历对象属性的循环结构。它会遍历对象的可枚举属性，包括继承的属性。具体来说，<code>for...in</code> 循环会迭代对象的每一个可枚举属性，并在每次迭代中将属性名称赋给指定的变量，然后执行指定的代码块。</p>
<p>下面是 <code>for...in</code> 循环的基本语法：</p>
<div class="code-container" code-lang="Javascript"><div class="codebox"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// code block to be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>其中：</p>
<ul>
<li><code>variable</code> 是一个在每次迭代中将被赋值为当前属性名称的变量。</li>
<li><code>object</code> 是要迭代的对象。</li>
</ul>
<p>示例：</p>
<div class="code-container" code-lang="Javascript"><div class="codebox"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + person[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>在上面的示例中，<code>for...in</code> 循环遍历了 <code>person</code> 对象的每一个属性，并在每次迭代中将属性名称赋给 <code>key</code> 变量，然后输出属性名称和对应的属性值。</p>
<p>需要注意的是，<code>for...in</code> 循环不仅会遍历对象自身的属性，还会遍历从原型链上继承的属性。如果只想遍历对象自身的属性而不包括继承的属性，可以通过 <code>Object.hasOwnProperty()</code> 方法来过滤：</p>
<div class="code-container" code-lang="Javascript"><div class="codebox"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="comment">// code block to be executed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<p>这样就可以只遍历对象自身的属性了。</p>
<h1 id="vue部分"><a href="#vue部分" class="headerlink" title="vue部分"></a>vue部分</h1><ol>
<li><p>实现父子通信三种方法</p>
<ol>
<li>使用props配置项,父组件写键值对传东西,子组件写props收东西,<strong>props不可以修改</strong></li>
<li>全局事件总线,在vm那写一个beforecreated里面让Vue.prototype.$bus&#x3D;this(vm)<br> 事件触发时,子组件用this.$bus.$emit(‘名字’,参数),接受方组件用this.$bus.$on绑定(‘名字’,数据处理的函数</li>
</ol>
</li>
<li><p>ref子组件通信,child</p>
</li>
<li><p>v-指令5个</p>
</li>
<li><p>商品名字<xxx>商品1&lt;&#x2F;&gt;</p>
</li>
<li><p>v-model,父组件,son</p>
</li>
<li><p>data为什么只能写函数返回值<br> 在Vue中，<code>data</code> 选项通常用于定义组件的初始数据。为了确保每个组件实例都有自己独立的数据副本，Vue 在创建组件实例时会将 <code>data</code> 选项的值进行初始化。然而，如果直接将对象赋值给 <code>data</code> 选项，那么所有的组件实例将共享同一个数据对象，这会导致状态不可预测的问题。</p>
</li>
<li><p>按顺序写生命周期函数</p>
</li>
</ol>
</div><div class="post-reward"><div class="post-reward-btn" title="赞赏作者"><img src="/assets/images/svg/uc/uc-gift.svg" class="icon noview" alt="Icon"><span></span></div><div class="post-reward-content"><div class="post-reward-text"></div><div class="post-reward-list"><a href="/null" target="_blank">致谢名单</a></div></div></div><div class="post-copyright"><div class="post-copyright-info">本作品由 呼佳慧 于 2024-06-04 20:52:47 发布</div><div class="post-copyright-link"><span>作品地址：<a href="https://name9807.github.io/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/">第二次面试</a></span><button class="copy-text" type="button" data-text="https://name9807.github.io/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/">复制</button></div><div class="post-copyright-detail">除特别声明外，本站作品均采用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/' title='Attribution-NonCommercial-ShareAlike' target='_blank'>CC BY-NC-SA 4.0</a> 许可协议，转载请注明来自 <a href='/'>随便写吧</a></div><img class="post-copyright-icon noview" src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></div><div class="post-tail-tags"></div></div><aside id="post-sidebar" status="show"><div id="toc-container"><div class="toc-title"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"><span>目录</span></div><div class="toc-content" id="toc-div"><ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#HTML%E9%83%A8%E5%88%86"><span class="toc-list-text">HTML部分</span></a></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#css%E9%83%A8%E5%88%86"><span class="toc-list-text">css部分</span></a></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#js%E9%83%A8%E5%88%86"><span class="toc-list-text">js部分</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E8%8A%82%E6%B5%81%EF%BC%88Throttling%EF%BC%89%EF%BC%9A"><span class="toc-list-text">节流（Throttling）：</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88Debouncing%EF%BC%89%EF%BC%9A"><span class="toc-list-text">防抖（Debouncing）：</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#vue%E9%83%A8%E5%88%86"><span class="toc-list-text">vue部分</span></a></li></ol></div></div></aside></div></div><div id="toolbar" hide=""><div id="toolbar-setting-container" hide=""><div class="toolbar-item"><button id="tool-color-mode" title="深色模式" type="button"><img src="/assets/images/svg/ta/ta-moon.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button class="copy-text" id="tool-share" title="分享" type="button" data-text="https://name9807.github.io/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/"><img src="/assets/images/svg/ta/ta-share.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-plus" title="放大字体" type="button"><img src="/assets/images/svg/ta/ta-text-plus.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-minus" title="缩小字体" type="button"><img src="/assets/images/svg/ta/ta-text-minus.svg" class="icon noview" alt="Icon"></button></div></div><div class="toolbar-container"><div class="toolbar-item"><button id="tool-setting" title="设置" type="button"><img src="/assets/images/svg/ta/ta-setting.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-toc" title="目录" type="button"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-gototop" title="返回顶部" type="button"><img src="/assets/images/svg/ta/ta-up.svg" class="icon noview" alt="Icon"></button></div></div></div></main><footer><div class="footer"><div id="footer-copyright">© 2024 - 2025 <span>💗</span> <a href="/null">呼佳慧</a></div><div id="footer-info"><div id="footer-framework">🚀本站由 <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/chanwj/hexo-theme-meow" title="3.1.0" target="_blank">Meow</a> 强力驱动</div><div id="footer-runtime"><span id="runtime" data-startdate="2024-04-02T22:16:20.000Z">🌻已稳定运行.年.月.天</span></div></div></div></footer><div class="scripts"><script>const GLOBALCONFIG = {
  root: '/',
  toolbar: true,
  lazyload_src: '/assets/images/Meow-Loading.webp',
  friends: false,
  codeblock: true,
  share_text: '🐱Share From Meow',
  onblur_title: 'Please Come Back～✧(´▽`ʃ♡ƪ)',
  mouse_click: false,
  notify:{
    enable: false,
    info: '复制成功～转载请标注本文地址',
    f12_info: '开发者模式已打开，请遵循本站版权协议'
  },
  search: {
    enable: false,
    path: 'search.json',
    local: {
      top_n_per_article: 1,
      preload: false
    }
  },
  encrypt: false,
};
</script><script>if (!localStorage.getItem('color-mode')) {
  localStorage.setItem('color-mode', 'light' || 'light');
}
document.body.setAttribute('data-mode', localStorage.getItem('color-mode'));
</script>
<script src="/js/theme/tools/utils.js"></script>

<script src="/js/plugins/dist/lazyload.min.js"></script>

<script src="/js/plugins/view-image.min.js"></script>
<script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/main.js" type="module"></script>
</div></body></html>