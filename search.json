[{"title":"DOM","url":"/2024/03/02/DOM/","content":"DOM对象dom\ndom对象是浏览器根据html标签生成的js对象\ndom核心思想:将网页内容当做对象处理。\n\ndom树将html树状结构直观表现出来_直接体现标签与标签之间的关系\n\ndocument是dom里提供的一个对象,网页所有内容都在document里\n\n获取DOM元素\n根据css选择器来获取dom元素\n\ndocument.querySelectorAll(&#x27;css选择器&#x27;)//获得的是一个伪数组document.querySelector(&#x27;css选择器&#x27;)//获得匹配的第一个\n\n​\t\n\n其他方式获取\n\ndocument.getElementById(&#x27;id&#x27;)//一个document.getElementsByTagName(&#x27;div&#x27;)//伪数组document.getElementsByClassName(&#x27;id&#x27;)\n\n操作元素内容\n对象.innerText  :不会识别标签\n对象.innerHtml:会解析标签\n\n操作元素属性\n操作元素常用属性:直接加.属性\n\n操作元素样式属性\n\n对象.style.样式&#x3D;xx\n对象.className&#x3D;’样式类名’用新的换旧的\n对象.classList.add&#x3D;’ xxx’  追加新类  box.classList.remove&#x3D;’’删除类  box.classList.toggle&#x3D;’’切换类,没有就加上,有了就删除\n\n\n操作元素表单属性: .value获得或设置 .type .disabled禁用 .checked勾选 .selected\n\n自定义属性: data-自定义属性 对象.dataset.属性  获取所有的自定义属性,加.是某一个\n\n\n定时器-间歇函数\n开始定时器:setinterval(函数,间隔时间)\n作用:每隔一段时间调用这个函数,(单位是ms)返回值是定时器序号\n关闭定时器:let 变量名=setinterval(函数,间隔时间)clearInterval(变量名)//满足一定条件执行\n\n事件监听(绑定)\n什么是事件?  事件是在编程时系统内发生的动作或事情\n事件监听:元素对象.addEventListener(&#x27;事件类型&#x27;,要执行的函数)\n事件监听三要素:事件源:被触发的dom元素事件类型:click,mouseover,用什么方式出发调用的函数:要执行的事情\n事件类型:\n\n\n鼠标事件::click,mouseover,mouseleave\n焦点事件:focus,blur\n键盘事件:keydown,keyup\n表单输入事件:input\n\n事件对象事件对象是存储了事件触发相关信息的对象\n\n语法:如何获取\n元素.addEventListener(click,function(e)&#123;&#125;)//一般命名为e,是函数的第一个参数\n\n事件对象属性\n\ntype:click…\nclientX&#x2F;clientY:光标相对于可视窗口的位置\noffsetX&#x2F;offsetY:光标相对于当前dom元素左上角的位置\nkey:按下键盘的值\n\n\n\n事件流事件流是事件完整执行过程中的流动路径\n\n\n事件捕获DOM.addEventListener(事件类型,事件处理函数,是否使用捕获机制)//第三个参数传入true代表是捕获阶段出发(很少使用)false是冒泡触发\n事件冒泡当一个事件被触发时,依次触发祖先元素的同名事件\n阻止冒泡事件对象.stopPropagation()//组织事件流动传播\n解绑事件\n\n\non事件方法//绑定btn.onclick=function()&#123;&#125;//解绑事件btn.onclick=null\n普通:btn.removeEventListener(事件类型,函数)//匿名函数无法解绑\n\n\n鼠标经过事件的区别mouseover&#x2F;mouseout存在冒泡机制mouseenter&#x2F;mouseleave没有,推荐使用\n\n事件委托\n优点:减少注册次数,提高程序性能1\n原理:利用事件冒泡的特点\n\ne.target&#x3D;即所点击的元素\ne.targetName&#x3D;点击的标签名字的大写\n\n\n\n阻止默认行为e.preventDefault()//放在事件监听的函数里面\n其他事件\n页面加载事件:\n \n window.addEventListener(‘load’,函数)\n \n页面滚动事件\n\n\n\n\n\n元素.scrollTop:内容向上走超出顶部的距离\n元素.scrollLeft:同理\n\n\n页面尺寸事件: resize:窗口大小发生变化时发生的事件 clientWigth&#x2F;Height是可视窗口的宽&#x2F;高\n\n元素的尺寸和位置获取宽高:offsetWidth&#x2F;Height包含自身设置宽高和padding和border可视宽高\n获取位置:offsetLeft&#x2F;Top距离自己定位父级元素的左上角距离,是只读属性\n日期对象实例化const date&#x3D;new Date()实例化日期对象\n日期对象方法\n\n时间戳1970年1月1日起到现在的毫秒数\n\ngetTime():\n\n+newDate():将字符串变为数字型\n\nDate.now()\n\n\n节点操作DOM节点dom树的每一个内容都称为节点,\n节点类型\n元素节点:所有的标签,html是根节点\n属性节点:所有的属性\n文本节点:所有的文本\n\n查找节点\n父节点查找:子节点.parentNode,返回最近一父节点,找不到返回为空\n子节点查找:\nchildrenNodes:获得所有子节点,包括文本节点(空格换行),注释节点等\nchildren属性:获得所有元素节点,返回一个位数组\n\n\n兄弟节点查找:\n下一个兄弟:nextElementSibling\n上一个兄弟:previousElementSibling\n\n\n\n修改节点\n创建节点:document.createElement(‘标签名’)\n追加节点:\n父元素.appendChildren(对象)\n父元素.insertBefore(要插入的元素,在那个元素前面)\n\n\n克隆节点:元素.cloneNode(布尔值)&#x2F;&#x2F;是否复制该节点的子代节点\n删除节点:父元素.removeChild(要删除的元素)\n\nM端事件\n\n\njs插件BOMbom是浏览器对象模型,bom包含dom\n定时器-延时函数\nsetTimeout(回调函数,等待的毫秒数)\n清楚延迟函数:clearTimeout(延时器的id)\n\njs执行机制\n\n\n\n\nlocation对象location.href&#x3D;xxx可以利用js实现跳转页面\nnavigator对象浏览器的相关信息\nhistory对象实现网页后退和前进back()&#x2F;forward()go(1&#x2F;-1)\n"},{"title":"html和css","url":"/2024/02/28/html/","content":"html骨架代码\nhead包含一些与文档相关的元数据和其他重要的信息，内容不会在浏览器中显示\ntitle定义文档的标题，不同的页面类型有不同的格式。比如：主页，一般是网页名称+主要关键词。详情页，一般是详情名称+网站名字+简介等等。\nlink指定当前文档与外部资源的关系\nmeta设置网页的元数据，例如字符集、描述、关键词等\nscript引入JavaScript代码或链接外部JavaScript文件。\n\n\nbody定义网页的主体内容，是HTML文档的一个必要组成部分，包含了所有对用户可见的网页内容，如文本、图像、链接、段落、标题、表格、表单等。\n\nhtml常用元素1. 标题标签，作为标题使用，并且依据重要性递减从h1到h6\n2. 段落标签，用于定义段落,可以将整个网页分为若干个段落p\n3. 换行标签和水平分隔线标签，在开发中用的很少，单标签\n换行: br\n加入水平分割线:hr\n都是单个出现的\n\n4. 文本格式化标签\n\n\n加粗\nb或者strong\n推荐使用语义化标签\n\n\n\n倾斜\nem或者i\n\n\n\n删除线\ndel或者s\n\n\n\n下划线\nins或者u\n\n\n\n5. 盒子标签,无特殊含义div或者span\n6. 图像标签，单标签img&#x2F;\n\n\n\n属性\n属性值\n说明\n\n\n\nsrc\n图片路径\n必须属性\n\n\nalt\n文本\n替换文本,图片不能显示时替换\n\n\ntitle\n文本\n提示文字,鼠标放到图上显示的文字\n\n\nwidth\n像素\n设置图像的宽度\n\n\nheight\n像素\n设置图像的高度\n\n\nborder\n像素\n设置图像的边框粗细\n\n\n7. 超链接标签a href&#x3D;”跳转目标” target&#x3D;”目标窗口的弹出方式”\n\n\n\n属性\n作用\n\n\n\nhref\n用于指定链接目标的ur地址，(必须属性)当为标签应用href属性时，它就具有了超链接的功能；\n\n\ntarget\n用于指定链接页面的打开方式，其中_self为默认值(在本窗口中打开)，_ blank为在新窗口中打开方式\n\n\n同时链接也可分类，如外部链接、内部链接、空链接、下载链接（地址是一个文件或者压缩包）等等\n8. 表格标签\n\n\nthead\n表格的标题\n\n\n\ntbody\n表格的主体\n\n\nth\n表头单元格\n\n\ntd\n单元格\n\n\ntr\n行\n\n\n\n- border：表示表格的边框宽度，单位是像素，即px；\n- rowspan：表示多行合并，可以指定具体要合并的行数；(不要忘记删除多余的单元格)\n- colspan：表示多列合并，可以指定具体要合并的列数；(不要忘记删除多余的单元格)\n- cellpadding：表示单元格边缘与其单元格内容之间的空白间距；\n- cellspacing：表示单元格之间的空白间距；\n- width：表示表格的宽度；\n- align：表示表格相对周围元素的对齐方式。\n\n9. 列表标签分为：有序列表、无序列表、自定义列表\n\n- 无序列表：使用 ul 标签，里面放着 li 标签，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。  ul 中只能嵌套 li 标签  li 中可以放任何标签  type属性可以指定列表项的符号类型，如：disc（默认）：小圆点，circle：空心圆圈，square：方块\n- 有序列表：使用 ol 标签，里面放着li标签，列表项目使用数字进行标记 ol 中只能嵌套li标签  type属性可以指定列表项的符号类型，如：i：罗马数字开始  start属性，指定起始编号。\n- 自定义列表：使用 dl 标签，dt 标签用来定义项目&#x2F;名字，dd描述每一个项目&#x2F;名字  dl 里面只能包含dt和 dd\n\n10. 表单标签\nform:表单域标签，表单域就是一个包含表单元素的区域\ninput:输入表单元素\nlabel:绑定一个表单元素，当点击 lable 标签内的文本时，会自动将焦点转到对应的表单元素上，lable 标签的for属性必须得与相关元素的id属性相同\nselect:下拉表单元素，用于定义一个下拉列表\noption:下拉列表中的元素，定义selected&#x3D;“selected”属性时，当前项为默认选中项\ntextarea:文本域元素，用于定义一个多行文本输入框，cols属性规定每行的字符数，rows属性规定显示的行数\n\ntype的属性值\n\n\n\n属性值\n描述\n\n\n\nbutton\n定义可点击按钮\n\n\ncheckbox\n定义复选框，一组复选框name属性必须相同\n\n\npassword\n定义密码字段，该字段中的字符被掩码\n\n\nradio\n定义单选按钮，一组单选按钮的name属性值必须相同\n\n\nreset\n定义重置按钮，清除表单中的所有数据\n\n\nsubmit\n定义提交按钮，提交到action属性指定的地址\n\n\ntext\n定义单行的输入字段，用户可在其中输入文本，默认宽度为20字符\n\n\n11. 注释和特殊字符\n\n\n\nHTML 原代码\n显示结果\n描述\n\n\n\n&amp;lt；\n&lt;\n小于号或显示标记\n\n\n&amp;gt；\n&gt;\n大于号或显示标记\n\n\n&amp;amp；\n&amp;\n可用于显示其它特殊字符\n\n\n&amp;quot；\n“\n引号\n\n\n&amp;reg；\n®\n已注册\n\n\n&amp;trade；\n™\n商标\n\n\n&amp;ensp；\n\n半个空白位\n\n\n&amp;emsp；\n\n一个空白位\n\n\n&amp;nbsp；\n\n不断行的空白\n\n\n特殊字符大全12. 常用的HTML5纯语义化标签\n分类(针对元素显示模式)\n\n\n元素模式\n元素排列\n是否能设置宽高\n默认宽度\n包含\n\n\n\n块级元素\n一行一个\n可以\n容器的100%\n- 标题标签：h1, h2, h3, h4, h5, h6- 段落标签：p- 换行标签： 水平分隔符标签：hr- div- …\n\n\n行内元素\n一行可以放多个\n不可以\n它本身内容的宽度\n- span- 图像标签：img- 文本格式化标签：i, em- 输入标签：input- …br\n\n\n行内快元素\n一行可以放多个\n可以\n它本身内容的宽度\n\n\n\ncss选择器的概念CSS选择器，是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。\n\n通配选择器由一个星号（*）代指它选中了文档中的所有内容。\n类型选择器也叫标签名选择器或者是元素选择器，它在文档中选择了一个 HTML 标签&#x2F;元素\n类选择器以一个句点（.）开头，会选择文档中应用了这个类的所有物件。\nid选择器开头为#而非句点，不过基本上和类选择器是同种用法。一个 ID 只会一般用到一次，虽然用多次也能正常显示，但是用javascript通过id来控制元素时就会出现错误。\n\n\n\nCascading是层叠的意思，层叠是 CSS 的一个基本特征，意为多个选择符之间具有特定的优先级，它是一个定义了如何合并来自多个源的属性值的算法。\n在同优先级的情况下，后定义的生效，不同级则优先级高的生效。各优先级关系，一般来说，选择器的优先级，范围越小，优先级越高id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配符选择器\n\n\ncss基本样式常用样式\nfont-size：字体大小 px\n\nfont-weight: normal; &#x2F;&#x2F;字体粗细\nfont-style: italic; &#x2F;&#x2F;字体倾斜\n\n\ntext-align：center； &#x2F;&#x2F;文本对齐\n 1. \n\ntext-decoration: none; &#x2F;&#x2F;无装饰\ntext-decoration: overline; &#x2F;&#x2F;上划线\ntext-decoration: line-through; &#x2F;&#x2F;中划线\ntext-decoration: underline; &#x2F;&#x2F;下划线\ntext-transform: uppercase; &#x2F;&#x2F;文本转换，全部换为大写字母\ntext-indent: 50px; &#x2F;&#x2F;首行缩进\nletter-spacing: 3px; &#x2F;&#x2F;字母间距\nword-spacing: 10px; &#x2F;&#x2F;单词间距\nline-height: 0.8; &#x2F;&#x2F;行间距\nwhite-space: nowrap; &#x2F;&#x2F;禁用html框中文字编辑时的换行符（不必懂）\ntext-shadow: 2px 2px 5px red; &#x2F;&#x2F;分别是文本的水平、垂直阴影以及阴影的模糊效果、阴影颜色\n\n\ncolor:字体颜色\n\nbackground:背景样式\n 1. \n\nbackground-color: blue; &#x2F;&#x2F;颜色名称方式\nbackground-color: rgb(255, 0, 0); &#x2F;&#x2F;RGB方式\nbackground-color: #ff0000; &#x2F;&#x2F;十六进制方式\nbackground-image: url(“bg.png”) ; &#x2F;&#x2F;设置背景图片\nbackground-size: contain&#x2F;cover; &#x2F;&#x2F; 图片相对于盒子的尺寸\nbackground-repeat: repeat-x; &#x2F;&#x2F;沿x方向阵列\nbackground-position: right top; &#x2F;&#x2F;设置背景图片初始位置\nbackground-attachment: fixed; &#x2F;&#x2F;背景图片是否随网页滑动\nbackground: #ffffff url(“tree.png”) no-repeat right top;&#x2F;&#x2F;简写形式\n\n\nheight，width，margin，padding、border\n  \n\n\nwidth: 300px;\nborder-style: solid; &#x2F;&#x2F; 边框样式\nborder-color: #ccc; &#x2F;&#x2F; 边框颜色\nborder-width: 15px; &#x2F;&#x2F; 边框宽度\nborder-radius: 5px; &#x2F;&#x2F; 允许你设置元素的外边框圆角,该属性是将这四个属性 border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius 简写为一个属性。\nborder: 15px solid green; &#x2F;&#x2F;边框粗细 实线 颜色 ，dotted是点线，double是双线，dashed是虚线\npadding: 50px;\nmargin: 20px;\n\n\noutline-style：轮廓样式\n\noutline-color: red; &#x2F;&#x2F;轮廓颜色\noutline-style: dotted; &#x2F;&#x2F;轮廓样式\noutline-width: thin; 轮廓宽度\noutline: 5px solid yellow; 简写轮廓属性\noutline-offset: 25px;&#x2F;&#x2F;轮廓偏移\n\n 轮廓（outline）与边框（border）的区别：\n\nborder 可应用于几乎所有有形的 html 元素，而 outline 是针对链接、表单控件等元素设计。\noutline 的效果将随元素的 focus 而自动出现(除非手动设置outline-style)，相应的由 blur 而自动消失。这些都是浏览器的默认行为，无需 JavaScript 配合 CSS 来控制。\noutline 是不占空间的，不会像 border 那样影响元素的尺寸或者位置，既不会增加额外的 width 或者 height\n对于input之类的表单控件，当你手动设置outline-style，它将不会采用默认的触发方式，而是直接显示，在没有手动设置outline-style的情况下，outline-width不生效\n\n\ncursor：pointer；&#x2F;&#x2F;鼠标呈现为指示链接的一只手\n\n\ncss伪元素和伪类什么是伪类伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。\n语法伪类就是开头为冒号的关键字\n常见伪类:\n\n:hover &#x2F;* 在用户将指针挪到元素上的时候才会激活 *&#x2F;\n:focus &#x2F;* 获得焦点的元素激活 *&#x2F;\n\n什么是伪元素伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。\n语法\n::after &#x2F;* 用来创建一个伪元素，作为已选中元素的最后一个子元素,通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素 &#x2F; ::before &#x2F; 用来创建一个伪元素，作为已选中元素的第一个子元素，其余同上 &#x2F; content &#x2F; 用于在元素的 ::before 和 ::after 伪元素中插入内容 *&#x2F;\n::after &#x2F;* 用来创建一个伪元素，作为已选中元素的最后一个子元素,通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素 &#x2F; ::before &#x2F; 用来创建一个伪元素，作为已选中元素的第一个子元素，其余同上 &#x2F; content &#x2F; 用于在元素的 ::before 和 ::after 伪元素中插入内容 *&#x2F;\n\nhtml和css的结合方式\n行内式：html中的标签属性 style ：适用于单纯只有一个标签需要设置时的特殊样式。如果多个标签需要应用同一个样式，建议采用内嵌式。\n内嵌式：建议在head中使用，使用标签 style 适用于当前页面多个标签使用同一个样式。\n外链式：link:适用于多个页面使用同一个样式时。\n\n代码规范保持统一如果你开始为项目指定规则或者独自工作，那么最重要的事情是让各方面都保持统一。统一在所有的地方都会起到实际作用，例如对类使用相同的命名常规，选择一种描述颜色的方式，或者维护一个统一的格式化方式（例如你是使用 Tab 还是空格来缩进代码？如果是空格，用多少个？）\n一直遵守一系列规则，你会在编写 CSS 的时候省去不少精神上的预负担，因为一些决定已经定型了。\n将css格式化成可读的形式CSS 不会管你使用哪种方式来进行格式化，我们自己的看法是，将每个属性值对放在新的一行会更好读。\n如果一个浏览器在解析你所书写的 CSS 规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的 CSS 声明。在你书写了错误的 CSS 代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的 CSS 代码的时候上述的情况同样会发生（直接忽略）。\n为css加注释在你的 CSS 里加入注释，不仅可以帮任何未来的开发者处理你的 CSS 文件，也可以在你离开项目一段时间后，帮你在回来时重新上手。\n你不必在你的 CSS 中给每个东西都加上注释，因为它们很多都是自解释的。你应该加上注释的是那些你因为某些原因做的特殊决定。\n或许你是照着一个教程来做事的，CSS 有些不够直观。此时，你应该在注释里面加入教程的 URL。你应该在你一年或者更长时间以后重新审视你的项目，但只是模模糊糊地想起来之前有个优秀的教程，不知道它在哪里的时候，感谢之前加入注释的自己。\n浏览器调试css\n\n网页布局\n传统布局：\n\n\n标准流（普通流）\n浮动流\n定位流\n\n\nflex布局\n\n前端布局方案不止以上两种\n标准流（普通流）\n标准流又称普通流，是浏览器默认的排版方式。\n标准流中元素会自动从左往右，从上往下进行排列。\n按照元素布局特性来分，主要有三类元素：块级元素、行内元素、行内块元素\n\n(具体见html部分标签的分类)\n浮动float使元素脱离了标准流，向左或向右移动，直到碰到父元素或另一个浮动元素的边缘为止\n参数\n\n\n\n属性值\n描述\n\n\n\nnone\n元素不浮动\n\n\nleft\n元素向左浮动\n\n\nright\n元素向右浮动\n\n\n前端组第三次培训\n本次培训内容\n\n\n标准流，浮动，定位\nFlex布局\n百度页面仿写\n第一次大作业\n\n\n网页布局的本质利用 CSS 将盒子摆放到相应的位置\n前端布局方案\n传统布局：\n\n\n标准流（普通流）\n浮动流\n定位流\n\n\nflex布局\n\n前端布局方案不止以上两种\n标准流（普通流）\n标准流又称普通流，是浏览器默认的排版方式。\n标准流中元素会自动从左往右，从上往下进行排列。\n按照元素布局特性来分，主要有三类元素：块级元素、行内元素、行内块元素\n块级元素：\n\n独占一行\n\n宽高内外边距都是可以设置的\n\ndiv,h1~h6,p……\n\n\n\n行内元素：\n\n宽高靠内容撑开，不能设置宽高，一行可以放多个，直到占满一行然后换行\n\nspan,button……\n\n行内块元素（既有行内元素特点，也有块级元素特点）\n\n宽高靠内容撑开 ，一行可以放多个\n\n宽高内外边距都是可以设置的\n\n\n\n\ninput、a……\n浮动float什么是浮动？使元素脱离了标准流，向左或向右移动，直到碰到父元素或另一个浮动元素的边缘为止\n用法 CSS选择器 &#123;    float: 属性值;&#125; .son1&#123;//设置class为son1的盒子向左浮动    float:left; &#125;\n\n参数\n\n\n\n属性值\n描述\n\n\n\nnone\n元素不浮动\n\n\nleft\n元素向左浮动\n\n\nright\n元素向右浮动\n\n\n特性：\n加了浮动的元素盒子是浮起来的，脱离了标准流，漂浮在其他标准盒子之上，原来的位置空了下来，漏给了标准流盒子\n浮动元素具有行内块元素特性\n浮动的元素是相互贴靠在一起的（没有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。\n浮动元素不会遮挡标准流中的文字， 浮动产生的目的最初是为了做文字环绕效果\n\n清除浮动为什么清除浮动在实现不给父元素定义宽高，由子元素决定父元素宽高时，如果子元素浮动了，脱离标准流，父元素高度为0，后面的元素就会到前面来。\n也就是说，清除浮动解决的是在父元素不方便给高度，子元素浮动不占位置导致父元素高度为0时，给标准流盒子造成的影响。\n\n清除浮动的本质是清除浮动造成的影响\n\n如果父盒子本身有高度，则不需要清除浮动\n\n清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。\n\n清除浮动主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题。\n\n\n清除浮动的方式1.额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）2.父级添加overflow属性（父元素添加overflow:hidden）（不推荐）3.使用after伪元素清除浮动（推荐使用）.clearfix:after&#123;/*伪元素是行内元素 正常浏览器清除浮动方法*/    content: &quot;&quot;;    display: block;    height: 0;    clear:both;    visibility: hidden;&#125;.clearfix&#123;    *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/&#125;\n\n​\t\n4.使用before和after双伪元素清除浮动 .clearfix:after,.clearfix:before&#123;    content: &quot;&quot;;    display: table;&#125;.clearfix:after&#123;    clear: both;&#125;.clearfix&#123;    *zoom: 1;&#125;\n\n定位position什么是定位让盒子固定在屏幕的一个位置\n浮动是多个块级元素在同一行显示，定位主要是有层叠的概念\n\n\n\n值\n语义\n\n\n\nstatic\n静态定位\n\n\nrelative\n相对定位\n\n\nabsolute\n绝对定位\n\n\nfixed\n固定定位\n\n\nsticky\n粘性定位\n\n\n相对定位relative\n不脱离标准流、保留原来位置\n参考点：原来的自身位置\n\n绝对定位absolute\n脱离标准流，不占用原来位置\n参考点：相对于离自己最近的 &#x3D;&#x3D;设置了定位&#x3D;&#x3D;的父元素移动\n如果没有祖先元素，或者祖先元素没定位，则以浏览器作为参照物\n行内元素设置了固定定位和绝对定位，会转为块\n\n固定定位fixed\n固定定位是元素固定于浏览器的可视区的位置，可以实现浏览器页面滚动时元素的位置不会改变\n脱离标准流，不占有原来位置\n参考点永远是浏览器窗口\n不随滚动条滚动\n\n粘性定位sticky（可以认为是相对定位和固定定位的混合）\n以浏览器的可视窗口为参照点移动元素（固定定位特点）\n粘性定位占有原先的位置，不脱离标准流（相对定位特点）\n必须添加 top、left、right、bottom 其中一个才有效 跟页面滚动搭配使用\n\n静态定位static\n静态定位是默认定位方式，无定位的意思，按照标准流特性摆放位置\n静态定位没有定位位置\n\n定位位置盒子移动到的最终位置\n\n\n\n属性\n例子\n语义\n\n\n\ntop\ntop:10px\n定位元素距离其父元素的上边线的距离\n\n\nbottom\nbottom:10px\n定位元素距离其父元素的下边线的距离\n\n\nright\nright:10px\n定位元素距离其父元素的右边线的距离\n\n\nleft\nleft:10px\n定位元素距离其父元素的左边线的距离\n\n\nflex\nFlex是flexible Box 缩写，意为“弹性布局”，flex布局也叫伸缩布局，弹性布局，弹性盒布局，伸缩盒布局。 当我们为父元素设为flex布局以后，子元素的float、clear和vertical-align属性会失效。\n采用flex布局的元素，称为flex容器，它的所有子元素自动成为容器成员，称为flex项目，容器存在两根轴，默认项目按主轴排列。\n主轴和侧轴是通过flex-direction确定的，横向排列，x为主轴，y方向为侧轴。纵向排列，y方向为主轴，x方向为侧轴（默认横向排列）\n\n\n\n\nflex-direction\n决定主轴方向\nrow &#x2F;row-reverse&#x2F;column&#x2F;column-reverse\n\n\n\nflex-wrap\n如果一行装不下如何换行\nnowrap&#x2F;wrap&#x2F;wrap-reverse\n\n\nflex-flow\n是direction和wrap的简写形式\n同上\n\n\njustify-ontent\n项目在主轴上的对齐方式\nflex-start&#x2F;flex-end&#x2F;center&#x2F;space-between&#x2F;space-around\n\n\nalign-items\n定义在交叉轴上如何对齐\nflex-start&#x2F;flex-end&#x2F;center&#x2F;strench&#x2F;baseline\n\n\nalign-content\n定义多根轴线的对齐方式(一根主轴时该属性不起作用)\nflex-start&#x2F;flex-end&#x2F;center&#x2F;strench&#x2F;space-between&#x2F;space-around\n\n\n\n\n\n项目的属性\n定义\n值\n\n\n\norder\n项目的排列顺序,数值越小排列越靠前\n默认为0\n\n\nflex-grow\n项目的放大比例(如果有剩余空间放大项目等比例放大)\n默认为0\n\n\nflex-shrink\n缩小比例(如果空间不足,缩小项目等比例缩小)\n默认值为1(即默认都会缩小)\n\n\nflex-basis\n分配多余空间之前,项目占据的主轴空间,浏览器根据该属性计算是否有剩余空间\n默认值为auto项目本身大小\n\n\nflex\ngrow,shrink,basis的简写\n默认值(01auto) auto(11auto) none(00auto)\n\n\nalign-self\n允许单个项目有与其他项目不同的对齐方式,可以覆盖align-items属性\n\n\n\n"},{"title":"浏览器相关","url":"/2024/03/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/","content":"一.浏览器运行原理浏览器的结构\n\n浏览器内核\n常见浏览器:IE、Edge、Firefox、Chrome、Safari、Opera\n浏览器内核分成两部分：渲染引擎和JS引擎\n\n\n浏览器是如何工作的1.线程和进程进程是操作系统进行资源分配和调度的基本单元,可以申请和拥有计算机资源,进程是程序的基本执行实体。\n线程是操作系统能够进行运算调度的最小单位,一个进程中可以并发多个线程,每条线程并行执行不同的任务。\n\n\n2.早期浏览器结构(单进程)\n1 不稳定 因为：其中一个线程的卡死可能会导致整个进程出问题，比如你打开一个标签页，其中一个标签页卡死可能会导致整个浏览器无法运行。\n2 不安全 因为：浏览器线程之间是可以共享数据的，那JS线程岂不是可以随意访问浏览器进程内的所有数据。\n3 不流畅 因为：一个进程需要负责太多事情，会导致运行效率问题。\n\n3.现代浏览器结构(多进程)\n\n\n\\1. 浏览器进程负责控制，Chrome浏览器除标签页外的用户界面，包括包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其他进程协调工作。\n\\2. 网络进程负责发起接受网络请求\n\\3. GPU进程负责整个浏览器界面的渲染\n\\4. 插件进程负责控制网站使用的所有插件，例如flash\n\\5. 渲染器进程用来控制显示tab标签内的所有内容\n\n4.当你在浏览器地址栏里输入内容时，浏览器内部会发生什么事情DOM就是文档对象模型，是浏览器对页面在其内部的表示形式layout树上的每个节点都记录了（X,Y）坐标和边框尺寸。绘制记录表记录了会绘制的顺序Layer树是分层树，记录层级draw quads是图块信息\n\n\\1. 浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程\n\\2. 主线程将html解析构造DOM树\n\\3. 进行样式计算\n\\4. 根据DOM树和生成好的样式生成layout树\n\\5. 通过遍历Layout树生成绘制顺序表\n\\6. 接着遍历Layout树生成了Layer树\n\\7. 主线程将Layer树和绘制顺序信息一起传给合成器线程\n\\8. 合成器线程按规则进行分图层，并把图层分为更小的图块(tiles)传给栅格化线程\n\\9. 栅格化线程进行栅格化\n\\10. 栅格化完成后，合成器线程会获得栅格线程传过来的”drawquads”图块信息\n\\11. 根据”drawquads”图块信息，合成器线程合成一个合成器帧，然后将该合成器帧通过IPC传回给浏览器进程\n\\12. 浏览器进程再传到GPU进行渲染\n\n\n\n5.重绘和重排(回流)重绘 （Redraw）：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）。例如：修改元素的填充颜色，会触发重绘。\n回流（重排）（Reflow）：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点）。例如：改元素的宽高，会触发重排。\n浏览器存储数据在浏览器端存储数据对我们是很有用，这相当于赋予浏览器记忆的功能，可以记录用户的所有状态信息，增强用户体验。比如当记录用户的登陆状态时，可以让用户能够更快的进行访问，而不是每次登陆时都需要去进行繁琐的操作。\n常见数据存储方案浏览器存储数据主要有三种方式：Cookie、web存储(localStorage和sessionStorage)、indexedDB\nHttp的不足之处由于 HTTP 协议是一个无状态协议，客户端向服务器发送请求，服务器返回响应，一次请求过程就结束了。如果下一次发送请求，服务器并不能区分是否是同一个客户端。所以我们才会需要浏览器存储方案\nCookieCookie又称是HTTP Cookie，最初是在客户端用于存储会话信息，从底层来看，它作为HTTP协议的一种扩展实现，Cookie数据会自动在web浏览器和web服务器之间传输，因此在服务器端脚本就可以读写存储的cookie的值。\nCookie通常用于存储一些通用的数据，比如用户的登陆状态，首选项等。虽然随着时代的进步，HTML5所提供的web存储机制已经逐步替代了Cookie，但有些较为老的浏览器还是不兼容web存储机制，作了解即可\nCookie的本质Cookie的本质就是存储在浏览器本地的一个很小的文本文件（4kb），内部以键值对的方式来存储信息。在第一次访问网站时，浏览器发出请求，服务器响应请求后，会在响应头（respond header）中添加一个Set-Cookie，并将Cookie放入响应请求中。在之后向同一个域名下发送请求，都会携带相同的 Cookie（造成性能浪费），服务器拿到 Cookie 进行解析，便能拿到客户端的状态。\nCookie的属性值\nname：名称，一个唯一确定的cookie的名称，cookie的名称必须经过URL编码。\nvalue：值，存储在cookie中的字符串值。值必须被URL编码。\nDomain：域，指明cookie对哪个域有效，所有向该域发送的请求都会包含这个信息。\npath：路径，对于指定域中的那个路径，应该向服务器发送cookie。\nExpires&#x2F;Max-Age：有效期，表示cookie的有效期。\nHttpOnly：如果这个这个值设置为true，就不能通过JS脚本获取cookie的值。通过这个值可以有效防止XSS攻击。\nSecure：安全标志，指定后，cookie只有在使用SSL连接的时候才能发送到服务器。\n\n\n\nCookie的缺点\n容量不足。Cookie 的体积上限只有 4KB，只能用来存储少量的信息。\n数量有限。每个特定域名下的cookie数量有限，不同浏览器数量限制不同。如果超过数量限制后再设置Cookie，浏览器就会清除以前设置的Cookie（各个浏览器的机制不同）。\n性能缺陷。每次请求都会携带同域名下的所有 Cookie，造成不必要的性能浪费。\n安全性差。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。\n\nWebStorage（重点）localStoragelocalStorage以键值对的方式存储，永久存储，永不失效，除非手动删除。\nlocalStorage有以下几个特点：\n\n优点\n保持的数据永久有效，除非手动删除\n大小为5M，相比cookie，可以存储更多的信息\n仅在客户端使用，不和服务端进行通信，因此不用每次请求HTTP都被携带\n接口封装较好\n\n\n缺点\n存在浏览器兼容问题，IE8以下版本的浏览器不支持\n如果浏览器设置为隐私模式，那我们将无法读取到localStorage\nLocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问\n\n\nAPI：\n  // 设置\n  localStorage.setItem(&#39;name&#39;, &#39;张三&#39;)\n  // 取值\n  let age = localStorage.getItem(&#39;name&#39;)\n  // 移除\n  localStorage.removeItem(&#39;name&#39;)\n  // 移除所有\n  localStorage.clear()\n  &#123;% asset_img -17095505297014.png img %&#125;#### **sessionStorage**sessionStorage对象存储特定于某个会话的数据，当这个会话的页签或浏览器**关闭**，sessionStorage也就消失了。**页面刷新**之后，存储在sessionStorage中的数据仍然存在可用- sessionStorage的特点：\t- 会话级别的浏览器存储\t- 大小为5M\t- 仅在客户端同一窗口使用，不和服务端通信\t- 接口封装较好- API\t- ```JavaScript\t\t// 设置\t\tsessionStorage.setItem(&#x27;name&#x27;, &#x27;张三&#x27;)\t\t// 取值\t\tlet name = sessionStorage.getItem(&#x27;name&#x27;)\t\t// 移除\t\tsessionStorage.removeItem(&#x27;name&#x27;)\t\t// 移除所有\t\tsessionStorage.clear()\n\n\n\n\n\n\n\nIndexedDBIndexedDB，全称Indexed Database API，是浏览器中保持结构化数据的一种数据库,随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。\nIndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时支持查询和搜索\n\n特点\n键值对存储：IndexedDB采用对象仓库存储数据，可以存储所有类型的数据。仓库中数据以键值对的形式保持。 \n异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 localStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n支持事务：有学过数据库的对事务肯定不陌生（没学过的以后需要学，现阶段暂时别去）。事务意味着在一系列操作中，只要有一步失败，整个事务就都取消，数据库回滚到事务执行之前，不存在只改写一部分数据的情况。\n同源限制：IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n储存空间大: IndexedDB 的储存空间比 localStorage大得多，一般来说不少于 250MB，甚至没有上限。\n支持二进制储存: IndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n\n\n","tags":["浏览器"]},{"title":"计算机网络","url":"/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"第四次培训\n计算机网络(前端需知)简单须知\n计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\n\n\n\n\n互联网、因特网、万维网\n三者关系\n\n\n\n三者介绍\n\n互联网internet：凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分。\n因特网Internet：\n互联网中的一种，是由上千万台设备组成的网络（该网络具备很大的规模）。因特网使用**TCP&#x2F;IP协议**让不同的设备可以彼此通信。但使用TCP&#x2F;IP协议的网络并不一定是因特网，一个局域网也可以使用TCP&#x2F;IP协议。\nTCP/IP协议:由很多协议组成，不同类型的协议又被放在不同的层，因特网提供的服务一般包括有：www(万维网)服务，电子邮件服务，远程登录服务，文件传输服务（FTP），网络电话等等。\n\n\n万维网www：大规模的、联机式的信息存储所，是无数个网络站点和网页的集合。只要应用层使用的是HTTP协议，就称为万维网（world wide web），之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。\n\n\n\n\n\n网络模型OSI OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。\n\n\nTCP&#x2F;IP模型众所周知，OSI参考模型是学术上和法律上的国际标准，是完整的权威的网络参考模型。而TCP&#x2F;IP参考模型是事实上的国际标准，即现实生活中被广泛使用的网络参考模型。\n\n\n\n协议:不同的硬件,操作系统之间的通信,都需要规则,这种规则称为协议。\nTCP IP 协议是互联网基础相关各类协议族的总称，进行通信时，会通过分层顺序和对方进行通信。客户端从应用层往下走，服务器端则从链路层往上走\n\n\n\n\nTCP IP 传输流\n\n\n\n\nIP 协议 **（ ** 网络层 ）：通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。IP协议只能指明数据包的源目通信方即”这是谁的送给谁的”，但不能保证数据包一定能到达对方，数据是否会被丢弃以及丢弃之后如何处理。\nARP 协议：寻找MAC地址（链路层）\nMAC地址是什么呢？简单说来就是两台相邻的路由器A和B，A怎么把数据传给B呢，它总要知道B的物理地址吧，物理地址就像门牌号一样\n\n\nDNS 服务 （应用层）：解析域名为IP地址\n\n协议传输层协议UDP-osi模型UDP协议全称是用户数据报协议,在网络中它用于处理数据报,是一种无连接，不可靠，基于报文的协议。\n特点：\n\n面向无连接\nUDP不需要和TCP一样在发送数据前进行3次握手建立连接,想发数据就可以开始发送\n只是数据报文的搬运工,不会对数据报文进行任何拆分和拼接操作\n\n\n有单播, 多播 ,广播功能\n不仅支持一对一传输方式,同样支持一对多,多对多,多对一的方式\n\n\n是面向报文的\n发送方的UDP对应用程序交下来的报文,在添加首部后就向下交付IP层.不合并拆分,而是保留这些报文边界.因此,应用程序必须选择合适大小的报文\n\n\n不可靠性\n通信建立在无连接上,想发就发\n收到什么数据就传递什么数据,不会备份数据,发送数据方也不会关心对方是否正确接收数据\n网络环境时好时坏,但是由于UDP因为没有阻塞控制,一直会以恒定速度发送数据,即使网络条件不好,也不会对发送速率进行调整.\n\n\n\n缺点：\n\n网络条件不好情况下会出现丢包\n\n优点：\n\n头部开销小,只有8字节，传输数据报文很高效，实时性要求高的地方有所作为（eg：电话视频会议等）。\n\nTCP-tcp&#x2F;ip模型TCP协议全称为传输控制协议，是一种面向连接的、可靠的、基于 字节流的传输层通信。\n特点：\n\n面向连接\n只数据发送之前必须在两端建立连接,建立方法为3次握手,为数据可靠的传输打下基础\n\n\n仅支持单播传输\n仅支持一对一数据传输,不支持多播和广播传输方式\n\n\n可靠传输\n对于可靠传输,判断丢包,误码靠的是TCP的段编号以及确认编号.\nTCP为了保证报文传输可靠,就给每个包一个序号,同时序号也保证了传送到接收端实体的包的按序接收\n\n\n提供拥塞控制\n当网络出现拥塞时,TCP可以减小向网络注入数据的速率和数量,缓解拥塞\n\n\nTCP提供全双工通信.\n在两个实体之间可以同时交换数据(发送和接收数据同时发生互不影响）\n\n\n\n优点： \n\n适用于要求可靠传输的应用,例如文件传输\n\n连接和断开\n连接\n\n\n断开\n\n\n\n客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。\n服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。\n客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。\n等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。\n客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态\n服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。\n客户端在经过 2MSL （最大报文段的生存时间）一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。\n\n应用层协议URL和URI解释\n\nURL指的是统一资源定位符,是访问WEB网站需要输入的网站地址\nURI是指统一资源标识符,全称为Uniform Resource Identifier,它的作用是区分互联网中的不同资源,比如:HTML,图像,视频,程序等等\nURL是URI的一个子集\n\nURI格式\n\n\n\n协议名:http:或https:表示协议名称,不区分字母大小写,后加上//.\n登录信息:user:@pass表示获取服务器资源的用户和密码.不推荐使用,不安全，不常用\n服务器地址:\n以域名形式 www.tutu.com，\n以IPv4形式192.168.0.1地址名;\n以[0:0:0:0:0:0:1]这种方括号括起来的IPv6地址；\n\n\n服务器端口号::8080表示端口号，如果省略端口部分，将采用默认端口80\n文件路径:/html/index.html表示服务器文件的路径,资源访问位置，域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，否则是直接到最后\n查询字符串（参数部分）:?userId=1表示文件路径中的参数 ,?后面以key=value形式,如果后面还需要加参数,用&amp;拼接\n片段标识符:#cn1表示文件中某个位置.即平时网页锚点定位\n\nHTTP协议简介\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。\n工作于客户端-服务端架构,浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n\n\n特点\n简单快速\n客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。\n由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快\n\n\n灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\nHTTP请求，响应，状态码与其他协议\n\n互联网运行原理当电脑访问到互联网(联网那一刻开始)他就获得了一个(Internet protocal address 网络协议地址)简称ip地址\n而某某网站的服务器也有一个ip地址,\n当我想访问该网站时,就是想要访问该网站的服务器\n此时我的电脑为客户端,服务器被称为服务端(客户端服务端模型)\n从电脑发送获得index.html的请求是通过tcp|ip协议族(共分四层)\n网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信\n应用层:提供特定应用程序的协议(传html的http协议 穿文档的ftp协议 imap协议)\n传输控制层:发送数据包到计算机上使用特定端口号的应用程序\n网络层:使用ip地址将数据包发送到特定的计算机\n链路层:将二进制数据包转化为网络信号或将网络信号转化为二进制数据包\n从我的电脑使用应用层的http协议发送一个请求消息;把该消息分解程序多片段就称为数据包\n数据包进入tcp层(传输控制层){    tcp面向链接可靠,因为每个发送的数据包接收方都要发送ack确认收到   }每一个数据包被分配一个端口号(即目标计算机的哪个应用程序来接收该数据包)\n进入**ip层(网络层)**后每个数据包先会被赋予目标计算机的ip地址,而ip是比较不需要负责的一层,他可以依据数据包的大小进行分包分别运输\n而进入链路层之后物理链路中由于数据包大小不同传输速度不一可能乱序到达,但是每个数据包都有了对应的端口号*,&#x3D;&#x3D;接收方&#x3D;&#x3D;*的tcp层可以排序重组,且tcp层如果没有发送ack确认的话发送方就会重新发送该数据包\n数据包走物理链路到电缆另一端的路由器,路由器根据每个数据包上的目标ip地址确定发送到何处\n到达后从ip地址,端口号这些标签一点一点剥离出来,到达应用层时数据包已经恢复成原来的形式.应用程序(服务端)监听到该消息后将.index.html通过同样的方式发送过去\n互联网是怎么构成的调制解调器猫:将计算机的数字信号翻译成可以沿着普通电话线传送的模拟信号在公共电话网略进行传输\n而公共电话网络连接isp(Internet service provider 互联网服务提供商 例如:中国电信,中国联通等等)接入互联网\n数据包经过电话网络和isp后路由到isp主干网络上面还有nsp nap\n每次数据包经过路由器,路由器检查它自己上面有没有目的地的IP地址,没有的话就交给上层去找\ndnsdomain names service(域名服务)是一个分布式数据库记录了域名和其ip地址的对应关系\n输入网址,先访问dns服务器获取IP地址然后采访问该ip的服务器\n"},{"title":"Ajax","url":"/2024/03/04/Ajax/","content":"一、概述AJAX 是一个缩写，它的全名是 Asynchronous JavaScript and XML，意思就是异步 JavaScript 和 XML，即用JavaScript执行异步网络请求。\n二、Ajax的优势传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页面。\nAJAX 通过在后台与服务器进行少量数据交换，可以使网页实现异步更新。\n这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n三、XMLHttpRequest 对象XMLHttpRequest（XHR）对象用于与服务器交互。\n通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。\n四、Ajax工作原理其工作原理基本经过以下几个步骤：\n\n客户端发送请求，请求交给 xhr。\nxhr 把请求提交给服务器。\n服务器进行业务处理。\n服务器响应数据交给 xhr 对象。\nxhr 对象接收数据，由 JavaScript 把数据写到页面上。\n\n暂时无法在飞书文档外展示此内容\n五、AJAX 的具体使用1.创建 XMLHttpRequest 对象const request = new XMLHttpRequest();\n\n2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息request.open(method, url, async, user, password);//伪代码，对应下列参数\n\n\nmethod    要使用的HTTP方法，比如 “GET”、”POST”、”PUT”、”DELETE” 等。\nurl    表示要向其发送请求的 URL 地址。\nasync (可选)    一个可选的布尔参数，表示是否异步执行操作，默认为 true。如果值为 false，send() 方法直到收到答复前不会返回。如果 true，已完成事务的通知可供事件监听器使用。如果 multipart 属性为 true 则这个必须为 true，否则将引发异常。\nuser (可选)    用于认证用途的用户名，默认值为 null。\npassword (可选)    用于认证用途的密码，默认值为 null。\n\n3.设置响应 HTTP 请求状态变化的函数和服务端返回信息函数// 语法为request.onreadystatechange = function()&#123;&#125;;// 或request.addEventListener(&#x27;readystatechange&#x27;,function()&#123;&#125;);\n\n存有处理服务器响应的函数，每当 readyState 改变时，onreadystatechange 函数就会被执行。\nvar xhr= new XMLHttpRequest()；    xhr.open(method, url, true);// 监听readyState的改变xhr.onreadystatechange = function () &#123;    console.log(xhr.readyState);      if(xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123;    console.log(xhr.responseText)  &#125;&#125;\n\n5.发送HTTP请求XMLHttpRequest.send(data);\n\nsetRequestHeader()xhr.setRequestHeader(&#x27;header&#x27;,&#x27;value&#x27;);\n\nPOST传数据时，用来添加 HTTP 头（在open之后使用，在send之前使用）\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type\n六、重要属性\nreadyState：存有服务器响应的状态信息。（更加具体的状态码信息可自行百度）\n0: 请求未初始化（代理被创建，但尚未调用 open() 方法）\n1: 服务器连接已建立（open方法已经被调用）\n2: 请求已接收（send方法已经被调用，并且头部和状态已经可获得）\n3: 请求处理中（下载中，responseText 属性已经包含部分数据）\n4: 请求已完成，且响应已就绪（下载操作已完成）\n\n\nresponseText：获得字符串形式的响应数据。\nstatus：响应状态\n1xx：指示信息–表示请求已接收，继续处理\n2xx：成功–表示请求已被成功接收、理解、接受\n3xx：重定向–要完成请求必须进行更进一步的操作\n4xx：客户端错误–请求有语法错误或请求无法实现\n5xx：服务器端错误–服务器未能实现合法的请求\n\n\n\n七、完整示例&lt;button id=&quot;ajaxButton&quot; type=&quot;button&quot;&gt;Make a request&lt;/button&gt;&lt;script&gt;    let httpRequest;    document.getElementById(&quot;ajaxButton&quot;).addEventListener(&#x27;click&#x27;, makeRequest);    function makeRequest() &#123;        httpRequest = new XMLHttpRequest();        httpRequest.onreadystatechange = alertContents;        httpRequest.open(&#x27;GET&#x27;, &#x27;test.html&#x27;);        httpRequest.send();    &#125;    function alertContents() &#123;        if (httpRequest.readyState === XMLHttpRequest.DONE) &#123;            if (httpRequest.status === 200) &#123;                alert(httpRequest.responseText);            &#125; else &#123;                alert(&#x27;There was a problem with the request.&#x27;);            &#125;        &#125;    &#125;&lt;/script&gt;\n"},{"title":"css动画","url":"/2024/03/04/css%E5%8A%A8%E7%94%BB/","content":"css动画创建动画ainimation-name:定义的动画名称\nanimation-duration:规定动画时长\n@keyframe规则:\n​\t@keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。\n@keyframes myfirst&#123;    0%   &#123;background: red;&#125;    25%  &#123;background: yellow;&#125;    50%  &#123;background: blue;&#125;    100% &#123;background: green;&#125;&#125; @-webkit-keyframes myfirst /* Safari 与 Chrome */&#123;    0%   &#123;background: red;&#125;    25%  &#123;background: yellow;&#125;    50%  &#123;background: blue;&#125;    100% &#123;background: green;&#125;&#125;\n重复动画:animation-iteration-count:用以指定动画重复的次数，仅仅使用该属性就能使动画重复播放。在该例中，设该属性为infinite以使动画无限重复\n来回运动nimation-direction:CSS 属性设置动画是应正向播放、反向播放还是在正向和反向之间交替播放。normal动画在每个循环中正向播放。换句话说，每次动画循环时，动画将重置为起始状态并重新开始。这是默认值。\nreverse动画在每个循环中反向播放。换句话说，每次动画循环时，动画将重置为结束状态并重新开始。动画步骤将反向执行，并且时间函数也将被反转。例如，ease-in 时间函数变为 ease-out。\nalternate动画在每个循环中正反交替播放，第一次迭代是正向播放。确定循环是奇数还是偶数的计数从 1 开始。\nalternate-reverse动画在每个循环中正反交替播放，第一次迭代是反向播放。确定循环是奇数还是偶数的计数从 1 开始。\nCSS 属性 animation-fill-mode 设置 CSS 动画在执行之前和之后如何将样式应用于其目标。none当动画未执行时，动画将不会将任何样式应用于目标，而是已经赋予给该元素的 CSS 规则来显示该元素。这是默认值。\nforwards目标将保留由执行期间遇到的最后一个关键帧 (en-US)计算值。\nbackwards动画将在应用于目标时立即应用第一个关键帧中定义的值，并在animation-delay期间保留此值。\nboth动画将遵循forwards和backwards的规则，从而在两个方向上扩展动画属性。\nanimation-delay CSS 属性指定从应用动画到元素开始执行动画之前等待的时间量。动画应该开始的时间偏移量，从应用动画到元素的时刻开始计算。可以用秒（s）或毫秒（ms）指定。单位是必需的。\n动画的暂停与播放animation-play-state CSS 属性设置动画是运行还是暂停。\nrunning当前动画正在运行。\npaused当前动画已被停止。\ncss的转换css2D转换方法\ntranslate(): translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。div&#123;transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */&#125;\nrotate(): rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。div&#123;transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */&#125;\nscale(): scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：-ms-transform:scale(2,3); /* IE 9 */-webkit-transform: scale(2,3); /* Safari */transform: scale(2,3); /* 标准语法 */\nskew(): 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。\n\n\nskewX();表示只在X轴(水平方向)倾斜。\nskewY();表示只在Y轴(垂直方向)倾斜。div&#123;transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */&#125;\n\n\nmatrix():matrix()方法和2D变换方法合并成一个。\n\nmatrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。\ndiv&#123;transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */&#125;\n\ncss3D转换\nrotateX()方法，围绕其在一个给定度数X轴旋转的元素。div&#123;    transform: rotateX(120deg);    -webkit-transform: rotateX(120deg); /* Safari 与 Chrome */&#125;\nrotateY()方法，围绕其在一个给定度数Y轴旋转的元素。div&#123;    transform: rotateY(130deg);    -webkit-transform: rotateY(130deg); /* Safari 与 Chrome */&#125;\n\n\n\n\n属性\n描述\nCSS\n\n\n\ntransform\n向元素应用 2D 或 3D 转换。\n3\n\n\ntransform-origin\n允许你改变被转换元素的位置。\n3\n\n\ntransform-style\n规定被嵌套元素如何在 3D 空间中显示。\n3\n\n\nperspective\n规定 3D 元素的透视效果。\n3\n\n\nperspective-origin\n规定 3D 元素的底部位置。\n3\n\n\nbackface-visibility\n定义元素在不面对屏幕时是否可见。\n3\n\n\n\ntransform-origin\n transform-origin CSS 属性让你更改一个元素变形的原点。 transform-origin属性可以使用一个，两个或三个值来指定，其中每个值都表示一个偏移量。没有明确定义的偏移将重置为其对应的初始值。 如果定义了两个或更多值并且没有值的关键字，或者唯一使用的关键字是center，则第一个值表示水平偏移量，第二个值表示垂直偏移量。 三个值： 前两个值和只有两个值时的用法相同。 第三个值必须是。它始终代表 Z 轴偏移量。 值 x-offset 定义变形中心距离盒模型的左侧的或偏移值。 offset-keyword left，right，top，bottom 或 center 中之一，定义相对应的变形中心偏移。 y-offset 定义变形中心距离盒模型的顶的或偏移值。 x-offset-keyword left，right 或 center 中之一，定义相对应的变形中心偏移。 y-offset-keyword top，bottom 或 center 中之一，定义相对应的变形中心偏移。 z-offset 定义变形中心距离用户视线（z&#x3D;0 处）的（不能是）偏移值。\n\n\n&#x2F;&#x2F;待补充\n3D 转换方法\n\n\n\n函数\n描述\n\n\n\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)\n定义 3D 转换，使用 16 个值的 4x4 矩阵。\n\n\ntranslate3d(x,y,z)\n定义 3D 转化。\n\n\ntranslateX(x)\n定义 3D 转化，仅使用用于 X 轴的值。\n\n\ntranslateY(y)\n定义 3D 转化，仅使用用于 Y 轴的值。\n\n\ntranslateZ(z)\n定义 3D 转化，仅使用用于 Z 轴的值。\n\n\nscale3d(x,y,z)\n定义 3D 缩放转换。\n\n\nscaleX(x)\n定义 3D 缩放转换，通过给定一个 X 轴的值。\n\n\nscaleY(y)\n定义 3D 缩放转换，通过给定一个 Y 轴的值。\n\n\nscaleZ(z)\n定义 3D 缩放转换，通过给定一个 Z 轴的值。\n\n\nrotate3d(x,y,z,angle)\n定义 3D 旋转。\n\n\nrotateX(angle)\n定义沿 X 轴的 3D 旋转。\n\n\nrotateY(angle)\n定义沿 Y 轴的 3D 旋转。\n\n\nrotateZ(angle)\n定义沿 Z 轴的 3D 旋转。\n\n\nperspective(n)\n定义 3D 转换元素的透视视图。\n\n\ncss过渡\n\n\n属性\n描述\nCSS\n\n\n\ntransition\n简写属性，用于在一个属性中设置四个过渡属性。\n3\n\n\ntransition-property\n规定应用过渡的 CSS 属性的名称。\n3\n\n\ntransition-duration\n定义过渡效果花费的时间。默认是 0。\n3\n\n\ntransition-timing-function\n规定过渡效果的时间曲线。默认是 “ease”。\n3\n\n\ntransition-delay\n规定过渡效果何时开始。默认是 0。\n3\n\n\n"},{"title":"第二次面试","url":"/2024/06/04/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%9D%A2%E8%AF%95/","content":"HTML部分\n前端的发展历史\n 前端技术的发展历史可以概括为以下几个阶段：\n\n静态页面时代（1990s）：在互联网初期，网页主要是由HTML（Hypertext Markup Language）构成，呈现为静态页面，内容和样式都比较简单。\n动态网页时代（2000s）：随着JavaScript（JS）的兴起，网页开始呈现出动态效果。AJAX（Asynchronous JavaScript and XML）技术的出现使得网页能够异步加载数据，提升了用户体验。同时，CSS（Cascading Style Sheets）的发展也为网页提供了更丰富的样式设计能力。\nRIA（Rich Internet Application）时代（2000s）：随着Flash和Silverlight等技术的出现，网页应用的交互性和多媒体性得到了大幅提升，使得网页应用能够更接近传统桌面应用的体验。\n移动优先时代（2010s至今）：随着智能手机和平板电脑的普及，移动端访问网页的比例逐渐增加。响应式设计（Responsive Web Design）和移动端优化成为前端开发的重要趋势。同时，HTML5、CSS3以及ES6（ECMAScript 2015）等新技术的出现，为前端开发提供了更多功能和性能上的支持。\n现代前端框架时代（2010s至今）：出现了一系列前端框架和库，如AngularJS、React、Vue.js等，它们提供了更高效、更灵活的开发方式，大大提升了前端开发的效率和可维护性。同时，前端工程化（如Webpack、Babel等）和组件化（如Web Components）也成为了前端开发的重要实践。\nWebAssembly时代（2010s至今）：WebAssembly（简称Wasm）是一种可以在网页浏览器中运行的低级字节码格式，可以让开发者使用其他编程语言（如C++、Rust等）编写高性能的Web应用。WebAssembly的出现为前端开发带来了全新的可能性，使得前端应用能够更加强大和复杂。\n\n 随着技术的不断发展和演进，前端开发也在不断变化和完善，成为了互联网应用开发中不可或缺的重要组成部分。\n\nhtml5新特性\n\n语义化标签：引入了一些新的语义化标签，如 &lt;header&gt;, &lt;footer&gt;, &lt;nav&gt;, &lt;article&gt;等，使得页面结构更清晰。\n\n多媒体支持：增强了对多媒体内容的支持，包括 &lt;audio&gt; 和 &lt;video&gt; 标签，可以直接在网页中嵌入音频和视频。\n\nCanvas绘图：引入了 &lt;canvas&gt; 标签，使得在网页中可以通过JavaScript进行动态绘图。\n\nSVG支持：增强了对SVG（可缩放矢量图形）的支持，可以将SVG作为图像嵌入到HTML文档中，并通过CSS和JavaScript进行控制。\n\n表单控件：引入了新的表单输入类型，如 &lt;input type=&quot;date&quot;&gt;, &lt;input type=&quot;email&quot;&gt;等，以及新的表单属性，如 required, placeholder等，提高了表单的功能和用户体验。\n\n本地存储：引入了本地存储技术，包括LocalStorage和SessionStorage，使得网页可以在客户端存储数据，提高了网页的性能和用户体验。\n\nWeb Workers：引入了Web Workers，使得网页可以在后台运行多线程JavaScript代码，提高了网页的性能和响应能力。\n\n地理位置：引入了地理位置API，使得网页可以获取用户的地理位置信息，用于定位服务和个性化内容。\n\nWebSockets：引入了WebSockets，使得网页可以建立持久的双向通信连接，实现实时数据传输。\n\n拖放：引入了拖放API，使得网页可以实现拖放操作，提高了用户与网页的交互体验。\n\n\n\n如何理解html语义化\n HTML语义化是指在编写HTML代码时，使用恰当的HTML元素来表达文档的结构和含义，以使页面结构清晰、易于理解，并且对搜索引擎和辅助技术（如屏幕阅读器）友好。这意味着使用适合内容的语义元素，如&lt;header&gt;、&lt;nav&gt;、&lt;main&gt;、&lt;article&gt;、&lt;section&gt;、&lt;aside&gt;等，而不是仅仅依赖于&lt;div&gt;和&lt;span&gt;元素来定义页面结构。\n 通过语义化HTML，可以提高页面的可访问性、搜索引擎优化（SEO），以及代码的可维护性。例如，使用&lt;nav&gt;元素来表示导航菜单，使用&lt;footer&gt;元素来表示页面底部，使用&lt;article&gt;元素来包含独立的文章内容等，都能够更清晰地传达页面的意图和结构。\n\n前端数据持久化存储 \n 前端数据持久性存储是指在客户端（如浏览器）中存储数据，使其在页面重新加载、关闭或重新打开后仍然保持可用状态的能力。在前端开发中，有几种常见的方式来实现数据的持久性存储： Cookies（Cookie）：Cookies是存储在用户计算机上的小型文本文件，可以通过浏览器发送给服务器。Cookies通常用于存储少量的数据，并且有大小限制（通常为4KB）。虽然Cookies在某些情况下是一种方便的持久性存储方式，但它们不适合存储大量数据，并且受到安全性和隐私性的限制。 Web Storage（Web存储）：Web Storage包括了两种机制：Session Storage和Local Storage。它们都允许在浏览器中存储键值对，并且具有较高的存储容量（通常为5MB）。Session Storage存储的数据在当前会话结束后被清除，而Local Storage存储的数据则会持久保存，直到用户手动清除或网站清除为止。 IndexedDB（索引数据库）：IndexedDB是一个浏览器内置的NoSQL数据库，允许在客户端存储大量结构化数据，并支持复杂的查询。IndexedDB提供了比Web Storage更强大的功能，但也更复杂一些，需要一定的学习和开发成本。 Cache API（缓存API）：Cache API允许开发者在浏览器中缓存网络请求的响应，以便在之后的访问中提供离线访问和快速加载。虽然缓存API通常用于缓存网络资源而不是用户数据，但也可以用于实现一些简单的数据持久性存储。 选择合适的前端数据持久性存储方式取决于项目需求、数据量、安全性要求以及对于功能和复杂度的需求。\n\n\ncss部分\n用css实现三角形 border,clip-path:poligon,线性渐变\n\nposition的情况\n\nstatic（默认值）：元素遵循正常文档流，即元素出现在文档中的位置。\nrelative：元素相对于其正常位置进行定位，但是在布局中仍然占据原本的空间。\nabsolute：元素相对于其最近的已定位（position不是static）的祖先元素进行定位，如果不存在已定位的祖先元素，则相对于初始包含块（通常是文档的视口）进行定位。元素脱离文档流，不占据空间。\nfixed：元素相对于视口进行定位，即无论页面滚动与否，元素始终位于固定的位置。也是脱离文档流的位置。\nsticky：元素根据用户的滚动位置在父元素内定位。它的行为就像position:relative;当元素在屏幕中时（即元素的位置距离顶部的距离小于或等于指定的top值），它的行为就像position:fixed;直到达到指定的位置。\n\n\nflex十个属性\n\n重绘和回流\n 重绘 （**Redraw**）：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）。\n 例如：修改元素的填充颜色，会触发重绘。\n 回流（重排）（**Reflow**）：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点）。\n 例如：改元素的宽高，会触发重排。\n\n\njs部分\n数组和字符串方法8个\n\n数组方法1. push,pop2. shift,unshift3. splice,reverse4. join连成字符串5. length,at,indexof6. map带有返回值,foreach不带返回值7. filter8. refuce,升序对每个数组元素调用回调函数,回调中两个参数,第一个是上一次调用的返回值,第二个事数组元素当前值-&gt;与其他迭代方法不同，reduce() 不接受 thisArg 参数。callbackFn 调用时始终以 undefined 作为 this 的值，如果 callbackFn 未处于严格模式，则该值将被替换为 globalThis。9. sort原地对数组排序韩慧该数组的引用 function(a, b){return a-b}升序 function(a, b){return b-a}降序\n\n字符串方法\n\n字符串拼接concat(适用于数组)\n\n字符串切片方法\n\nslice传入起始位置和末位置,负数表示倒数第几位,,start大于end会返回空串\n\nsubstr传入两个参数第一个是起始位置,第二个是截取长度\n\nsubstring两个参数第一个是起始位置和末尾,start大于end会交换位置,不接受负数参数\n\n\n\nsplit将字符串打碎成数组\n\ntolowerCase,toUpperCase大小写转换\n\nincludes检查字符串是否有,两个参数,第一个子串内容,第二个搜索起始位置,返回bool\n\n\n\n数组去重,要求严格\n\n\n\n最简单的是用集合,还可以用splice,错在j的位置不对\n\n\n在arr的原型上添加each的方法\n\n调用栈和调用位置,\n\n调用栈：为了到达当前执行位置所调用的所有函数\n调用位置：函数被调用的位置，当前正在执行的函数的前一个调用中\n\n\n全部隐士类型转化\n\n\n  ​\t在相等运算中,有bool,bool值先转化成数字\n  ​\t空数组和空对象相加都转换成字符串,空数组转换成空串,对象转换”[objec Object]”\n  ​\t空数组本身在js中被认为是真的,而在比较运算时转换空串或0都被被视为假\n  ​\t在空数组相加时,空数组与布尔值相加时都会转换成字符串,拼串\n  ​\t数字家字符串,将数字转换为字符串,数字减字符串,字符串变数字,能变就转,不能变就nan\n  ​\t首先，让我们分解表达式 !+[]：\n1. `[]` 表示一个空数组。\n2. `+[]` 将空数组转换为数字。空数组经过类型转换后，会变成数字 `0`。\n3. `!+[]` 对数字 `0` 进行逻辑非操作。在 JavaScript 中，逻辑非操作符 `!` 会将其操作数转换为布尔值，并返回其相反值。由于 `0` 被视为假值，所以 `!0` 的结果是 `true`。\n\n  所以，!+[] 返回的结果是 true。\n  ​\t当数组参与比较时:            1. 如果另一个操作数是字符串,数组转化为字符串[1,2,3]-&gt;”1,2,3”            2.  如果另一个操作数是数字,数组转化为数字      \t\t- 数组为空转换为0        \t\t- 包含一个元素,这个元素被作为数字值          \t\t- 包含多个元素,不确定\njs闭包在 JavaScript 中，闭包是指在一个函数内部定义的函数可以访问到该函数作用域内的变量，即使在外部函数执行完毕后仍然可以访问到这些变量。当内层函数执行完毕时，外层函数的作用域并不会被立即销毁，只有当不存在对外层函数作用域内变量的引用时，外层函数的作用域才会被垃圾回收\n原题目:\nfunction out() &#123;    var a = 10    return function inner() &#123;        a++        console.log(a)    &#125;&#125;out()()out()()let x = out()x()x()\n\n\n在这个题目中执行out()()的时候先执行外层函数,此时存在a&#x3D;10,接着执行内层函数,这时外层函数变量a仍然可以访问,而外层函数本身不可访问,外层函数被销毁,a没有被销毁,此时a++是11\nout()()执行完毕后这两个函数内都被销毁,而再次执行时,会重新产生这个a,依然是10+1&#x3D;11\n而当x成为这个内层函数的引用是,由于这个引用一直存在,所以这个a没有被销毁,所以会累加11,12\n只有当x&#x3D;null类似的东西写了之后才可以释放a\n\njs垃圾回收机制\n标记清除:\n 它的基本原理是通过标记在执行上下文中仍然可访问的对象，然后清除未标记的对象。垃圾回收器会从根部对象开始遍历内存中的对象，标记所有可以访问的对象，然后清除未被标记的对象，即认定为垃圾。\n\n引用计数:\n 它的原理是通过跟踪每个对象被引用的次数来判断对象是否可以被回收。当一个对象的引用计数变为零时，表示该对象不再被引用，可以被垃圾回收器回收。\n\n\n原题同上\nthis的绑定规则\n默认绑定:无法使用其他规则,一般是直接调用\n隐式绑定:函数调用中的this绑定到调用这个函数的这个上下文对象 隐式丢失:如果为函数创建别名或者在别的函数中作为回调函数被调用,就会丢失,绑定全局,但是如果是在对象中的属性名调用不会丢失\n显示绑定:\n硬绑定:通过bind将对象绑定到该函数,以后无论怎么调用,this都不变bind,this被绑定给特定对象,但是可以被覆盖call,apply(apply是接受参数数组)\n\n\nnew绑定:在js中,new执行的机制是先创建一个空对象,再进行原型的连接,并且将新对象绑定到函数调用的this\n特例:\nnull或undefined没有包装类,所以采用显示绑定会被忽略,实际采用默认绑定规则\n间接引用(p.foo &#x3D; o.foo)(); &#x2F;&#x2F; 2,其实this是window\n软绑定,其实是特例并不是和硬绑定相对,他可以当应用默认绑定时改成指定的this\n箭头函数根据外层作用域决定this\n\n\n\n原题\n&quot;use strict&quot;function fn1() &#123;  console.log(&quot;fn1&quot;, this);&#125;var demo = &#123;  color: &quot;red&quot;,&#125;;var obj = &#123;  msg: &quot;outer&quot;,  fn1,  fn2: function () &#123;    console.log(&quot;fn2&quot;, this);  &#125;,  fn4: () =&gt; &#123;    console.log(&quot;fn4&quot;, this);  &#125;,  fn5: function () &#123;    console.log(&quot;fn5&quot;, this);    var fn6 = () =&gt; &#123;      console.log(&quot;fn6&quot;, this);    &#125;;    fn6();    function demo() &#123;      console.log(&quot;demo&quot;, this);    &#125;    demo();     var demo2 = function () &#123;      console.log(&quot;demo2&quot;, this);    &#125;;    demo2();  &#125;,&#125;;obj.fn1(); //fn1  obj obj.fn2(); // fn2 objobj.fn4();//fn4 windowobj.fn5(); //fn5 obj;  fn6 obj;---因为箭头函数指向父作用域this //demo undefined; demo2 undefined\n\njs包装类在JavaScript中，包装类（Wrapper Class）是一种特殊的对象，它们用来给基本数据类型（如字符串、数字和布尔值）提供对象形式的方法和属性。JavaScript中的基本数据类型是原始值，它们是不可变的，因此无法直接调用方法或访问属性。为了解决这个问题，JavaScript引入了包装类，它们在使用基本数据类型时会自动创建，并且可以提供一些额外的方法和属性。\n当我们在基本数据类型上调用方法或访问属性时，JavaScript会自动将其转换为相应的包装类对象，执行操作后再转换回原始值。这个过程称为自动装箱和拆箱\n只有null和undefined没有包装类\n节流和防抖节流（Throttling）：节流是指限制函数的执行频率，确保函数在一定时间间隔内只执行一次。它适用于需要在用户频繁触发事件时控制函数执行的情况，比如滚动事件或者鼠标移动事件。节流可以防止函数被频繁调用，从而减少性能开销。\n防抖（Debouncing）：防抖是指在函数连续触发的情况下，只有在某个时间段内没有新的触发事件发生时，才执行该函数。它适用于需要等待用户停止某个连续操作后再执行某个函数的情况，比如搜索框输入事件或者窗口大小改变事件。防抖可以避免函数被频繁调用，提高性能和用户体验。\n可迭代性生成器函数:\nfunction* 是 JavaScript 中的一个语法，用于定义一个生成器函数（Generator Function）。生成器函数是一种特殊类型的函数，可以通过 yield 关键字来暂停执行，并在需要时恢复执行。生成器函数使用 function* 关键字进行定义，并在函数体内部使用 yield 关键字来产生（yield）一个序列的值。这使得生成器函数能够以惰性的方式生成一系列的值，而不需要一次性将它们全部计算出来，这对于处理大量数据或者需要按需获取值的情况非常有用。\n以下是一个简单的生成器函数示例：\njavascript复制代码function* generatorFunction() &#123;  yield 1;  yield 2;  yield 3;&#125;// 创建生成器对象const generator = generatorFunction();// 通过调用 next() 方法逐个获取生成器函数产生的值console.log(generator.next().value); // 输出: 1console.log(generator.next().value); // 输出: 2console.log(generator.next().value); // 输出: 3console.log(generator.next().value); // 输出: undefined，因为已经没有更多的值了\n\n在上面的示例中，generatorFunction 是一个生成器函数，它通过 yield 关键字产生了三个值。通过调用 generator.next() 方法可以逐个获取这些值，每次调用 next() 方法都会从上一次暂停的地方继续执行，直到函数执行完成或者遇到 return 语句。\n生成器函数的另一个特点是可以通过 yield* 关键字委托给另一个生成器函数或可迭代对象，从而实现更复杂的生成器行为。\n在 JavaScript 中，for...in 是一种用于遍历对象属性的循环结构。它会遍历对象的可枚举属性，包括继承的属性。具体来说，for...in 循环会迭代对象的每一个可枚举属性，并在每次迭代中将属性名称赋给指定的变量，然后执行指定的代码块。\n下面是 for...in 循环的基本语法：\nfor (variable in object) &#123;  // code block to be executed&#125;\n\n其中：\n\nvariable 是一个在每次迭代中将被赋值为当前属性名称的变量。\nobject 是要迭代的对象。\n\n示例：\nconst person = &#123;  name: &#x27;John&#x27;,  age: 30,  city: &#x27;New York&#x27;&#125;;for (let key in person) &#123;  console.log(key + &#x27;: &#x27; + person[key]);&#125;\n\n在上面的示例中，for...in 循环遍历了 person 对象的每一个属性，并在每次迭代中将属性名称赋给 key 变量，然后输出属性名称和对应的属性值。\n需要注意的是，for...in 循环不仅会遍历对象自身的属性，还会遍历从原型链上继承的属性。如果只想遍历对象自身的属性而不包括继承的属性，可以通过 Object.hasOwnProperty() 方法来过滤：\nfor (let key in object) &#123;  if (object.hasOwnProperty(key)) &#123;    // code block to be executed  &#125;&#125;\n\n这样就可以只遍历对象自身的属性了。\nvue部分\n实现父子通信三种方法\n\n使用props配置项,父组件写键值对传东西,子组件写props收东西,props不可以修改\n全局事件总线,在vm那写一个beforecreated里面让Vue.prototype.$bus&#x3D;this(vm) 事件触发时,子组件用this.$bus.$emit(‘名字’,参数),接受方组件用this.$bus.$on绑定(‘名字’,数据处理的函数\n\n\nref子组件通信,child\n\nv-指令5个\n\n商品名字商品1&lt;&#x2F;&gt;\n\nv-model,父组件,son\n\ndata为什么只能写函数返回值 在Vue中，data 选项通常用于定义组件的初始数据。为了确保每个组件实例都有自己独立的数据副本，Vue 在创建组件实例时会将 data 选项的值进行初始化。然而，如果直接将对象赋值给 data 选项，那么所有的组件实例将共享同一个数据对象，这会导致状态不可预测的问题。\n\n按顺序写生命周期函数\n\n\n","categories":["面试记录"]},{"title":"第一次面试","url":"/2024/06/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/","content":"osi七层模型应用层,表示层,会话层,传输层,网络层,数据链路层,物理层\nGET和POST客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。\n\n\n\n1\nGET\n请求指定的页面信息，并返回实体主体。\n\n\n\n2\nHEAD\n类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头\n\n\n3\nPOST\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。\n\n\n4\nPUT\n从客户端向服务器传送的数据取代指定的文档的内容。\n\n\n5\nDELETE\n请求服务器删除指定的页面。\n\n\n6\nCONNECT\nHTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。\n\n\n7\nOPTIONS\n允许客户端查看服务器的性能。\n\n\n8\nTRACE\n回显服务器收到的请求，主要用于测试或诊断。\n\n\n9\nPATCH\n是对 PUT 方法的补充，用来对已知资源进行局部更新 。\n\n\nDOM.addEventListener(事件类型,事件处理函数,是否使用捕获机制)&#x2F;&#x2F;第三个参数传入true代表是捕获阶段出发(很少使用)false是冒泡触发\n\n\n\n值\n描述\n\n\n\nbutton\n定义可点击的按钮（通常与 JavaScript 一起使用来启动脚本）。\n\n\ncheckbox\n定义复选框。\n\n\ncolorNew\n定义拾色器。\n\n\ndateNew\n定义 date 控件（包括年、月、日，不包括时间）。\n\n\ndatetimeNew\n定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区）。\n\n\ndatetime-localNew\n定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）。\n\n\nemailNew\n定义用于 e-mail 地址的字段。\n\n\nfile\n定义文件选择字段和 “浏览…” 按钮，供文件上传。\n\n\nhidden\n定义隐藏输入字段。\n\n\nimage\n定义图像作为提交按钮。\n\n\nmonthNew\n定义 month 和 year 控件（不带时区）。\n\n\nnumberNew\n定义用于输入数字的字段。\n\n\npassword\n定义密码字段（字段中的字符会被遮蔽）。\n\n\nradio\n定义单选按钮。\n\n\nrangeNew\n定义用于精确值不重要的输入数字的控件（比如 slider 控件）。\n\n\nreset\n定义重置按钮（重置所有的表单值为默认值）。\n\n\nsearchNew\n定义用于输入搜索字符串的文本字段。\n\n\nsubmit\n定义提交按钮。\n\n\ntelNew\n定义用于输入电话号码的字段。\n\n\ntext\n默认。定义一个单行的文本字段（默认宽度为 20 个字符）。\n\n\ntimeNew\n定义用于输入时间的控件（不带时区）。\n\n\nurlNew\n定义用于输入 URL 的字段。\n\n\nweekNew\n定义 week 和 year 控件（不带时区）。\n\n\n空格&amp;nbsp、大于号&amp;gt、小于号&amp;lt常用\n使元素脱离了标准流，向左或向右移动，直到碰到父元素或另一个浮动元素的边缘为止\n","categories":["面试记录"]},{"title":"也曾为了比赛看点东西","url":"/2024/06/04/%E4%B9%9F%E6%9B%BE%E4%B8%BA%E4%BA%86%E6%AF%94%E8%B5%9B%E7%9C%8B%E7%82%B9%E4%B8%9C%E8%A5%BF/","content":"大学 B 组11.排序（1）归并排序[4-5] \nvoid merge_sort_recursive(int arr[], int reg[], int start, int end) &#123;    if (start &gt;= end)        return;    int len = end - start, mid = (len &gt;&gt; 1) + start;    int start1 = start, end1 = mid;    int start2 = mid + 1, end2 = end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    int k = start;    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    while (start1 &lt;= end1)        reg[k++] = arr[start1++];    while (start2 &lt;= end2)        reg[k++] = arr[start2++];    for (k = start; k &lt;= end; k++)        arr[k] = reg[k];&#125;void merge_sort(int arr[], const int len) &#123;    int reg[len];    merge_sort_recursive(arr, reg, 0, len - 1);&#125;\n\n（2）快速排序[4-5] \n   void quick_sort(int s[], int l, int r)&#123;    if (l &lt; r)    &#123;        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1        int i = l, j = r, x = s[l];        while (i &lt; j)        &#123;            while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数                j--;              if(i &lt; j)                 s[i++] = s[j];               while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数            i++;          if(i &lt; j)             s[j--] = s[i];    &#125;    s[i] = x;    quick_sort(s, l, i - 1); // 递归调用     quick_sort(s, i + 1, r);&#125;&#125;\n\n（3）桶排序[4] \n#include&lt;stdio.h&gt; #define Max_len 10      //数组元素个数 // 打印结果void Show(int  arr[], int n)&#123;    int i;    for ( i=0; i&lt;n; i++ )        printf(&quot;%d  &quot;, arr[i]);    printf(&quot;\\n&quot;);&#125; //获得未排序数组中最大的一个元素值int GetMaxVal(int* arr, int len)&#123;        int maxVal = arr[0]; //假设最大为arr[0]        for(int i = 1; i &lt; len; i++)  //遍历比较，找到大的就赋值给maxVal    &#123;        if(arr[i] &gt; maxVal)            maxVal = arr[i];    &#125;        return maxVal;  //返回最大值&#125; //桶排序   参数：数组及其长度void BucketSort(int* arr , int len)&#123;    int tmpArrLen = GetMaxVal(arr , len) + 1;    int tmpArr[tmpArrLen];  //获得空桶大小    int i, j;        for( i = 0; i &lt; tmpArrLen; i++)  //空桶初始化        tmpArr[i] = 0;        for(i = 0; i &lt; len; i++)   //寻访序列，并且把项目一个一个放到对应的桶子去。        tmpArr[ arr[i] ]++;        for(i = 0, j = 0; i &lt; tmpArrLen; i ++)    &#123;        while( tmpArr[ i ] != 0) //对每个不是空的桶子进行排序。        &#123;            arr[j ] = i;  //从不是空的桶子里把项目再放回原来的序列中。            j++;            tmpArr[i]--;        &#125;    &#125;&#125; int main()&#123;   //测试数据    int arr_test[Max_len] = &#123; 8, 4, 2, 3, 5, 1, 6, 9, 0, 7 &#125;;        //排序前数组序列    Show( arr_test, Max_len );    //排序    BucketSort( arr_test,  Max_len);    //排序后数组序列    Show( arr_test, Max_len );        return 0;&#125;\n\n（4）堆排序[4] \n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a, int *b) &#123;    int temp = *b;    *b = *a;    *a = temp;&#125;void max_heapify(int arr[], int start, int end) &#123;    // 建立父節點指標和子節點指標    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) &#123; // 若子節點指標在範圍內才做比較        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比較兩個子節點大小，選擇最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數            return;        else &#123; // 否則交換父子內容再繼續子節點和孫節點比較            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * 2 + 1;        &#125;    &#125;&#125;void heap_sort(int arr[], int len) &#123;    int i;    // 初始化，i從最後一個父節點開始調整    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢    for (i = len - 1; i &gt; 0; i--) &#123;        swap(&amp;arr[0], &amp;arr[i]);        max_heapify(arr, 0, i - 1);    &#125;&#125;int main() &#123;    int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    int i;    for (i = 0; i &lt; len; i++)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\\n&quot;);    return 0;&#125;\n\n（5）基数排序[4~5] \n#include&lt;stdio.h&gt;#define MAX 20//#define SHOWPASS#define BASE 10void print(int *a, int n) &#123;  int i;  for (i = 0; i &lt; n; i++) &#123;    printf(&quot;%d\\t&quot;, a[i]);  &#125;&#125;void radixsort(int *a, int n) &#123;  int i, b[MAX], m = a[0], exp = 1;  for (i = 1; i &lt; n; i++) &#123;    if (a[i] &gt; m) &#123;      m = a[i];    &#125;  &#125;  while (m / exp &gt; 0) &#123;    int bucket[BASE] = &#123; 0 &#125;;    for (i = 0; i &lt; n; i++) &#123;      bucket[(a[i] / exp) % BASE]++;    &#125;    for (i = 1; i &lt; BASE; i++) &#123;      bucket[i] += bucket[i - 1];    &#125;    for (i = n - 1; i &gt;= 0; i--) &#123;      b[--bucket[(a[i] / exp) % BASE]] = a[i];    &#125;    for (i = 0; i &lt; n; i++) &#123;      a[i] = b[i];    &#125;    exp *= BASE;#ifdef SHOWPASS    printf(&quot;\\nPASS   : &quot;);    print(a, n);#endif  &#125;&#125;int main() &#123;  int arr[MAX];  int i, n;  printf(&quot;Enter total elements (n &lt;= %d) : &quot;, MAX);  scanf(&quot;%d&quot;, &amp;n);  n = n &lt; MAX ? n : MAX;  printf(&quot;Enter %d Elements : &quot;, n);  for (i = 0; i &lt; n; i++) &#123;    scanf(&quot;%d&quot;, &amp;arr[i]);  &#125;  printf(&quot;\\nARRAY  : &quot;);  print(&amp;arr[0], n);  radixsort(&amp;arr[0], n);  printf(&quot;\\nSORTED : &quot;);  print(&amp;arr[0], n);  printf(&quot;\\n&quot;);  return 0;&#125;\n\n12.搜索（1）剪枝[4-6] \n（2）双向 BFS[5-6] \n（3）记忆化搜索[5]\n （4）迭代加深搜索[5-6] \n（5）启发式搜索[7] \n13.DP （1）背包 DP[4-6] （2）树形 DP[4-6] （3）状压 DP[5-6] （4）数位 DP[5-6] （5）DP 的常见优化[7] \n14.字符串 （1）哈希[4-5] （2）kmp[4-6] （3）manacher[4-6] \n15.图论（1）欧拉回路[5-7] （2）最小生成树[5-7] （3）单源最短路及差分约束系统[5-7] （4）拓扑序列[5-7] （5）二分图匹配[7] （6）图的连通性问题（割点、桥、强连通 分量）[7] （7）DFS 序[5-7] （8）最近共同祖先[5-7] \n16.数学（1）排列组合[5-6] （2）二项式定理[6] （3）容斥原理[6-7] （4）模意义下的逆元[5] （5）矩阵运算[6-7] （6）高斯消元[7] \n17.数据结构（1）ST 表[5-6] （2）堆[5-6] （3）树状数组[5-6] （4）线段树[6-7] （5）Trie 树[5-7] （6）并查集[5-6] （7）平衡树(利用系统自带的标准库实现简 单平衡树)[5-7] \n18.计算几何 （1）基础计算和基本位置关系判定[6-7] （2）概率论[7+] （3）博弈论[7+]\n"},{"title":"copy来的作用域闭包笔记","url":"/2024/06/04/copy%E6%9D%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85%E7%AC%94%E8%AE%B0/","content":"作用域先来看一段代码\nfunction func ()&#123;    var vari = 12;&#125;func()console.log(vari)//Uncaught ReferenceError:not definedfunction func ()&#123;    console.log(vari)&#125;var vari = 12func()//12\n\n这里体现的就是JS中的变量**作用域。\n简单来说，作用域体现了JS引擎对变量名的处理机制，类似于一个“地盘”，它最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。\n这个机制在不同语言中有不同实现，大体可以分两类：静态****作用域（也称词法作用域）与动态作用域。静态作用域会在变量名定义时捕捉其所在段对变量的绑定；而动态作用域则会在变量调用时检测是否有与变量名匹配的变量。JS****采用的是静态作用域。\nvar a = 10;function func ()&#123;    console.log(a);&#125;function func1 ()&#123;    var a=5;    func()&#125;//10\n\njs作用域的特点一共有三种方式可以形成作用域，全局、函数、块。全局作用域在运行时便默认存在，我们可以使用的是函数与块作用域。\n下面继续看一个例子：\n//全局function foo()&#123;    let vari = 10;//函数作用域    if(vari==10)&#123;        let vari = 20//块级作用域        console.log(vari)//20,这里触发了遮蔽机制    &#125;    &#123;        let abc = 10//就算只有花括号也可以构成块级作用域    &#125;    console.log(abc)//Reference Error,块级作用域外无法找到变量        console.log(vari)//10&#125;foo()\n\n函数作用域函数（包括回调函数）及对象方法将会使用其被定义时所处的****作用域，而非使用其实际调用时的作用域\nlet a=2;function foo()&#123;    console.log(a)&#125;function bar(func)&#123;    let a =10;    func()&#125;bar(foo)//2。a在定义foo的作用域中未被定义。\n\n块级作用域块级作用域只在使用let与const声明变量时可用，使用var声明变量不会触发块级作用域。在正常情况下我们推荐使用let声明变量，它拥有块级作用域，在重复定义时let会报错，而var只会默默地进行赋值操作\nfunction foo()&#123;    var a=10;    if(a)&#123;        var a=20;        console.log(a)    &#125;    console.log(a);//两个都是20。这意味着内部没有触发遮蔽而是直接修改了外层作用域的变量值。使用let可以避免很多不直观的错误。&#125;\n\n全局作用域在JS中，全局作用域可以使用globalThis进行引用。除此之外在各个环境中还有不同的引用全局作用域的方法，比如浏览器的window，Node.js的global，web Worker的self。\n由于模块（module）机制的出现，全局作用域的重要性逐渐降低，语句更多的是在自己所属的函数作用域下执行。\n作用域链作用域就像套娃一般，外层套内层。变量在调用中将会由调用点出发，向外层寻找符合变量名的变量，直至到达全局作用域。\nfunction foo()&#123;    let a = 10;//a=10    &#123;        a=20;//修改外层a为20        let b=30;//b=30        let d=()=&gt;&#123;            console.log(b)        &#125;        &#123;            let b=40;//内层b=40            console.log(a);//20            console.log(b);//40            d()//30        &#125;        console.log(b)//30        &#123;            let c=50;            console.log(b);//30                    &#125;        console.log(c);//RE    &#125;    console.log(a)//20&#125;foo()//开始执行\n\nLHS与RHS我们之前讲到JS引擎会沿着作用域向上寻找变量、直至全局作用域。那么问题来了，假如某个变量名直到全局作用域都没有找到（比如还未定义就使用这个变量）会发生什么呢？一般这种情况常见于书写错误，比如经典的mian、jvav。此时我们需要了解JS引擎的LHS与RHS（left hand search，左侧搜索以及Right hand search，右侧搜索）。\nLHS与RHS最原始的定义是对在表达式两侧变量的查找。比如一个赋值表达式：a&#x3D;b，对a的查找是LHS，对b的查找是RHS。引申之后LHS即对变量的赋值,RHS即对变量的引用。看如下代码：\nfunction foo (a)&#123;    let b = a;    return a+b&#125;let c = foo(2)\n\n我们从c声明开始，c赋值触发一次LHS，调用函数触发一次RHS，参数赋值触发一次LHS，b赋值触发一次LHS，a调值触发一次RHS，a+b触发两次RHS。\n那么学习他对开发的意义是什么呢？意义在于全局作用域对LHS与RHS搜索失败的处理方法不同。LHS、即赋值搜索、失败后会在全局作用域创建同名变量，并对其赋值；而RHS、即取值搜索、失败后会抛出Reference Error。LHS的默认行为可能会导致调试过程中出现问题。不过在严格模式下，LHS失败也会抛出Reference Error。\n实践中不要刻意使用这个特性！每一个使用的变量都要尽可能的在作用域顶端完成声明！这里讲解是用于排查错误使用。\n闭包什么是闭包？基础回答: A函数嵌套B函数，B函数使用了A函数的内部变量，且A函数返回B函数，这就是闭包\n高级回答: ???  闭包其实就是一个自带了执行环境（由外层函数提供，即便外层函数销毁依旧可以访问）的特殊函数。 \n关键字 : “执行环境”, “特殊函数”, “外层函数被销毁”\n闭包的一些其他相关描述\n\n一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）\n\n&#x3D;&#x3D;》 翻译为人话: 闭包是由一个函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时能访问的所有局部变量。\n\n闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“\n闭包是指那些能够访问自由变量的函数。**(在一个函数内部，如果引用了外部作用域的变量但是在函数内部并没有声明（即非局部变量），那么这些变量被称为自由变量)**\n闭包允许函数访问并操作函数外部的变量\n\n闭包的几个场景\nvar name = &quot;听风是风&quot;;var obj = &#123;  name: &quot;行星飞行&quot;,  sayName: function () &#123;    return function () &#123;      console.log(this.name);    &#125;;  &#125;&#125;;obj.sayName()();  ??? function init() &#123;  var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量  function displayName() &#123; // displayName() 是内部函数，一个闭包      alert(name); // 使用了父函数中声明的变量  &#125;  displayName();&#125;init(); ??? \n\n闭包到底是什么？我们该从哪个角度去看待闭包呢?  它仅仅只是函数中的一个函数吗? (黄皮书 &#x3D;&#x3D;&gt;当函数可以记住并访问所在的词法作用域时，就产生了闭包 )\n那么我们来看一下它：[[Scopes]] Closure\nvar b = &#x27;global property&#x27;function outer () &#123;    var a = &#x27;property of outer scope&#x27;    function inner () &#123;        var c = 2       return function innermost () &#123;            console.log(a, c)        &#125;    &#125;    return inner()&#125;var innermost = outer()innermost()console.log(innermost.prototype);//[[Scopes]]是函数的内部属性，是无法访问的,但foo.prototype.constructor和foo指向同一个函数，所以点开constructor选项\n\n那么，我们可以看到，其中其实是存储了一些Closure对象，那么这些对象都是什么东西呢?\n就是我们形成的闭包，那么这个是已经发生了转换的， 在之前，在函数对象上会保存一个[scope]属性，在这个属性中会保存所有的父级的变量对象，那么说起变量对象，就不得不回到上下文这个知识点\n执行上下文:\n我们所常说的执行上下文(上下文),是在代码执行前生成的，生成后被塞入执行上下文栈中，上下文又被分为3种\n\n全局上下文\n函数上下文 &#x3D;》 arguments,  \neval上下文\n\n两个阶段. 解析，执行\n他们都有三个属性\n\nVO(变量对象), 激活后叫 (AO)活动对象\n作用域链\nthis\n\n其中 : 变量对象中包含了在这一块代码中的所有的变量 ， 函数声明， 以及参数 。\n那么现在机制是什么呢？\n在每个函数执行前都会创建一个闭包对象(Closure), 不管会不会用到\n\n每个函数只能有一个\n子级函数共享父级的一个\n\n这里我们提到两个属性 [[Scopes]]和Closure\n其中[[Scopes]]是在父函数预编译时确定的，其中还是和之前的[[scope]]一样，而Closure 是在自己本身函数预解析的时候才会确定。在确定的同时，会出现一个替换的效果，（如果Closure里面有东西，就会用来替换原有的VO）.\n最后，在内部函数都预解析完成后，js的垃圾回收机制会把没有用到的VO进行一个回收。\n(减少内存泄漏的可能性)\n闭包的经典使用场景\nreturn 回一个函数\n函数作为一个参数\n循环赋值\n\nvar data = []for (var i = 0; i &lt; 5; i++) &#123;  data[i] = function () &#123;    console.log(i);  &#125;&#125;for (var i = 0; i &lt; 5; i++) &#123;  data[i]()&#125;// ------- var data = []for (let i = 0; i &lt; 5; i++) &#123;  data[i] = function () &#123;    console.log(i);  &#125;&#125;for (var j = 0; j &lt; 5; j++) &#123;  data[j]()&#125;// -------- var data = []for (let i = 0; i &lt; 5; i++) &#123;  data[i] = function () &#123;    console.log(i);  &#125;&#125;for (var j = 0, i = 9; j &lt; 5; j++) &#123;  data[j]()&#125;\n\n\n节流防抖\n\n….\n闭包的危害\n容易造成内存泄漏\n\n如果你不清除对一块内存的引用，那么就会引起内存泄漏。（我们可能已经在代码中有了内存泄漏，但是占用的内存不是太大，导致我们暂时不会发觉）\nfunction bindEvent() &#123;  let ele = document.querySelector(&#x27;.ele&#x27;);  ele.onclick = function () &#123;    console.log(ele.style.color);  &#125;;&#125;;bindEvent();/* 由于点击事件中使用到了外层函数中的DOM ele，导致 ele 始终无法释放，大家都知道操作DOM本来是件不太友好的事情，你现在操作别人不说，还抓着不放了，你良心不会痛？*/// 来自某篇博客\n\nthis先看几个例子\n//词法作用域function foo() &#123;  console.log(a); &#125; function baz() &#123;   var a = 3;   foo();  &#125;  var a = 4;  baz();//4   //动态作用域function foo() &#123;  console.log(a); &#125; function baz() &#123;   var a = 3;   foo();  &#125;  var a = 4;  baz();//3  //this使用var f = function () &#123;  console.log(this.x);&#125;var x = 1;var obj = &#123;  f: f,  x: 2,&#125;;f();// 1obj.f()；//2  \n\nwhat？不是函数自身function foo(num) &#123;        console.log( &quot;foo: &quot; + num );    // 记录foo被调用的次数t    this.count++;&#125;foo.count = 0;var i;for (i=0; i&lt;10; i++) &#123;    if (i &gt; 5) &#123;              foo( i );        &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// foo被调用了多少次？4console.log( foo.count );//0\n\n不是作用域在JavaScript内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过JavaScript代码访问，它存在于JavaScript引擎内部\nfunction foo() &#123;    var a = 2;    this.bar();&#125;function bar() &#123;        console.log( this.a );&#125;foo();\n\n是属性\n被自动定义在所有函数的作用域中，在运行时进行绑定\nthis的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式\n当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到\n\nWho？调用位置和调用栈\n调用栈：为了到达当前执行位置所调用的所有函数\n调用位置：函数被调用的位置，当前正在执行的函数的前一个调用中\n\nfunction baz() &#123;  // 调用栈: baz  // 调用位置:全局作用域  console.log(&quot;baz&quot;);  bar();  console.log(11)&#125;function bar() &#123;  // 调用栈:baz--&gt;bar  // 调用位置:baz  console.log(&quot;bar&quot;);  foo();&#125;function foo() &#123;  // 调用栈:baz--&gt;bar--&gt;foo  // 调用位置:bar  console.log(&quot;foo&quot;);&#125;baz();\n\n绑定规则(重要)\n默认绑定\n\nfunction foo() &#123;  console.log(this.a);&#125;var a = 2;foo();//2\n\n\n无法应用其他规则时使用，this指向全局对象(window)\n严格模式不适用\n\n\n隐式绑定\n\n\n当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。\n\n//调用foo()时this被绑定到obj，因此this.a和obj.a是一样的var obj = &#123; a: 2, foo: function()&#123;console.log(this.a&#125;&#125;;obj.foo(); // 2//exc1function foo() &#123;  console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo &#125;;var obj1 = &#123; a: 2, obj2: obj2 &#125;;obj1.obj2.foo();//42\n\n\n隐式丢失\n\n隐式绑定的函数丢失绑定对象，从而默认绑定到全局或者undefined（取决于是否使用严格模式）\nfunction foo() &#123;  console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo &#125;;var bar = obj.foo; // 为函数调用创建别名var a = &quot;oops, global&quot;; // a是全局对象的属性bar();bar(); // &quot;oops, global&quot;//exc2function foo() &#123;  console.log(this.a);&#125;function doFoo(fn) &#123; //传入回调函数  fn();  &#125;var obj = &#123; a: 2, foo: foo &#125;;var a = &quot;oops, global&quot;; // a是全局对象的属性doFoo(obj.foo); // oops, global\n\n\n显式绑定\n\n\ncall(..) 、apply(..) 、bind(..) 方法\n显式绑定：可以直接指定this的绑定。它们的第一个参数是一个对象，会把这个对象绑定到this，接着在调用函数时指定这个this。\n\nfunction foo() &#123;  console.log(this.a);&#125;var obj = &#123; a: 2 &#125;;var obj1 = &#123; a: 3 &#125;;foo.call(obj); // 2foo.call(obj1); // 3\n\n硬绑定硬绑定是指this强制绑定到某个对象上（除了使用new时）\nfunction foo() &#123;  console.log(this.a); // 2&#125;var a = 3var obj = &#123; a: 2 &#125;;var bar = function () &#123;  console.log(this.a) //3  foo.call(obj); &#125;;bar(); function foo(something) &#123;  console.log(this.a, something);  return this.a + something;&#125;var obj = &#123; a: 2 &#125;;var bar = foo.bind(obj);var b = bar(3); // 2 3   柯里化console.log(b); // 5//函数通过 bind() 方法被绑定，它的上下文（即 this 的值）将被永久固定var test = function (x, y) &#123;    console.log(this, arguments)&#125;var a = test.bind(&#123; s: 1 &#125;, 1)a.call(&#123; d: 1 &#125;, 2) // &#123;s: 1&#125; 1 2var b = a.bind(&#123; d: 1 &#125;, 2)b()// &#123;s: 1&#125; 1 2var c= a.bind(&#123; d: 1 &#125;, 4)c()\n\n\nnew绑定\n\n\nJavaScript中new的机制实际上和面向类的语言完全不同 \n使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n创建（或者说构造）一个全新的对象。{ }\n这个新对象会被执行[[原型]]连接。{ }.proto&#x3D; foo.prototype\n这个新对象会绑定到函数调用的this。\n如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象\n\n\n\nfunction Foo(b) &#123;   this.a = b;&#125;var bar = new Foo(2);console.log(bar.a); // 2\n\n优先级new&gt;显示绑定&gt;隐式绑定&gt;默认绑定\nthis特例\n把null或者undefined（没有包装类，不能直接new一个新对象）作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则（DMZ对象）\n\nfunction foo(a, b) &#123;  console.log(a, b);&#125;var dmzobj = Object.create(null); // DMZ对象var bar = foo.bind(dmzobj, 2);bar(3); // 2 3\n\n\n间接引用\n\nfunction foo() &#123;  console.log(this.a);&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2\n\n\n软绑定\n\n//软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到objfunction foo() &#123;  console.log(&quot;name: &quot; + this.name);&#125;var obj = &#123; name: &quot;obj&quot; &#125;,  obj2 = &#123; name: &quot;obj2&quot; &#125;,  obj3 = &#123; name: &quot;obj3&quot; &#125;;var fooOBJ = foo.softBind(obj);fooOBJ(); // name: objfooOBJ.call(obj3); // name: obj3\n\n&#x3D;&gt;this箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this\nfunction foo() &#123;//console.log(this)//obj1  return (a) =&gt; &#123;    //this继承自foo()    console.log(this.a);  &#125;;&#125;var obj1 = &#123;  a: 2,&#125;;var obj2 = &#123;  a: 3,&#125;;var bar = foo.call(obj1);/*bar=(a) =&gt; &#123;    //this继承自foo()    console.log(this.a);  &#125;;*/bar(obj2);// \n\n练习&quot;use strict&quot;function fn1() &#123;  console.log(&quot;fn1&quot;, this);&#125;var demo = &#123;  color: &quot;red&quot;,&#125;;var obj = &#123;  msg: &quot;outer&quot;,  fn1,  fn2: function () &#123;    console.log(&quot;fn2&quot;, this);  &#125;,  fn4: () =&gt; &#123;    console.log(&quot;fn4&quot;, this);  &#125;,  fn5: function () &#123;    console.log(&quot;fn5&quot;, this);    var fn6 = () =&gt; &#123;      console.log(&quot;fn6&quot;, this);    &#125;;    fn6();    function demo() &#123;      console.log(&quot;demo&quot;, this);    &#125;    demo();     var demo2 = function () &#123;      console.log(&quot;demo2&quot;, this);    &#125;;    demo2();  &#125;,&#125;;obj.fn1(); //fn1  obj obj.fn2(); // fn2 objobj.fn4();//fn4 windowobj.fn5(); //fn5 obj;  fn6 obj;---因为箭头函数指向父作用域this //demo undefined; demo2 undefined\n\n补充：node没有window对象\nvar a = 12;function foo() &#123;  console.log(this.a);&#125;foo();var obj = &#123;  id: &quot;awesome&quot;,  cool: function coolFn() &#123;    console.log(this.id);  &#125;,&#125;;setTimeout(obj.cool, 100);//obj.cool是回调函数,被window调用,故this为window,结果为undefined\n\nhttps://www.cnblogs.com/wangfupeng1988/p/3977924.html\n原型链Function.prototype.a= () =&gt;&#123;  console.log(1);&#125;Object.prototype.b= () =&gt; &#123;  console.log(2);&#125;function A() &#123;&#125;const a = new A();a.a();a.b();A.a();A.b();function A() &#123;&#125;A.prototype.n = 0;console.log(A)A.prototype.add = function() &#123; this.n+= 1; console.log(this)&#125;const a = new A();const b = new A();a.add();b.add();console.log(b.n)function A() &#123;&#125;function B(a) &#123;    this.a = a;&#125;function C(a) &#123;    if(a) &#123;        this.a = a;    &#125;&#125;A.prototype.a = 1;B.prototype.a = 1;C.prototype.a = 1;console.log(new A().a);console.log(new B().a); console.log(new C(2).a);function foo() &#123;    this.some= &#x27;222&#x27;    let ccc = &#x27;ccc&#x27;    foo.obkoro1= &#x27;obkoro1&#x27;    foo.prototype.a = &#x27;aaa&#x27;&#125;foo.koro = &#x27;扣肉&#x27;foo.prototype.test = &#x27;test&#x27;let foo1 = new foo()  foo.prototype.test = &#x27;test2&#x27; //console.log(foo1) //foo1身上的属性\n\n前言在面向对象编程中，继承是非常实用也非常核心的功能，这一切都基于面向类语言中的类。然而，javascript和面向类的语言不同，早期，它没有类作为蓝图，javascript中只有对象，但抽象继承思想又是如此重要，于是聪明绝顶的javascript开发者们就利用javascript原型链的特性实现了和类继承功能一样的继承方式。\n对象都是通过函数创建的，函数也是对象\nvar obj = &#123; a: 10, b: 20 &#125;;var arr = [5, &#x27;x&#x27;, true];//上述代码本质： var obj = new Object(); obj.a = 10; obj.b = 20; var arr = new Array(); arr[0] = 5; arr[1] = &#x27;x&#x27;; arr[2] = true;\n\n何为原型要想弄清楚原型链，我们得先把原型搞清楚，原型可以理解为是一种设计模式。以下是《你不知道的javascript》对原型的描述：\n\njavascript中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 都会被赋予一个非空的值。\n\n《javascript高级程序设计》这样描述原型：\n\n每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法都可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。\n\n我们通过一段代码来理解这两段话：\nfunction Person() &#123; &#125;// 在Person的原型对象上挂载属性和方法Person.prototype.name = &#x27;滑稽鸭&#x27;Person.prototype.age = 22Person.prototype.getName = function () &#123;  return this.name&#125;const hjy = new Person()console.log(&#x27;hjy: &#x27;,hjy)console.log(&#x27;getName: &#x27;,hjy.getName())\n\n这是上面这段代码在chrome控制台中显示的结果：\n\n可以看到，我们先是创建了一个空的构造函数Person，然后创建了一个Person的实例hjy，hjy本身是没有挂载任何属性和方法的，但是它有一个[[Prototype]]内置属性，这个属性是个对象，里面有name、age属性和getName函数，定睛一看，这玩意儿可不就是上面写的Person.prototype对象嘛。事实上，Person.prototype和hjy的[[Prototype]]都指向同一个对象，这个对象对于Person构造函数而言叫做原型对象，对于hjy实例而言叫做原型。下面一张图直观地展示上述代码中构造函数、实例、原型之间的关系：\n\n因此，构造函数、原型和实例的关系是这样的：\n每个构造函数都有一个原型对象（实例的原型），原型有一个**constructor**属性指回构造函数，而实例有一个内部指针指向原型。在chrome、firefox、safari浏览器环境中这个指针就是__proto__，其他环境下没有[[Prototype]]的标准方式。\n每个对象都有一个_proto_，可称为隐式原型。这个属性引用了创建这个对象的函数的prototype(指向创建该对象的函数的prototype)\n\nfunction Fn() &#123; &#125;Fn.prototype.name = &#x27;王福朋&#x27;;Fn.prototype.getYear = function () &#123;            return 1988;        &#125;;var fn = new Fn();console.log(fn.name);//王福朋console.log(fn.getYear());//1988//fn这个对象本质上是被Fn函数创建的//fn.__proto__=== Fn.prototype\n\n\n自定义函数的prototype也是一个对象，由Object创建，所以f1._proto_—&gt;Foo.prototype，\nFoo.prototype._proto_—&gt;Object.prototype,\nObject.prototype._proto_—&gt;null\nObject.prototype是一个特例——它的proto指向的是null，切记切记! ! !\n函数是被Fuction创造的，则如下图所示，Object.proto_&#x3D;&#x3D;&#x3D;Fuction.prototype,并且，Function.proto_&#x3D;&#x3D;&#x3D;Function.prototype，是一个环形结构\n\nFunction.prototype指向的对象，它的proto也指向Object.prototype！！！\n因为Function.prototype是一个对象，是对象就是由Object创造，那么\nFunction.prototype.**proto**&#x3D;&#x3D;&#x3D;Object.prototype\n原型链\n在上述原型的基础上，如果hjy的原型是另一个类型的实例呢？于是hjy的原型本身又有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数。这样，实例和原型之间形成了一条长长的链条，这就是原型链。\n\n所有普通的[[Prototype]]都会指向内置的Object.prototype，而Object的[[Prototype]]指向null。也就是说所有的普通对象都源于Object.prototype，它包含javascript中许多通用的功能。\n\n在原型链中，如果在对象上找不到需要的属性或者方法，引擎就会继续在[[Prototype]]指向的原型上查找，同理，如果在后者也没有找到需要的东西，引擎就会继续查找它的[[Prototype]]指向的原型。上图理解一下：\n\n理解继承\n继承是面向对象编程的三大特征之一（封装、继承、多态）。多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只需要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类，基类等。子类可以直接访问父类中的非私有的属性和行为。\n\n以咱们人类为例，咱全地球人都是一个脑袋、双手双脚，很多基本特征都是一样的。但人类也可以细分种类，有黄种人、白种人、黑种人，咱们如果要定义这三种人，无需再说一个脑袋、双手双脚之类的共同特征，黄种人就是在人类的基础上将皮肤变为黄色，白种人皮肤为白色，黑种人为黑色，如果有其他特征就再新增即可，例如蓝眼睛、黄头发等等。\n\n如果用代码封装，咱们就可以将人类定义为基类或者超类，拥有脑袋、手、足等属性，说话、走路等行为。黄种人、白种人、黑种人为子类，自动复制父类的属性和行为到自身，然后在此基础上新增或者重写某些属性和行为，例如黄种人拥有黄皮肤、黑头发。这就是继承的思想。\njs中的继承（原型继承）在其他面向类语言中，继承意味着复制操作，子类是实实在在地将父类的属性和方法复制了过来，但javascript中的继承不是这样的。根据原型的特性，js中继承的本质是一种委托机制，对象可以将需要的属性和方法委托给原型，需要用的时候就去原型上拿，这样多个对象就可以共享一个原型上的属性和方法，这个过程中是没有复制操作的。\njavascript中的继承主要还是依靠于原型链，原型处于原型链中时即可以是某个对象的原型也可以是另一个原型的实例，这样就能形成原型之间的继承关系。\n访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找（即找到prototype），这就是原型链\n然而，依托原型链的继承方式是有很多弊病的，我们需要辅以各种操作来消除这些缺点，在这个探索的过程中，出现了很多通过改造原型链继承而实现的继承方式。\njs六种继承方式原型链继承直接利用原型链特征实现的继承，让构造函数的prototype指向另一个构造函数的实例。\nfunction Person() &#123;  this.hand = 2&#125;function YellowRace() &#123; &#125;YellowRace.prototype = new Person()const hjy = new YellowRace()console.log(hjy.hand) \n\n上述代码中的Person构造函数、YellowRace构造函数、hjy实例之间的关系如下图：\n\n根据原型链的特性，当我们查找hjy实例的head和hand属性时，由于hjy本身并没有这两个属性，引擎就会去查找hjy的原型，还是没有，继续查找hjy原型的原型，也就是Person原型对象，结果就找到了。就这样，YellowRace和Person之间通过原型链实现了继承关系。\n但这种继承是有问题的：\n\n创建hjy实例时不能传参，也就是YellowRace构造函数本身不接受参数。\n当原型上的属性是引用数据类型时，所有实例都会共享这个属性，即某个实例对这个属性重写会影响其他实例。\n\n针对第二点，我们通过一段代码来看一下：\nfunction Person() &#123;  this.colors = [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]&#125;function YellowRace() &#123; &#125;YellowRace.prototype = new Person()const hjy = new YellowRace()hjy.colors.push(&#x27;green&#x27;) console.log(hjy.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27;] const laowang = new YellowRace() console.log(laowang.colors)  // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]\n\n可以看到，hjy只是想给自己的生活增添一点绿色，但是却被laowang给享受到了，这肯定不是我们想看到的结果。\n盗用构造函数盗用构造函数也叫作“对象伪装”或者“经典继承”，原理就是通过在子类中调用父类构造函数实现上下文的绑定。\nfunction Person(eyes) &#123;  this.eyes = eyes  this.colors = [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]&#125;function YellowRace() &#123;  Person.call(this, &#x27;black&#x27;) //console.log(this)// 调用构造函数并传参&#125;const hjy = new YellowRace()hjy.colors.push(&#x27;green&#x27;)console.log(hjy.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]console.log(hjy.eyes) // blackconst laowang = new YellowRace()console.log(laowang.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]console.log(laowang.eyes) // black\n\n上述代码中，YellowRace在内部使用call调用构造函数，这样在创建YellowRace的实例时，Person就会在YellowRace实例的上下文中执行，于是每个YellowRace实例都会拥有自己的colors属性，而且这个过程是可以传递参数的，Person.call()接受的参数最终会赋给YellowRace的实例。它们之间的关系如下图所示：\n\n虽然盗用构造函数解决了原型链继承的两大问题，但是它也有自己的缺点：\n\n必须在构造函数中定义方法，通过盗用构造函数继承的方法本质上都变成了实例自己的方法，不是公共的方法，因此失去了复用性。\n子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式，原因如上图所示，YellowRace构造函数、hjy和laowang实例都没有和Person的原型对象产生联系。\n\n针对第二点，我们看一段代码：\nfunction Person(eyes) &#123;  this.eyes = eyes    this.getEyes = function () &#123;    return this.eyes  &#125;&#125;   Person.prototype.ReturnEyes = function () &#123;  return this.eyes&#125;function YellowRace() &#123;  Person.call(this, &#x27;black&#x27;)&#125;const hjy = new YellowRace()console.log(hjy.getEyes()) // blackconsole.log(hjy.ReturnEyes()) // TypeError: hjy.ReturnEyes is not a function\n\n可以看到，hjy实例能继承Person构造函数内部的方法getEyes()，对于Person原型对象上的方法，hjy是访问不到的。\n组合继承原型链继承和盗用构造函数继承都有各自的缺点，而组合继承综合了前两者的优点，取其精华去其糟粕，得到一种可以将方法定义在原型上以实现重用又可以让每个实例拥有自己的属性的继承方案。\n组合继承的原理就是先通过盗用构造函数实现上下文绑定和传参，然后再使用原型链继承的手段将子构造函数的prototype指向父构造函数的实例，代码如下：\nfunction Person(eyes) &#123;  this.eyes = eyes  this.colors = [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]&#125;Person.prototype.getEyes = function () &#123;  return this.eyes&#125;function YellowRace() &#123;  Person.call(this, &#x27;black&#x27;) // 调用构造函数并传参&#125;YellowRace.prototype = new Person() // 再次调用构造函数const hjy = new YellowRace()hjy.colors.push(&#x27;green&#x27;)const laowang = new YellowRace()console.log(hjy.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]console.log(laowang.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]console.log(hjy.getEyes()) // black\n\nhjy终于松了口气，自己终于能独享生活的一点“绿”，再也不会被老王分享去了。\n此时Person构造函数、YellowRace构造函数、hjy和laowang实例之间的关系如下图：\n\n组合继承.png\n相较于盗用构造函数继承，组合继承额外的将YellowRace的原型对象（同时也是hjy和laowang实例的原型）指向了Person的原型对象，这样就集合了原型链继承和盗用构造函数继承的优点。\n但组合继承还是有一个小小的缺点，那就是在实现的过程中调用了两次Person构造函数，有一定程度上的性能浪费。这个缺点在最后的寄生式组合继承可以改善。\n原型式继承\n2006年，道格拉斯.克罗克福德写了一篇文章《Javascript中的原型式继承》。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。\n\n文章最终给出了一个函数：\nconst object = function (o) &#123;  function F() &#123; &#125;  F.prototype = o   return new F()&#125;\n\n其实不难看出，这个函数将原型链继承的核心代码封装成了一个函数，但这个函数有了不同的适用场景：如果你有一个已知的对象，想在它的基础上再创建一个新对象，那么你只需要把已知对象传给object函数即可。\nconst object = function (o) &#123;   function F() &#123; &#125;   F.prototype = o   return new F()&#125;  const hjy = &#123;    eyes: &#x27;black&#x27;,     colors: [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]    &#125;    const laowang = object(hjy)    console.log(laowang.eyes) // black    console.log(laowang.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]复制代码\n\nES5新增了一个方法Object.create()将原型式继承规范化了。相比于上述的object()方法，Object.create()可以接受两个参数，第一个参数是作为新对象原型的对象，第二个参数也是个对象，里面放入需要给新对象增加的属性（可选）。第二个参数与Object.defineProperties()方法的第二个参数是一样的，每个新增的属性都通过自己的属性描述符来描述，以这种方式添加的属性会遮蔽原型上的同名属性。当Object.create()只传入第一个参数时，功效与上述的object()方法是相同的。\nconst hjy = &#123;  eyes: &#x27;black&#x27;,    colors: [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]&#125;const laowang = Object.create(hjy, &#123;  name: &#123;    value: &#x27;老王&#x27;,    writable: false,    enumerable: true,    configurable: true  &#125;,  age: &#123;    value: &#x27;32&#x27;,    writable: true,    enumerable: true,    configurable: false  &#125;&#125;)console.log(laowang.eyes) // blackconsole.log(laowang.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]console.log(laowang.name) // 老王console.log(laowang.age) // 32\n\n稍微需要注意的是，object.create()通过第二个参数新增的属性是直接挂载到新建对象本身，而不是挂载在它的原型上。_原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。\n上述代码中各个对象之间的关系仍然可以用一张图展示：\n\n这种关系和原型链继承中原型与实例之间的关系基本是一致的，不过上图中的F构造函数是一个中间函数，在object.create()执行完后它就随着函数作用域一起被回收了。那最后hjy的constructor会指向何处呢？下面分别是浏览器和node环境下的打印结果：\n\n\n查阅资料得知chrome打印的结果是它内置的，不是javascript语言标准。具体是个啥玩意儿我也不知道了🤣。\n既然原型式继承和原型链继承的本质基本一致，那么原型式继承也有一样的缺点：\n\n不能传参，使用手写的object()不能传，但使用Object.create()是可以传参的。\n原对象中的引用类型的属性会被新对象共享。\n\n寄生式继承寄生式继承与原型式继承很接近，它的思想就是在原型式继承的基础上以某种方式增强对象，然后返回这个对象。\nfunction inherit(o) &#123;  let clone = Object.create(o)  clone.sayHi = function () &#123;  // 增强对象     console.log(&#x27;Hi&#x27;)  &#125;   return clone&#125; const hjy = &#123;   eyes: &#x27;black&#x27;,   colors: [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]  &#125;  const laowang = inherit(hjy)  console.log(laowang.eyes) // black  console.log(laowang.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]  laowang.sayHi() // Hi\n\n这是一个最简单的寄生式继承案例，这个例子基于hjy对象返回了一个新的对象laowang，laowang拥有hjy的所有属性和方法，还有一个新方法sayHi()。\n可能有的小伙伴就会问了，寄生式继承就只是比原型式继承多挂载一个方法吗？这也太low了吧。其实没那么简单，这里只是演示一下挂载一个新的方法来增强新对象，但我们还可以用别的方法呀，比如改变原型的constructor指向，在下面的寄生式组合继承中就会用到。\n寄生式组合继承寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路就是使用寄生式继承来继承父类的原型对象，然后将返回的新对象赋值给子类的原型对象。\n首先实现寄生式继承的核心逻辑：\nfunction inherit(Father, Son) &#123; const prototype = Object.create(Father.prototype) // 获取父类原型对象副本  prototype.constructor = Son // 将获取的副本的constructor指向子类，以此增强副本原型对象Son.prototype = prototype // 将子类的原型对象指向副本原型对象&#125;\n\n这里没有将新建的对象返回出来，而是赋值给了子类的原型对象。\n接下来就是改造组合式继承，将第二次调用构造函数的逻辑替换为寄生式继承：\n//组合式继承function Person(eyes) &#123;  this.eyes = eyes  this.colors = [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]&#125;Person.prototype.getEyes = function () &#123;  return this.eyes&#125;function YellowRace() &#123;  Person.call(this, &#x27;black&#x27;) // 调用构造函数并传参&#125;YellowRace.prototype = new Person() // 再次调用构造函数const hjy = new YellowRace()hjy.colors.push(&#x27;green&#x27;)const laowang = new YellowRace()console.log(hjy.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]console.log(laowang.colors) // [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]console.log(hjy.getEyes()) // black//寄生式继承function Person(eyes) &#123;  this.eyes = eyes  this.colors = [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]&#125;function YellowRace() &#123;  Person.call(this, &#x27;black&#x27;) // 调用构造函数并传参&#125;inherit( Person ,YellowRace) // 寄生式继承，不用第二次调用构造函数const hjy = new YellowRace()hjy.colors.push(&#x27;green&#x27;)const laowang = new YellowRace()console.log(hjy.colors)console.log(laowang.colors)console.log(hjy.getEyes())\n\n上述寄生式组合继承只调用了一次Person构造函数，避免了在Person.prototype上面创建不必要、多余的属性。于此同时，原型链依然保持不变，效率非常之高效。\n如图，寄生组合式继承与组合式继承中的原型链关系是一样的：\n\nnew 关键字在实现各种继承方式的过程中，经常会用到new关键字，那么new关键字起到的作用是什么呢？\n简单来说，new关键字就是绑定了实例与原型的关系，并且在实例的的上下文中调用构造函数。下面就是一个最简版的new的实现：\nconst myNew = function (Fn, ...args) &#123;  const o = &#123;&#125;  o.__proto__ = Fn.prototype  Fn.apply(o, args)   return o&#125;      function Person(name, age) &#123;    this.name = name    this.age = age    this.getName = function () &#123;    return this.name  &#125;  &#125;  const hjy = myNew(Person, &#x27;张三&#x27;, 22)  console.log(hjy.name)  console.log(hjy.age)  console.log(hjy.getName())\n\n实际上，真正的new关键字会做如下几件事情：\n\n创建一个新的javaScript对象（即 {} ）\n为步骤1新创建的对象添加属性proto ，将该属性链接至构造函数的原型对象\n将this指向这个新对象\n执行构造函数内部的代码（例如给新对象添加属性）\n如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。\n\n代码如下：\nconst myNew = function (Fn, ...args) &#123;  const o = &#123;&#125;   o.__proto__ = Fn.prototype   const res = Fn.apply(o, args)   if (res &amp;&amp; typeof res === &#x27;object&#x27; || typeof res === &#x27;function&#x27;) &#123;     return res  &#125;   return o&#125;\n\n有些小伙伴可能会疑惑最后这个判断是为了什么？因为语言的标准肯定是严格的，需要考虑各种情况下的处理。比如const res = Fn.apply(o, args)这一步，如果构造函数有返回值，并且这个返回值是对象或者函数，那么new的结果就应该取这个返回值，所以才有了这一层判断。\ninstanceofInstanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\nInstanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。\n\n\n依据上述内容，就可以解释以下内容：\n\n\ninstanceof表示的就是一种继承关系，或者原型链的结构\nAxios的使用Axios的基本使用及搭配Elementui的二次封装@王玮 \n一、执行机制参考文章：一文搞懂进程、线程、协程及JS协程的发展 - 掘金\n\n进程和线程\n\n（1）含义\n进程（process）：保存在硬盘上的程序会被载入到内存中运行，在内存空间里面形成一个独立的内存体，这个内存体有自己独立的地址空间，系统也会为应用的每一个进程分配独立的CPU、内存等资源。\n线程（thread）：进程中执行的每一个任务指的就是线程，系统不会为其分配内存资源，各个线程共享进程拥有的内存资源(线程也被称为轻量级进程)。\n\n进程是CPU资源分配的最小单位\n线程是CPU调度的最小单位\n一般操作系统会存在多个进程，他们相互独立，瓜分内存、CPU资源，\n一个进程又分为多个线程，他们共享资源，完成各自的任务，同时由于共享资源，可以相互协作\n（2）状态\n进程三态\n\n\n就绪：获取CPU外的所有资源、只要CPU分配资源就可以马上执行\n运行：获得处理器分配的资源，程序开始执行\n阻塞：正在执行的进程由于某些事件（I&#x2F;O请求，申请缓存区失败）而暂时无法运行，\n\n进程受到阻塞，在满足请求时进入就绪状态等待系统调用\n\n线程三态\n\n\n就绪：指线程具备运行的所有条件，逻辑上可以运行，在等待处理机\n运行：指线程占用处理机正在运行\n阻塞：线程在等待一个事件，逻辑上不可执行（占用）\n\n（3）关系\n一个程序至少有一个进程，一个进程至少有一个线程。\n线程不能够脱离进程而独立运行，同一进程的所有线程共享该进程的所有资源；\n进程是cpu资源分配的最小的单位，线程是cpu资源调度的最小的单位\n当进程运行时只产生一个线程，被称为单线程，否则被称为多线程。\n\n（4）浏览器中的进程和线程浏览器是电脑中的一个进程，它有一个主进程还有很多的子进程，通过子进程来实现多进程。\n 当我们打开浏览器的时候，我们的浏览器就会默认的给我们打开至少 1 个浏览器进程，1 个 GPU 进程，1 个网络进程，和 1 个渲染进程 (一个 tag 页就是一个渲染进程)。ps:* 如果你有浏览器的第三方插件也会打开第三方插件进程 * 然后其中，浏览器进程，GPU 进程，网络进程，第三方插件进程这些都是共有的，只有渲染进程会跟着 tag 页的增加而增加。这里的渲染进程还有另外一个名字，就是我们常说的浏览器内核！！！\n 这里以 chrome 浏览器举例去看我们的进程，设置     更多工具     任务管理器 \n\n\n进程的下一层就是线程，我们常说的 js 引擎线程就是在渲染进程中，那么我们的渲染进程中到底包含什么线程呢？\n\nGUI 渲染线程：负责渲染页面，解析 HTML 和 CSS, 构建 DOM 树，CSSOM 树，渲染树和绘制页面，重绘重排也是在该线程中执行.\njs 引擎线程：一个渲染进程中只能有一个 js 引擎线程，负责解析和执行 js. js单线程。\n计时器线程：指 setInterval 和 setTimeout，因为 JS 引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作 \n异步 http 请求线程: XMLHttpRequest 连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待 JS 引擎空闲执行\n事件触发线程：主要用来控制事件循环，比如 JS 执行遇到计时器，AJAX 异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等 JS 引擎处理 \nIO线程: 负责和其他的进程IPC通信（一种进程间的通信方式），接收其他进程传进来的消息。\n\n\n\n并发与并行\n\n并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。 并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。 \n并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。\n区别：是否同时\n\n并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。\n\n在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。\n\nJavaScript 协程\n\n协程定义：一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度,或者可以理解为协程就是线程中可以交替运行的代码片段。\n发展\n\n同步代码\n异步JavaScript: callback hell（回调地狱）\nES6引入 Promise&#x2F;a+, 生成器Generators(语法 function foo(){}* 可以赋予函数执行暂停&#x2F;保存上下文&#x2F;恢复执行状态的功能), 新关键词yield使生成器函数暂停.【译】 Promises&#x2F;A+ 规范 - 掘金\nES7引入 async函数&#x2F;await语法糖,async可以声明一个异步函数(将Generator函数和自动执行器，包装在一个函数里)，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果.\n\n与线程的比较\n\n线程是为了解决阻塞和并发的问题（在一段时间内执行更多的程序），协程是为了在一段时间运行更多的“程序”（应该说是函数）并且避免线程阻塞。\n线程切换是由操作系统的时间片控制,而协程是程序自己实现的，让协程不断轮流执行才是实现并发，所以实现协程还必须要有一个类似于时间片的结构，不同于线程的切换，协程的切换不是按照时间来算的，而是按照代码既定分配，就是说代码运行到这一行才启动协程，协程是可以由我们程序员自己操控的。\n切换调度开销方面远比线程小。\n\nfunction* idMaker() &#123;    let index = 0;    while (true)         yield index++;&#125;let gen = idMaker(); // &quot;Generator &#123; &#125;&quot;console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2// 协程本身是个函数，协程之间的切换本质是函数执行权的转移。\n\n\nJS中的同步和异步\n\n（1）JS单线程所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个\n\nJS为什么是单线程?\n\n这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。\n为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n\n计算机的同步和异步解释?\n\n同步：**是阻塞模式，是按顺序执行，执行完一个再执行下一个，需要等待，协调运行；\n异步：**是非阻塞模式，无需等待，异步是彼此独立，在等待某事件的过程中，继续做自己的事，不需要等待这一事件完成后再工作。\n（2）JS任务任务\nJs引擎运行的环境是宿主环境,即Web浏览器  &#x2F; Node.js,但这些宿主环境都提供了一种机制处理程序中多个块的执行,且执行js语句,这种机制被称为事件循环机制\n任务队列:一个先进先出的数据结构，也称事件队列.\n宏任务\n微任务\n\n\n一个任务可能引起更多任务被添加\n\n\n分类-同步和异步\n为什么会有同步和异步任务?\n同步任务：主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务\n\n当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。\n\n异步任务：指不进入主线程，而进入任务队列的任务。只有任务队列通知主线程，某个异步任务可以执行，该任务才会进入主线程，当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务(单线程的JS通过事件循环实现异步)\n\nJS执行机制(Event loop)\n虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中.\n不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含下图中的3种 webAPI，分别是 DOM Binding、network、timer模块\n\n\n演示执行栈、event table、回调队列、event loop过程：\nhttp://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!\n关于heap和stack:深入理解js数据类型与堆栈内存 - 掘金\n\nJS的执行机制\n\n\n\n判断js代码是同步还是异步,同步就进入主进程,异步就进入event table\n异步和同步各自对应处理方式执行\n异步任务在event table中注册函数,当满足触发条件后,被推入event queue\n同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中\n\n\n\n\n总结\n\n首先判断js代码是同步还是异步,同步就进入主线程,异步就进入event table\n异步任务在event table中注册函数,当满足触发条件后,被推入event queue\n同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中\n\nJS的异步执行机制两个概念\n\nEvent Table（回调函数对应表）：用来存储 JavaScript 中的异步事件 (request, setTimeout, IO等) 及其对应的回调函数的列表\n执行栈：所有同步任务都在主线程上执行，形成执行栈\n\nblog-事件循环机制\n步骤\n\n文件读取操作（异步任务）会被添加到Event Table中，等IO事件完成后，就会在任务队列中添加一个事件，表示异步任务完成，可以进入执行栈\n判断主线程是否有空，当主线程处理完其它任务有空时，就会读取任务队列，如果该任务指定了回调函数，那么主线程在处理该事件时，就会执行回调函数中的代码，也就是执行异步任务\n单线程从从任务队列中读取任务是不断循环的，每次执行栈被清空后，都会在任务队列中读取新的任务，如果没有任务，就会等待直到有新的任务。\n\n举例\nconsole.log(&quot;setTime之前&quot;);setTimeout(() =&gt; &#123;     console.log(&quot;timeout callback&quot;);   &#125;, 0);console.log(&quot;setTime之后&quot;);\n\nJS中常见的异步A. 回调函数\n定义:你自己定义的函数、你不会调用、最终执行了\n分类: 同步和异步回调\n\n\n同步回调:立即执行,完全执行完了才结束,不会放入回调队列中\n\npop push  shift  unshift   reverse  concat   splice\n高阶函数\n\n异步回调:不会立即执行,会放入回调队列将来执行\n\n//同步回调 (数组遍历相关回调函数)let arr=[&#x27;s&#x27;,&#x27;i&#x27;,&#x27;p&#x27;,&#x27;c&#x27;]console.log(1)arr.forEach((v,k)=&gt;&#123;    console.log(v)&#125;)console.log(2)//异步回调  ajax请求/promise的失败成功/setTimout/setIntervalconsole.log(&quot;setTime之前&quot;);setTimeout(() =&gt; &#123;      console.log(&quot;timeout callback&quot;);   &#125;, 0);console.log(&quot;setTime之后&quot;);\n\n\n回调函数产生的问题\na. 回调地狱\n\n\n\n在使用JavaScript时，为了实现某些逻辑经常会写出层层嵌套的回调函数，如果嵌套过多，会极大影响代码可读性和逻辑。（eg：A函数的参数是B函数，B函数的参数C函数……）\nvar sayhello = function (name, callback) &#123;  setTimeout(function () &#123;    console.log(name);    callback();  &#125;, 1000);&#125;sayhello(&quot;first&quot;, function () &#123;  sayhello(&quot;second&quot;, function () &#123;    sayhello(&quot;third&quot;, function () &#123;      console.log(&quot;end&quot;);    &#125;);  &#125;);&#125;);\n\nb. 控制反转(IOC) \n回调最大的问题,会导致信任链断裂,使用回调需要应用某种逻辑解决所有这些控制反转导致的信任问题.\n//Aajax(&quot;/xxx&quot;,function()&#123;    //C&#125;,1000)//B\n\n问题总结:与大脑方式不同有顺序性问题   控制反转造成信任问题\n解决方式:Promise的使用 解决原理\nB. 事件监听任务的执行不取决于代码的顺序，而取决于某个事件是否发生\nC.发布订阅模式\n/***伪代码*/// 创建事件管理器实例const event =new EventEmitter() // 注册一个registerFinish事件监听者event.on(&#x27;registerFinish&#x27;, function() &#123; login()&#125;) event.on(&#x27;registerFinish&#x27;, function()&#123; fn2()&#125;) ..function registe()&#123;     setTimeout(()=&gt;&#123; // 触发事件        event.trigger(&quot;registerFinish&quot;)     &#125;,2000)&#125;function login() &#123;    console，log（＂fn2执行了＂） &#125;registe()\n\nD. Promises对象理解\nPromise是一个构造函数,用来封装一个异步操作并可以获得异步执行结果\nPromise的参数是一个回调函数(同步),返回值为仍Promise对象\nPromise对象必须实现then方法，而且then必须返回一个Promise对象，同一个Promise对象的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致\nthen方法接受两个参数，第一个参数是成功时的回调(异步)，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调(异步)\n\n状态\n1.pending(即将发生的)- - -&gt;resolved&#x2F;fullfilled\n2.pending(即将发生的)- - -&gt;rejected\n不能逆向转换，同时“完成”态和“拒绝”态不能相互转换\n注意:\n只有这两种状态转变,且一个Promise对象只能改变一次状态\n无论成功或失败都会有一个结果\n\n\n\n//promise简单举例const p = new Promise((resolve, reject) =&gt; &#123;  console.log(&quot;start promise&quot;);  let a=1  if(a==1)&#123;  resolve(&quot;success&quot;);  &#125;else&#123;  reject(&quot;error&quot;)  &#125;&#125;);p.then((val) =&gt; &#123;  console.log(val);//&quot;success&quot;&#125;);p.catch(err=&gt;&#123;console.log(err)&#125;)p.finally(()=&gt;&#123;console.log(123)&#125;)console.log(&quot;sync task&quot;);/*start promisesync tasksuccess*///进阶(Assignment)//eg1 console.log(&quot;sync task1&quot;);new Promise(    (resolve,reject)=&gt;&#123;        console.log(123)        setTimeout(() =&gt; &#123;          console.log(&#x27;setTimeout&#x27;)          resolve(&quot;成功的数据&quot;);          reject(&quot;失败的数据&quot;);        &#125;, 1000);    &#125;).then(    value=&gt;console.log(&quot;onResolved()1&quot;, value)    )    .catch(    reason=&gt;console.log(&quot;onRejected()1&quot;, reason)    )   console.log(&quot;sync task2&quot;);   //eg2 setTimeout(() =&gt; &#123;      console.log(&quot;timeout callback()&quot;);      Promise.resolve(1).then((value) =&gt; console.log(&quot;onResolved&quot;, value));   &#125;, 0); setTimeout(() =&gt; &#123;      console.log(&quot;timeout callback2()&quot;);    &#125;, 0);Promise.resolve(1).then((value) =&gt; console.log(&quot;onResolved&quot;, value));Promise.resolve(1).then((value) =&gt; console.log(&quot;onResolved2&quot;, value));//eg3setTimeout(() =&gt; &#123;      console.log(1); &#125;, 0);new Promise((resolve) =&gt; &#123;      console.log(2);      resolve();    &#125;)      .then(() =&gt; &#123;        console.log(3);      &#125;)       .then(() =&gt; &#123;        console.log(4);      &#125;);console.log(5);   \n\nPromise执行流程\nE. Generator 函数\nECMAScript 6 入门 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack\nF.async&#x2F;await\nasync是用来声明一个异步方法,await用来等待异步方法的执行\n正常情况下await后边是一个Promise对象,返回该对象的结果。如果不是Promise对象,直接返回封装好的promise。**await**都会阻塞函数中后边的代码（即加入微队列）\n\n//eg1async function f()&#123;    return await 123;&#125;f().then(value=&gt;console.log(value))//eg2async function fn1()&#123;    console.log(1)    await fn2();    console.log(2);//阻塞&#125;async function fn2()&#123;    console.log(&#x27;fn2&#x27;)&#125;fn1();console.log(3)\n\n二、异步中的宏\\微任务执行\n为什么引入微任务？异步任务也有需要紧急执行的，需要给他更高的优先级，例如dom操作如果等待过久，会看起来卡顿\n\n\n宏任务， 微任务一个微任务（microtask）就是一个简短的函数，当创建该函数的函数执行之后，并且只有当 Javascript 调用栈为空，而控制权尚未返还给被用户代理用来驱动脚本执行环境的事件循环之前，该微任务才会被执行。\n简单的说，先执行一个宏任务(最开始是script),然后执行所有微任务，然后宏、微直到全部执行完。\n参考：js 宏任务和微任务 - wangziye - 博客园\n体验一下\nsetTimeout(()=&gt;&#123;    console.log(&quot;1&quot;);&#125;,0);//避免晦涩地使用 promise 去创建微任务queueMicrotask(()=&gt;&#123;    console.log(&quot;2&quot;);&#125;);queueMicrotask(()=&gt;&#123;    console.log(&quot;3&quot;);&#125;);      setTimeout(() =&gt; &#123;        console.log(&quot;我是外部的setTimeout&quot;);        setTimeout(() =&gt; &#123;          console.log(&quot;我是内部的setTimeout&quot;);        &#125;, 0);        new Promise((resolve, reject) =&gt; &#123;          reject(&quot;我是定时器内部的promise&quot;);        &#125;)          .then((data) =&gt; &#123;            console.log(data);          &#125;)          .catch((err) =&gt; &#123;            console.log(err);          &#125;);      &#125;, 100);// sleep 函数   function sleep(numberMillis) &#123;      var now = new Date();      var exitTime = now.getTime() + numberMillis;      while (true) &#123;        now = new Date();        if (now.getTime() &gt; exitTime) return;      &#125;    &#125; // 使用sleep 函数去验证我们对主线任务和异步任务的思考  function addFunc() &#123;      console.time();      setTimeout(() =&gt; &#123;        console.timeEnd();        console.log(2);      &#125;, 0);  &#125;  sleep(1000)  addFunc()  function addProFunc() &#123;      new Promise((resolve, reject) =&gt; &#123;        console.time();        resolve();      &#125;)        .then(() =&gt; &#123;          console.timeEnd();        &#125;)        .catch((err) =&gt; &#123;          console.log(err);      &#125;);    &#125;\n\n\n我们可以看到这个图然后想一想，那些是宏任务，那些是微任务。\n宏任务 macro-task(Task)\nscript(主线程上第一个任务)\nsetTimeout\nsetInterval\nsetImmediate\nI&#x2F;O\nrequestAnimationFrame\nUI rendering\n\n微任务 micro-task(Job)\nprocess.nextTick\nPromise.then\nObject.observe (废弃)\nMutationObserver（监听DOM所有变化,MutationObserverAPI–微任务 - Lyra李 - 博客园）\n\n注意：事件循环每次只会入栈****一个 macrotask ，主线程执行完该任务后又会先检查 microtasks 队列并完成里面的所有任务后再执行 macrotask;\n宏任务中可以再生成宏任务和微任务。微任务也同理。\n那么下面就让我们做一些题来检验\n正常的调用\nfunction a1() &#123;   console.log(1);&#125;function a2() &#123;   console.log(2);&#125;function a3() &#123;   console.log(3);&#125;// 输出什么？\n\n添加定时器\nfunction a1() &#123;        console.log(1);      &#125;      function a2() &#123;        console.log(2);      &#125;      function a3() &#123;        console.log(3);      &#125;      setTimeout(() =&gt; &#123;        a3();        setTimeout(() =&gt; &#123;          a2();        &#125;, 0);      &#125;, 0);      a1();// A 任务setTimeout(() =&gt; &#123;    console.log(1)&#125;, 20)// B 任务setTimeout(() =&gt; &#123;    console.log(2)&#125;, 0)// C 任务setTimeout(() =&gt; &#123;    console.log(3)&#125;, 10)// DsetTimeout(() =&gt; &#123;    console.log(5)&#125;, 10)console.log(4)\n\n添加promise \nconsole.log(1)new Promise((resolve, reject) =&gt; &#123;    console.log(2)    resolve()&#125;).then(res =&gt; &#123;    console.log(3)&#125;)console.log(4)// 输出什么?1243 console.log(2);new Promise((resolve, reject) =&gt; &#123;  console.log(1);  resolve(3);  console.log(4);&#125;).then((data) =&gt; &#123;  console.log(data);&#125;);\n\n添加 async await\nconsole.log(1);var pro = new Promise((reject, resolve) =&gt; &#123;  console.log(2);  reject(3)&#125;);async function add() &#123;// 等待， pro reject  返回， mid   var mid = await pro  // 上面是同步的  console.log(mid);&#125;add()console.log(4);// 1243setTimeout(function () &#123;  console.log(&#x27;1&#x27;)&#125;, 0)console.log(&#x27;2&#x27;)async function async1() &#123;  console.log(&#x27;3&#x27;)  await async2()  console.log(&#x27;4&#x27;)&#125;async function async2() &#123;  console.log(&#x27;5&#x27;)&#125;async1()console.log(&#x27;6&#x27;)// 235641console.log(&#x27;1&#x27;)async function async1() &#123;  console.log(&#x27;2&#x27;)  await &#x27;await的结果&#x27;  console.log(&#x27;3&#x27;)&#125;async1()console.log(&#x27;4&#x27;)new Promise(function (resolve) &#123;  console.log(&#x27;5&#x27;)  resolve()&#125;).then(function () &#123;  console.log(&#x27;6&#x27;)&#125;) // 1 2 4 5 3  6\n\n热身结束\n\n第一题\n\nsetTimeout(function () &#123;    console.log(1)&#125;, 0);new Promise(function (resolve, reject) &#123;    console.log(2)    for (var i = 0; i &lt; 10000; i++) &#123;        if (i === 10) &#123;            console.log(10)        &#125;        i == 9999 &amp;&amp; resolve();    &#125;    console.log(3)&#125;).then(function () &#123;    console.log(4)&#125;)console.log(5);\n\n\n第二题   boss 副本\n\nconsole.log(&quot;start&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;children2&quot;)    Promise.resolve().then(() =&gt;&#123;        console.log(&quot;children3&quot;)    &#125;)&#125;, 0)new Promise(function(resolve, reject)&#123;    console.log(&quot;children4&quot;)    setTimeout(function()&#123;        console.log(&quot;children5&quot;)        resolve(&quot;children6&quot;)    &#125;, 0)&#125;).then(res =&gt;&#123;    console.log(&quot;children7&quot;)    setTimeout(() =&gt;&#123;        console.log(res)    &#125;, 0)&#125;)//s  4  2  3 5  7 6async function async1() &#123;    console.log(&#x27;async1 start&#x27;)    await async2()    console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123;    console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123;    console.log(&#x27;setTimeout&#x27;)&#125;, 0)async1()new Promise((resolve) =&gt; &#123;    console.log(&#x27;promise1&#x27;)    resolve()&#125;).then(function () &#123;    console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;)// script start   async1 start  async2 promise1  script end async1 end promise2 setTimeoutasync function async1() &#123;    console.log(&#x27;async1 start&#x27;);    await async2();    setTimeout(function() &#123;        console.log(&#x27;setTimeout1&#x27;)  // 这一部分代码会放入到 promise 的微任务队列中。    &#125;,0)&#125;async function async2() &#123;    setTimeout(function() &#123;        console.log(&#x27;setTimeout2&#x27;)    &#125;,0)&#125;console.log(&#x27;script start&#x27;);setTimeout(function() &#123;    console.log(&#x27;setTimeout3&#x27;);&#125;, 0);async1();new Promise(function(resolve) &#123;    console.log(&#x27;promise1&#x27;);    resolve();&#125;).then(function() &#123;    console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;);//宏队列 setTimeout3 setTimeout2  setTimeout1//script start  //async1 start//promise1//script end//promise2//setTimeout3 setTimeout2  setTimeout1\n\n总结: js整体代码执行，增加宏任务和微任务，在js整体代码结束的时候处理自身的微任务，然后事件循环机制去看任务队列中是否有需要被扔进执行栈的，如果有，那么就扔进去。\n看一个例子\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=clo, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      div &#123;        height: 100px;        width: 100px;        background-color: cadetblue;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;button class=&quot;btn&quot;&gt;点我就完事了&lt;/button&gt;  &lt;/body&gt;  &lt;script&gt;    var btn = document.querySelector(&quot;.btn&quot;);    btn.addEventListener(&quot;click&quot;, () =&gt; &#123;      var divNode = document.querySelector(&quot;div&quot;);      divNode.style.backgroundColor = &quot;red&quot;;      alert(&quot;你看见什么了呢?&quot;);    &#125;);  &lt;/script&gt;&lt;/html&gt;\n\n思考题: 为什么会发生这种情况? \nalert() 是 window 的内置函数，被认为是同步代码\nHTML部分&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;span&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/span&gt;        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;        &lt;span&gt;更多：&#123;&#123; more.like &#125;&#125;&lt;/span&gt;        &lt;input type=&quot;text&quot; v-model=&quot;more.like&quot;&gt;    &lt;/div&gt;    &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;//用来模拟实现Vue的js文件    &lt;script&gt;        const vm = new Vue(            &#123;                el:&quot;#app&quot;,                data:&#123;                    name:&quot;墨冉&quot;,                    more:&#123;                        like:&#x27;play game&#x27;                    &#125;                &#125;            &#125;        )    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nJS部分\n首先创建Vue构造函数，这里我们用类来实现\n\nclass Vue &#123;    constructor(obj_instance) &#123;        this.$data = obj_instance.data;    &#125;&#125;\n\n\n进行数据劫持\n\nclass Vue &#123;    constructor(obj_instance) &#123;        this.$data = obj_instance.data;                Observer(this.$data);//数据监听函数             &#125;&#125;\n\n数据监听函数需要用到 Object.defineProperty() \n该方法的详细内容 Object.defineProperty() - JavaScript | MDN\nObject.defineProperty(&quot;操作对象&quot;,&quot;操作属性&quot;,&#123;    enumerable: true,//设为true表示可枚举    configurable: true,//设为true表示可更改    get()&#123;&#125;,//在访问该属性时触发    set()&#123;&#125;,//在修改该属性时触发&#125;)//数据劫持function Observer(data_instance) &#123;    //递归出口    if (!data_instance || typeof data_instance !== &#x27;object&#x27;) return;    Object.keys(data_instance).forEach(key =&gt; &#123;        //存储对应的属性值        let value = data_instance[key];        //递归        Observer(value);//这里传参就不能是key，而是value        Object.defineProperty(data_instance, key, &#123;            enumerable: true,            configurable: true,            get() &#123;                console.log(`访问了属性：$&#123;key&#125;---值：$&#123;value&#125;`);                return value;            &#125;,            set(newValue) &#123;                console.log(`属性$&#123;key&#125;的值$&#123;value&#125;修改为--$&#123;newValue&#125;`);                value = newValue;                //更改的属性为对象时，进行数据劫持                Observer(newValue);            &#125;        &#125;)    &#125;)&#125;\n\n\n获取页面元素，放入临时内存区域，应用Vue数据，渲染页面\n\nclass Vue &#123;    constructor(obj_instance) &#123;        this.$data = obj_instance.data;                Observer(this.$data);//数据监听函数                Compile(obj_instance.el, this);//解析函数    &#125;&#125;//解析函数function Compile(element, vm) &#123;    vm.$el = document.querySelector(element);    //创建文档碎片    const fragment = document.createDocumentFragment();    console.log(vm.$el.childNodes);//查看获取到的子节点        //添加子节点到fragment里    let child;    while (child = vm.$el.firstChild) &#123;        fragment.append(child)    &#125;            fragment_compile(fragment)    //替换文档碎片内容    function fragment_compile(node) &#123;        const pattern = /\\&#123;\\&#123;\\s*(\\S+)\\s*\\&#125;\\&#125;/;//正则表达式，匹配&#123;&#123;&#125;&#125;        if (node.nodeType === 3) &#123;            const result_regex = pattern.exec(node.nodeValue);            if (result_regex) &#123;                console.log(node.nodeValue);                console.log(result_regex);                                console.log(vm.$data[result_regex[1]]);                const arr = result_regex[1].split(&#x27;.&#x27;);                const value = arr.reduce(                    (total, current) =&gt; total[current], vm.$data                )                console.log(value);                node.nodeValue = pattern.replace(pattern, value);                                console.log(node.nodeValue)            &#125;            return;         &#125;        node.childNodes.forEach(child =&gt; fragment_compile(child));    &#125;    vm.$el.appendChild(fragment);&#125;\n\n\n实现发布者-订阅者模式\n\n//收集和通知class Dependency &#123;    constructor() &#123;        this.subscribers = [];    &#125;    addSub(sub) &#123;        this.subscribers.push(sub);    &#125;    //通知方法    notify() &#123;        this.subscribers.forEach(sub =&gt; sub.update());    &#125;&#125;//订阅者class Watcher &#123;    constructor(vm, key, callback) &#123;        this.vm = vm;        this.key = key;        this.callback = callback;        Dependency.temp = this;        key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data);//触发getter函数        Dependency.temp = null;    &#125;    update() &#123;        const value = this.key.split(&#x27;.&#x27;).reduce(            (total, current) =&gt; total[current], this.vm.$data        )        this.callback(value);    &#125;&#125;//解析函数function Compile(element, vm) &#123;    vm.$el = document.querySelector(element);    //创建文档碎片    const fragment = document.createDocumentFragment();    let child;    while (child = vm.$el.firstChild) &#123;        fragment.append(child)    &#125;    fragment_compile(fragment)    function fragment_compile(node) &#123;        const pattern = /\\&#123;\\&#123;\\s*(\\S+)\\s*\\&#125;\\&#125;/;        if (node.nodeType === 3) &#123;            const xxx = node.nodeValue;//添加的            const result_regex = pattern.exec(node.nodeValue);            if (result_regex) &#123;                const arr = result_regex[1].split(&#x27;.&#x27;);                const value = arr.reduce(                    (total, current) =&gt; total[current], vm.$data                )                node.nodeValue = xxx.replace(pattern, value);//修改的                                //创建订阅者                new Watcher(vm, result_regex[1], newValue =&gt; &#123;//添加的                    node.nodeValue = xxx.replace(pattern, newValue);//添加的                &#125;)//添加的            &#125;            return;        &#125;        node.childNodes.forEach(child =&gt; fragment_compile(child));    &#125;    vm.$el.appendChild(fragment);&#125;//数据劫持function Observer(data_instance) &#123;    //递归出口    if (!data_instance || typeof data_instance !== &#x27;object&#x27;) return;    const dependency = new Dependency();//创建发布者实例    Object.keys(data_instance).forEach(key =&gt; &#123;        let value = data_instance[key];        //递归        Observer(value);        Object.defineProperty(data_instance, key, &#123;            enumerable: true,            configurable: true,            get() &#123;                console.log(`访问了属性：$&#123;key&#125;---值：$&#123;value&#125;`);                //订阅者加入依赖实例数组                Dependency.temp &amp;&amp; dependency.addSub(Dependency.temp);                return value;            &#125;,            set(newValue) &#123;                console.log(`属性$&#123;key&#125;的值$&#123;value&#125;修改为--$&#123;newValue&#125;`);                value = newValue;                //更改的属性为对象时，进行数据劫持                Observer(newValue);                //通知函数，通知订阅者                dependency.notify()            &#125;        &#125;)    &#125;)&#125;\n\n\n判断哪个节点有v-model\n\n//解析函数function Compile(element, vm) &#123;    vm.$el = document.querySelector(element);    //创建文档碎片    const fragment = document.createDocumentFragment();    let child;    while (child = vm.$el.firstChild) &#123;        fragment.append(child)    &#125;    fragment_compile(fragment)    function fragment_compile(node) &#123;        const pattern = /\\&#123;\\&#123;\\s*(\\S+)\\s*\\&#125;\\&#125;/;        if (node.nodeType === 3) &#123;            const xxx = node.nodeValue;            const result_regex = pattern.exec(node.nodeValue);            if (result_regex) &#123;                const arr = result_regex[1].split(&#x27;.&#x27;);                const value = arr.reduce(                    (total, current) =&gt; total[current], vm.$data                )                node.nodeValue = xxx.replace(pattern, value);                //创建订阅者                new Watcher(vm, result_regex[1], newValue =&gt; &#123;                    node.nodeValue = xxx.replace(pattern, newValue);                &#125;)            &#125;            return;        &#125;                //------------------------------------------------------------------------------        //判断哪个节点有v-model，看下面        if (node.nodeType === 1 &amp;&amp; node.nodeName === &#x27;INPUT&#x27;) &#123;            //attr获取节点属性并给他们转换成数组            const attr = Array.from(node.attributes);            //对这个数组进行遍历去寻找v-model属性            attr.forEach(i =&gt; &#123;                if (i.nodeName === &#x27;v-model&#x27;) &#123;                    //获取vue实例中的数据                    const value = i.nodeValue.split(&#x27;.&#x27;).reduce(                        (total, current) =&gt; total[current], vm.$data                    );                    //将值赋值给input的value属性                    node.value = value;                    //给v-model创建订阅者实例                    new Watcher(vm, i.nodeValue, newValue =&gt; &#123;                        //直接将新的值赋值给input的value属性                        node.value = newValue                    &#125;)                                        node.addEventListener(&quot;input&quot;, e =&gt; &#123;                        const arr1 = i.nodeValue.split(&#x27;.&#x27;);                        const arr2 = arr1.slice(0, arr1.length - 1);                        const final = arr2.reduce(                            (total, current) =&gt; total[current], vm.$data                        )                        final[arr1[arr1.length - 1]] = e.target.value;                    &#125;)                &#125;            &#125;)        &#125;        //看上面        //------------------------------------------------------------------------------                node.childNodes.forEach(child =&gt; fragment_compile(child));    &#125;    vm.$el.appendChild(fragment);&#125;\n\nALLclass Vue &#123;    constructor(obj_instance) &#123;        this.$data = obj_instance.data;        Observer(this.$data);        Compile(obj_instance.el, this);    &#125;&#125;//数据劫持function Observer(data_instance) &#123;    //递归出口    if (!data_instance || typeof data_instance !== &#x27;object&#x27;) return;    const dependency = new Dependency();    Object.keys(data_instance).forEach(key =&gt; &#123;        let value = data_instance[key];        //递归        Observer(value);        Object.defineProperty(data_instance, key, &#123;            enumerable: true,            configurable: true,            get() &#123;                // console.log(`访问了属性：$&#123;key&#125;---值：$&#123;value&#125;`);                //订阅者加入依赖实例数组                Dependency.temp &amp;&amp; dependency.addSub(Dependency.temp);                return value;            &#125;,            set(newValue) &#123;                // console.log(`属性$&#123;key&#125;的值$&#123;value&#125;修改为--$&#123;newValue&#125;`);                value = newValue;                //更改的属性为对象时，进行数据劫持                Observer(newValue);                dependency.notify()            &#125;        &#125;)    &#125;)&#125;// 解析函数function Compile(element, vm) &#123;    vm.$el = document.querySelector(element);    // 创建文档碎片    const fragment = document.createDocumentFragment();    let child;    while (child = vm.$el.firstChild) &#123;        // console.log(child);        fragment.append(child)    &#125;    // console.log(fragment)    fragment_compile(fragment)    function fragment_compile(node) &#123;        const pattern = /\\&#123;\\&#123;\\s*(\\S+)\\s*\\&#125;\\&#125;/;        if (node.nodeType === 3) &#123;            const xxx = node.nodeValue;            const result_regex = pattern.exec(node.nodeValue);            // console.log(result_regex)            if (result_regex) &#123;                const arr = result_regex[1].split(&#x27;.&#x27;);                const value = arr.reduce(                    (total, current) =&gt; total[current], vm.$data                )                node.nodeValue = xxx.replace(pattern, value);                //创建订阅者                new Watcher(vm, result_regex[1], newValue =&gt; &#123;                    node.nodeValue = xxx.replace(pattern, newValue);                &#125;)            &#125;            return;        &#125;        if (node.nodeType === 1 &amp;&amp; node.nodeName === &#x27;INPUT&#x27;) &#123;            const attr = Array.from(node.attributes);            attr.forEach(i =&gt; &#123;                if (i.nodeName === &#x27;v-model&#x27;) &#123;                    const value = i.nodeValue.split(&#x27;.&#x27;).reduce(                        (total, current) =&gt; total[current], vm.$data                    );                    node.value = value;                    new Watcher(vm, i.nodeValue, newValue =&gt; &#123;                        node.value = newValue                    &#125;)                    node.addEventListener(&quot;input&quot;, e =&gt; &#123;                        const arr1 = i.nodeValue.split(&#x27;.&#x27;);                        const arr2 = arr1.slice(0, arr1.length - 1);                        const final = arr2.reduce(                            (total, current) =&gt; total[current], vm.$data                        )                        final[arr1[arr1.length - 1]] = e.target.value;                    &#125;)                &#125;            &#125;)        &#125;        node.childNodes.forEach(child =&gt; fragment_compile(child));    &#125;    vm.$el.appendChild(fragment);&#125;//收集和通知class Dependency &#123;    constructor() &#123;        this.subscribers = [];    &#125;    addSub(sub) &#123;        this.subscribers.push(sub);    &#125;    //通知方法    notify() &#123;        this.subscribers.forEach(sub =&gt; sub.update());    &#125;&#125;//订阅者class Watcher &#123;    constructor(vm, key, callback) &#123;        this.vm = vm;        this.key = key;        this.callback = callback;        Dependency.temp = this;        key.split(&#x27;.&#x27;).reduce((total, current) =&gt; total[current], vm.$data);        Dependency.temp = null;    &#125;    update() &#123;        const value = this.key.split(&#x27;.&#x27;).reduce(            (total, current) =&gt; total[current], this.vm.$data        )        this.callback(value);    &#125;&#125;\n\nclass Vue {    constructor(obj_instance) {        this.$data &#x3D; obj_instance.data;        Observer(this.$data);        Compile(obj_instance.el, this);    }}\n&#x2F;&#x2F;数据劫持function Observer(data_instance) {    &#x2F;&#x2F;递归出口    if (!data_instance || typeof data_instance !&#x3D;&#x3D; ‘object’) return;    const dependency &#x3D; new Dependency();    Object.keys(data_instance).forEach(key &#x3D;&gt; {        let value &#x3D; data_instance[key];        &#x2F;&#x2F;递归        Observer(value);\n    Object.defineProperty(data_instance, key, &#123;\n        enumerable: true,\n        configurable: true,\n        get() &#123;\n            // console.log(`访问了属性：$&#123;key&#125;---值：$&#123;value&#125;`);\n            //订阅者加入依赖实例数组\n            Dependency.temp &amp;&amp; dependency.addSub(Dependency.temp);\n            return value;\n        &#125;,\n        set(newValue) &#123;\n            // console.log(`属性$&#123;key&#125;的值$&#123;value&#125;修改为--$&#123;newValue&#125;`);\n            value = newValue;\n            //更改的属性为对象时，进行数据劫持\n            Observer(newValue);\n            dependency.notify()\n        &#125;\n    &#125;)\n&#125;)\n\n}\n&#x2F;&#x2F; 解析函数function Compile(element, vm) {    vm.$el &#x3D; document.querySelector(element);    &#x2F;&#x2F; 创建文档碎片    const fragment &#x3D; document.createDocumentFragment();\nlet child;\nwhile (child = vm.$el.firstChild) &#123;\n    // console.log(child);\n    fragment.append(child)\n&#125;\n// console.log(fragment)\nfragment_compile(fragment)\n\nfunction fragment_compile(node) &#123;\n    const pattern = /\\&#123;\\&#123;\\s*(\\S+)\\s*\\&#125;\\&#125;/;\n    if (node.nodeType === 3) &#123;\n        const xxx = node.nodeValue;\n        const result_regex = pattern.exec(node.nodeValue);\n        // console.log(result_regex)\n        if (result_regex) &#123;\n            const arr = result_regex[1].split(&#39;.&#39;);\n            const value = arr.reduce(\n                (total, current) =&gt; total[current], vm.$data\n            )\n            node.nodeValue = xxx.replace(pattern, value);\n            //创建订阅者\n            new Watcher(vm, result_regex[1], newValue =&gt; &#123;\n                node.nodeValue = xxx.replace(pattern, newValue);\n            &#125;)\n        &#125;\n        return;\n    &#125;\n    if (node.nodeType === 1 &amp;&amp; node.nodeName === &#39;INPUT&#39;) &#123;\n        const attr = Array.from(node.attributes);\n        attr.forEach(i =&gt; &#123;\n            if (i.nodeName === &#39;v-model&#39;) &#123;\n                const value = i.nodeValue.split(&#39;.&#39;).reduce(\n                    (total, current) =&gt; total[current], vm.$data\n                );\n                node.value = value;\n                new Watcher(vm, i.nodeValue, newValue =&gt; &#123;\n                    node.value = newValue\n                &#125;)\n                node.addEventListener(&quot;input&quot;, e =&gt; &#123;\n                    const arr1 = i.nodeValue.split(&#39;.&#39;);\n                    const arr2 = arr1.slice(0, arr1.length - 1);\n                    const final = arr2.reduce(\n                        (total, current) =&gt; total[current], vm.$data\n                    )\n                    final[arr1[arr1.length - 1]] = e.target.value;\n                &#125;)\n            &#125;\n        &#125;)\n    &#125;\n    node.childNodes.forEach(child =&gt; fragment_compile(child));\n&#125;\nvm.$el.appendChild(fragment);\n\n}\n&#x2F;&#x2F;收集和通知class Dependency {    constructor() {        this.subscribers &#x3D; [];    }\naddSub(sub) &#123;\n    this.subscribers.push(sub);\n&#125;\n//通知方法\nnotify() &#123;\n    this.subscribers.forEach(sub =&gt; sub.update());\n&#125;\n\n}\n&#x2F;&#x2F;订阅者class Watcher {    constructor(vm, key, callback) {        this.vm &#x3D; vm;        this.key &#x3D; key;        this.callback &#x3D; callback;        Dependency.temp &#x3D; this;        key.split(‘.’).reduce((total, current) &#x3D;&gt; total[current], vm.$data);        Dependency.temp &#x3D; null;    }    update() {        const value &#x3D; this.key.split(‘.’).reduce(            (total, current) &#x3D;&gt; total[current], this.vm.$data        )        this.callback(value);    }}\n"},{"title":"发布订阅模式vs观察者模式","url":"/2024/09/20/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8Fvs%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"设计模式wiki中将设计模式分为四类，分别是：\n\n创建模式（creational patterns）\n结构模式（structural patterns）\n行为模式（behavioral patterns）\n并发模式（concurrency patterns）\n\n观察者&#x2F;发布订阅模式属于其中的行为模式。\n实际情境公众号订阅说到发布订阅，拿微信公众号举例，就很好理解，有n个人订阅了某公众号，在该公众号发布了推文后，这n个人就会收到推文发布的消息。\n状态更新在实际编程过程中，有一种情况很多人应该碰到过，就是在页面上完成一些与接口的交互操作后，要更新页面的某些状态，但这个状态由于某些原因无法立即获得，如果要得到状态的更新结果，可以有两种选择，一种是重复请求接口以获取，可以是用户手动刷新页面或请求接口、或者交互结束后自动开启接口轮询；第二种是建立长连接，等待服务端推送结果。第二种方式，就可以算作是一种发布-订阅，订阅者是客户端，订阅内容是页面状态，发布者就是服务端。\n为什么说观察者&#x2F;发布订阅属于行为模式从上述例子就可以理解，原本的行为是客户端主动去获取内容，应用了此模式后，行为变成了客户端订阅（发起长连接请求）、由服务端来推送消息，行为方式发生了变化；并且我们也可以看出，这样做提高了应用的性能，客户端不必要再多次地去发起请求，减少了建立网络请求的消耗。\n定义定义了对象之间一对多的依赖关系，其中一个对象的状态变更，会使其所有依赖对象收到通知并自动更新。\n可以看出，这两个模式处理的是存在一对多依赖关系的双方之间的交互行为。\n虽然描述相同，但两者的实际实现还是存在区别，我们可以再进一步了解。\n观察者模式主体对象维护依赖对象(观察者)的列表,制动通知他们的任何变化,通过调用他们的方法\n发布-订阅模式发布者将消息分类,再有订阅者接受,同样，订阅者对一个或多个类别表示感兴趣，只是接收感兴趣的信息，但并不知道有哪些发布者（如果有的话）。\n发布-订阅是消息队列模式的同类，通常是更大的面向消息的中间件系统的一部分。大多数消息传递系统的API中同时支持发布&#x2F;订阅和消息队列模型；比如Java消息服务（JMS）。\n该模式提供了更高的网络可扩展性和更动态的网络拓扑结构，但也因此降低了修改发布者和发布数据结构的灵活性。\n由上述两个定义可知，在发布-订阅模式中，发布者和订阅者的耦合度更低，订阅者并不知道消息的发布者，在这种模式下，通常会存在一个第三方的订阅中心，订阅中心接收到发布者的消息，然后再将消息分发给订阅者；而在观察者模式中，观察者是通过在主体身上放置监听器从而直接观察主体，相当于是发布者（主体）直接将消息传递给订阅者（观察者），此时两者的耦合性更高，这种模式下，观察者需要实现统一的接口以供主体调用，而主体则需要维护一个观察者的集合。\n目前应用vue的事件总线\n// 创建一个事件总线并导出const EventBus = new Vue();export default EventBus;// 在主文件中引入EventBus，并挂载到全局import bus from &#x27;EventBus文件路径&#x27;;Vue.prototype.bus = bus;// 订阅事件“someEvent”// 这里func指someEvent这个事件的监听函数，也即在收到消息后通知订阅者的方法this.bus.$on(&#x27;someEvent&#x27;, func);//订阅者// 发布（触发）事件“someEvent”// 这里params指someEvent这个事件被触发时回调函数接收的入参，也就是传递给订阅者的状态this.bus.$emit(&#x27;someEvent&#x27;, params);//发布者\n\nvue3的ref实现\n"},{"title":"复习vue2","url":"/2024/09/23/%E5%A4%8D%E4%B9%A0vue2/","content":"vue实例Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：\n最基础的声明式渲染:\n&lt;div id=&quot;app&quot;&gt;  &#123;&#123; message &#125;&#125;&lt;/div&gt;\n\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;Hello Vue!&#x27;  &#125;&#125;)\n\n现在数据和 DOM 已经被建立了关联，所有东西都是响应式的\n\n如何实现的?当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter&#x2F;setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。\ndefinProperty是一种更加高级的为对象添加属性的方式:ES5之后所有的属性具备了属性描述符\nobject.defineproperty(myObje,&#x27;a&#x27;,&#123;value:2//属性值writable:true//是否可以修改--false时相当于定义空setterconfigable:true//单项操作,不可删除enumerable:true//可枚举&#125;)\n\n这些 getter&#x2F;setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter&#x2F;setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。\n每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\n\n\n注意事项由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：\nVue 不能检测以下数组的变动：\n\n当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n\n当你修改数组的长度时，例如：vm.items.length = newLength   可能你还没有注意到， \n Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n\n\n\n注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 #app) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。\n\n\n也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。不要在选项 property 或回调上使用箭头函数\nvue模版语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。\n在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。\n侦听器vs监视属性虽然计算属性在大多数情况下因为能够避免命令式的重复和可以提供setter而更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n&lt;div id=&quot;watch-example&quot;&gt;  &lt;p&gt;    Ask a yes/no question:    &lt;input v-model=&quot;question&quot;&gt;  &lt;/p&gt;  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123;  el: &#x27;#watch-example&#x27;,  data: &#123;    question: &#x27;&#x27;,    answer: &#x27;I cannot give you an answer until you ask a question!&#x27;  &#125;,  watch: &#123;    // 如果 `question` 发生改变，这个函数就会运行    question: function (newQuestion, oldQuestion) &#123;      this.answer = &#x27;Waiting for you to stop typing...&#x27;      this.debouncedGetAnswer()    &#125;  &#125;,  created: function () &#123;    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，    // 请参考：https://lodash.com/docs#debounce    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)  &#125;,  methods: &#123;    getAnswer: function () &#123;      if (this.question.indexOf(&#x27;?&#x27;) === -1) &#123;        this.answer = &#x27;Questions usually contain a question mark. ;-)&#x27;        return      &#125;      this.answer = &#x27;Thinking...&#x27;      var vm = this      axios.get(&#x27;https://yesno.wtf/api&#x27;)        .then(function (response) &#123;          vm.answer = _.capitalize(response.data.answer)        &#125;)        .catch(function (error) &#123;          vm.answer = &#x27;Error! Could not reach the API. &#x27; + error        &#125;)    &#125;  &#125;&#125;)&lt;/script&gt;\n\n\nlodashLodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。\nLodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法 非常适用于：\n\n遍历 array、object 和 string\n对值进行操作和检测\n创建符合功能的函数\n\n\nv-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。&#x2F;&#x2F;避免切换时无法获取条件变真\n相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n","categories":["vue"]},{"title":"vue3响应式原理详解（未完成","url":"/2024/09/23/vue3%E9%83%A8%E5%88%86%E5%8E%9F%E7%90%86/","content":"响应式基础ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回：\nconst count = ref(0)console.log(count) // &#123; value: 0 &#125;console.log(count.value) // 0count.value++console.log(count.value) // 1\n\n响应式原理当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会触发追踪它的组件的一次重新渲染。在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。\n该 .value 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：\n核心思想\n假若A&#x3D;a+b,目标是使ab变化时能够及时调用update()&#x2F;&#x2F;返回新A值的函数此时a,b被称为依赖,update被称为作用或者对这两个依赖的订阅者因此此时需要解决的就是需要某个函数–&gt;在依赖变化时产生作用(调用update这个函数)这个函数的作用应该是:当一个变量被读取时追踪–&gt;执行a+b时读取来了ab此时追踪这两个变量如果某个作用读取了被追踪的变量那么这个作用(函数)被设定为变量的订阅者探测追踪的变量的变化,新赋值之后要通知所有的订阅者作用来重新执行\nvue的响应式工作原理\n原生 JavaScript 没有提供任何机制能做到这一点。但是，我们是可以追踪对象属性的读写的。\n在 JavaScript 中有两种劫持 property 访问的方式：getter &#x2F; setters 和 Proxies。Vue 2 使用 getter &#x2F; setters 完全是出于支持旧版本浏览器的限制。而在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter &#x2F; setter 用于 ref。下面的伪代码将会说明它们是如何工作的：\n\nproxy\n使用 Proxy 对象，您可以为另一个对象创建代理，该对象可以拦截和重新定义该对象的基本操作。\nProxy 对象允许您创建一个对象，该对象可以代替原始对象，但可能会重新定义基本的 Object 操作，例如获取、设置和定义属性。代理对象通常用于记录属性访问、验证、格式化或清理输入等。\n您可以使用两个参数创建一个 Proxy ：\n\ntarget ： 要代理的原始对象\nhandler ：一个对象，用于定义哪些操作将被拦截以及如何重新定义拦截的操作。  handler对象中提供了get()可以拦截访问目标属性\n\n因此reactive具有一定局限性:\n\n有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。\n不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：\n对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接\n\n\n\nfunction reactive(obj) &#123;return new Proxy(obj, &#123; get(target, key) &#123;   track(target, key)//负责记录使用这个属性观察者,组件实例或者计算属性实例添加到一个列表中,方便以后修改了挨个通知依赖项更新。   return target[key] &#125;, set(target, key, value) &#123;   target[key] = value   trigger(target, key)//找到所有依赖于这个属性的组件或者计算属性,然后与调用更新 &#125;&#125;)&#125;function ref(value) &#123;//普通的getter和setter   此时的value是一个普通的基本值,被包装成一个ref对象const refObject = &#123; get value() &#123;   track(refObject, &#x27;value&#x27;)   return value &#125;, set value(newValue) &#123;   value = newValue   trigger(refObject, &#x27;value&#x27;) &#125;&#125;return refObject&#125;\n\n\ntrack函数:\n在 track() 内部，我们会检查当前是否有正在运行的副作用。如果有，我们会查找到一个存储了所有追踪了该属性的订阅者的 Set，然后将当前这个副作用作为新订阅者添加到该 Set 中。\n// 这会在一个副作用就要运行之前被设置// 我们会在后面处理它let activeEffectfunction track(target, key) &#123;if (activeEffect) &#123;//判断是否有正在运行的订阅者(副作用)----&gt;组件实例或者计算属性 const effects = getSubscribersForProperty(target, key)//副作用订阅将被存储在一个全局的 WeakMap&lt;target, Map&lt;key, Set&lt;effect&gt;&gt;&gt; 数据结构中。如果在第一次追踪时没有找到对相应属性订阅的副作用集合，它将会在这里新建。 effects.add(activeEffect)&#125;&#125;\n\ntrigger函数:\n在 trigger() 之中，我们会再查找到该属性的所有订阅副作用。但这一次我们需要执行它们：\nfunction trigger(target, key) &#123;const effects = getSubscribersForProperty(target, key)effects.forEach((effect) =&gt; effect())//执行他们的更新函数&#125;\n\nwhenDepsChange函数:(更新函数)\nfunction whenDepsChange(update) &#123;const effect = () =&gt; &#123;//他的外包装,宣告此时他是活跃的副作用 activeEffect = effect update()//实际更新 activeEffect = null&#125;effect()&#125;\n\nVue 提供了一个 API 来让你创建响应式副作用 watchEffect()。事实上，你会发现它的使用方式和我们上面示例中说的魔法函数 whenDepsChange() 非常相似,这个api运行你所需要的实际更新.\n\n","categories":["vue"]},{"title":"vue3复习","url":"/2024/09/23/vue3%E5%A4%8D%E4%B9%A0/","content":"vue3应用实例每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例：&#x2F;&#x2F;工厂函数createApp\nimport &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;  /* 根组件选项 */&#125;)\n\n根组件我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。\n如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。\njs\nimport &#123; createApp &#125; from &#x27;vue&#x27;// 从一个单文件组件中导入根组件import App from &#x27;./App.vue&#x27;const app = createApp(App)\n\n挂载应用应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：\nhtml\n&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\njs\napp.mount(&#x27;#app&#x27;)\n\n应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。\n.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。\nDOM 中的根组件模板根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供：\nhtml\n&lt;div id=&quot;app&quot;&gt;  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/div&gt;\n\njs\nimport &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;&#125;)app.mount(&#x27;#app&#x27;)\n\n当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。\nDOM 内模板通常用于无构建步骤的 Vue 应用程序。它们也可以与服务器端框架一起使用，其中根模板可能是由服务器动态生成的。\n应用配置应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：\njs\napp.config.errorHandler = (err) =&gt; &#123;  /* 处理错误 */    // 处理错误，比如记录到日志  console.error(&#x27;错误:&#x27;, err);  // 可以显示友好的提示  alert(&#x27;出现了一个错误！&#x27;);&#125;\n\n应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：\njs\napp.component(&#x27;TodoDeleteButton&#x27;, TodoDeleteButton)\n\n这使得 TodoDeleteButton 在应用的任何地方都是可用的。我们会在指南的后续章节中讨论关于组件和其他资源的注册。你也可以在 API 参考中浏览应用实例 API 的完整列表。\n确保在挂载应用实例之前完成所有应用配置！\n多个应用实例应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。\njs\nconst app1 = createApp(&#123;  /* ... */&#125;)app1.mount(&#x27;#container-1&#x27;)const app2 = createApp(&#123;  /* ... */&#125;)app2.mount(&#x27;#container-2&#x27;)\n\n如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。\n指令动态绑定多个值如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：\njs\nconst objectOfAttrs = &#123;  id: &#x27;container&#x27;,  class: &#x27;wrapper&#x27;,  style: &#x27;background-color:green&#x27;&#125;\n\n通过不带参数的 v-bind，你可以将它们绑定到单个元素上：\ntemplate\n&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;\n\n模板语法支持单一表达式\n支持调用函数（组件暴露的方法\n受限的全局访问模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。在 app.config.globalProperties 上显式地添加它们，供所有的 Vue 表达式使用。\n\n指令参数\n某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute：\n  template\n  &lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n  这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。\n  另一个例子是 v-on 指令，它将监听 DOM 事件：\n  template\n  &lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n  这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。\n  &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n  这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 &quot;href&quot;，那么这个绑定就等价于 v-bind:href。\n  &lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n  在此示例中，当 eventName 的值是 &quot;focus&quot; 时，v-on:[eventName] 就等价于 v-on:focus。\n\n动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。\n\n\n\n\n\n\ndom的更新时机修改了响应式状态时,dom会自动更新,但更新不是同步的.会在nextTick中缓冲修改,修改多次但组件只更新一次\nTS\n为ref()标注类型TS\n根据初始化的值推导出类型 const year &#x3D; ref(2020)\n使用Ref类型 const year: Ref&lt;string | number&gt; &#x3D; ref(‘2020’)\n调用 ref() 时传入一个泛型参数，来覆盖默认的推导行为：const year &#x3D; ref&lt;string | number&gt;(‘2020’) 但是未传递初始值是得到泛型加undefined的联合类型\n\n为reactive标注类型\n隐式推导参数&#x2F;&#x2F; 推导得到的类型：{ title: string } const book &#x3D; reactive({ title: ‘Vue 3 指引’ })\n\n要显式地标注一个 reactive 变量的类型，我们可以使用接口：\n import &#123; reactive &#125; from &#x27;vue&#x27;\tinterface Book &#123;  title: string  year?: number&#125;\tconst book: Book = reactive(&#123; title: &#x27;Vue 3 指引&#x27; &#125;)\n\n​\t不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。\n为compute标注类型\ncomputed() 会自动从其计算函数的返回值上推导出类型：\nimport &#123; ref, computed &#125; from &#x27;vue&#x27;const count = ref(0)// 推导得到的类型：ComputedRef&lt;number&gt;const double = computed(() =&gt; count.value * 2)// =&gt; TS Error: Property &#x27;split&#x27; does not exist on type &#x27;number&#x27;const result = double.value.split(&#x27;&#x27;)\n\n你还可以通过泛型参数显式指定类型：\nconst double = computed&lt;number&gt;(() =&gt; &#123;  // 若返回值不是 number 类型则会报错&#125;)\n\n\n\n","categories":["vue"]},{"title":"你不知道的javascript上卷整理","url":"/2024/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E4%B8%8A%E5%8D%B7%E6%95%B4%E7%90%86/","content":"作用域是什么编译原理传统编译语言流程:\n\n分词&#x2F;词法分析:编程语言的字符串分解成词法单元\n解析&#x2F;语法分析:将词法单元流(数组)转换成元素组成的代表程序语法结构的树–抽象语法树\n代码生成:将抽象语法树转化为可执行代码(和语言,目标平台相关)—–通过某种方法转换成机器指令执行想执行的任务\n\n但是javascript有更复杂的引擎,会在语法分析和生成代码阶段优化运行性能\n对于javascript来说编译仅发生在执行前几微妙—作用域背后javascript引擎会用许多方法延迟编译来保证性能更好\n理解作用域\n引擎:负责整个js程序的编译和执行过程\n编译器:负责编译中的语法分析和代码生成\n作用域:收集和维护标识符组成的查询,确定代码对当前标识符的访问权限——&gt;根据名称找变量的一套规则\n\n&#x3D;&#x3D;javascript的执行:&#x3D;&#x3D;编译器先进行分词,语法分析——&gt;编译器向作用域集合查找该变量名,(没有就声明)—-&gt;编译器生成运行时代码,引擎询问作用域查找变量,查找并赋值\n&#x3D;&#x3D;左查找和右查找&#x3D;&#x3D;\n\n左查找:试图找到变量的容器本身,从而可以对其赋值  eg:某变量的赋值,函数参数的赋值\n右查找:找到他的值(非左侧查找)  eg:函数调用,值的使用\n\n作用域嵌套当块或者函数嵌套在另一个块或者函数中的时候,发生了作用域的嵌套,在当前作用域中无法找到某个变量时,引擎会在外城嵌套的作用域中继续查找,知道抵达最外层的作用域或者找到该变量.\n异常\n右查找找不到时:抛出referenceError  右查找找到了但操作不合法:typeError\n左查找找不到时:创建一个该名称变量返还给引擎\n\n严格模式:\n\n左查找失败:referenceError\n同上\n\n词法作用域词法作用域vs动态作用域\n词法阶段词法化:编译器的工作第一阶段(分词和语法分析)\n词法作用域是一个由词法化这个词衍生出来的词语.是定义在词法阶段的作用域,是由写代码是变量和块作用域写在哪里实现的.\n作用域会根据词法作用域的嵌套结构提供的位置信息,由引擎进行查找,并在查找到第一个符合的标识符停止,因此对外层产生了遮蔽效应\n[^如果是全局变量,实际是全局对象的属性,例如浏览器的window对象,在遮蔽的情况下可以被通过window.变量名访问,其他则不可访问]: \n欺骗词法两种会导致性能下降的机制可以欺骗词法作用域\n函数作用域和块作用域","tags":["js"]},{"title":"TCP篇","url":"/2025/08/29/TCP%E7%AF%87/","content":"TCP的基本认识传输层的由来：\n\n网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机吗，但是只找到主机有用吗，是不是程序之间进行的沟通啊像QQ、浏览器和京东服务器，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，\n那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。\n\nIP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。\n如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的\n传输层功能：建立端口到端口的通信(端对端通信)\n补充：端口范围0-65535，0-1023为系统占用端口\ntcp协议：TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。\n\n面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；\n可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；\n字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃\n\nTCP连接：\n建立一个 TCP 连接是客户端与服务端达成三个信息的共识。• Socket：由 IP 地址和端口号组成• 序列号：用来解决乱序问题等• 窗口大小：用来做流量控制\n\n\n\n以太网头\nip 头\ntcp头\n数据\n\n\n\n\n\n20字节\n理论上可以无限长，但是为了保证效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割，在传输层进行分片。1460\n\n\n\n\n\n以太网头\nip头\nudp头\n数据\n\n\n\n\n\n8个字节\n总长度不超过65,535字节，正好放进一个IP数据包。\n\n\ntcp报文　　　　\n 序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。控制位：\n\nACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。\nRST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。\nSYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。\nFIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。  为什么需要 TCP 协议？ TCP 工作在哪一层？\n\nUDP报文\n\n\n目标和源端口：告诉UDP协议应该将报文发到哪个进程\n包长度：保存UDP总长度\n校验和：防止受损\n\nTCP与UDP的区别\nUDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。\n\nTCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。\n\n\n常用的端口号：\n\n\n\n应用程序\nFTP\nTFTP\nTELNET\nSMTP\nDNS\nHTTP\nSSH\nMYSQL\n\n\n\n熟知端口\n21,20\n69\n23\n25\n53\n80\n22\n3306\n\n\n传输层协议\nTCP\nUDP\nTCP\nTCP\nUDP\nTCP\n\n\n\n\ntcp三次握手和四次挥手三次握手：\nTCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；\nTCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。\nTCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。\nTCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。\n当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。\n\n为什么是三次握手？（待补充四次挥手：数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。服务端也可以主动关闭，一个流程。\n\n客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n为什么四次挥手？（待补充Socket编程（待补充(TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。)\n当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex，双方都可以收发消息) 的通信。\n这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。\n"},{"title":"TCP篇（2）","url":"/2025/08/29/TCP%E7%AF%87%EF%BC%882%EF%BC%89/","content":"TCP重传、滑动窗口、流量控制、拥塞控制TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的，着重介绍重传机制、滑动窗口、流量控制、拥塞控制。\n重传机制在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。\n\n\n常见的重传机制：\n\n超时重传\n快速重传\nSACK\nD-SACK\n\n超时重传在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。\nTCP 会在以下两种情况发生超时重传：\n\n数据包丢失\n确认应答丢失\n\n上文提到的指定时间的确定：\nRTT：往返时延，指的是数据发送时刻到确认的时刻的插值\nRTO：超时重传时间，应该 略大于RTT\n实际上，由于我们的网络是时刻变化的，RTT的值是经常变化的，因此RTO也应该是一个 动态变化的值\n\n这个动态变化的值根据某种公式计算出来，公式待补充\n多次重传时，TCP的处理：如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。\n快速重传\n\nseq1~6，全部发送，但是当2发送失败时，后续收到345都会返回ack2。\n因此，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。\n快速重传还需思考的问题假如， Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？\n\n只传了seq2，则还需要等3个ack3，确认seq3也丢失了\n若是全部重传，则seq4~6白传\n\n为解决此问题引入sack方法\nSACK选择性确认，在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\n\n\nD-SACKACK丢失情况使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。\n\n\n两次ack丢失，超过了发送方的一次的超时时延，对第一波数据包进行超时重发，而接受方发现是重复的数据，于是回了一个 SACK &#x3D; 30003500，告诉「发送方」 30003500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到。由此发送方可以判断是接收方ACK丢失，并不会继续进行超时重传。\n网络时延情况\n\n好处\n发送方可以确认是包丢了还是ack丢了\n是否是延迟了\n是否重复传输\n\n滑动窗口窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n累计确认窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。\n窗口大小的确定\n\nTCP头部的window字段，即窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。\n\n因此窗口的大小由接收方的窗口大小来决定。\n\n发送方窗口的内容变化过程\n\n\n发送方将发送窗口内的数据全都发送出去\n发送结束后，此时可用窗口为0，表示收到ack之前不可以继续发送数据\n若有5个字节的数据被ack确认，那么滑动窗口往右边移动5字节\n此时发送窗口末端的5字节再次成为可用窗口\n\n另外：tcp滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）\n\nSNDWND:表示窗口大小（由接收方指定\nSNDUNA：绝对指针，指向第一个已发送未ack的数据\nSNDNXT：绝对指针，指向未发送但可发送的第一个字节\n相对指针：指向未发送但是超出接收方处理窗口的第一个字节，由una + wnd求出\n\n接收方滑动窗口的内容变化过程\n\n\nRCVWND: 表示接受窗口的大小，会通告给发送方\nRCVNXT：指针，指向期望从发送方发来的下一个数据字节的序列号\n相对指针 ： RCVNXT + RCVWND\n\n\n接收窗口的大小和发送窗口的大小大约相等的，由滑动窗口并不是一成不变的，可以根据接收方的处理速度来随时修改\n\n流量控制TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。\n"},{"url":"/2025/03/09/class%E5%92%8Cinterface/","content":"class和interface\n算法&#x2F;&#x2F;时间复杂度&#x2F;&#x2F;&#x2F;狂刷\nvue的状态管理&#x2F;&#x2F;监听改变?\nvue的响应式原理&#x2F;&#x2F;&#x2F;vue2和3的响应式模版更新\nmvvm mvc模型\n构造函数和class的constructor\nwebsocket和http有啥区别\n项目优点:xhy:聊天室的构建&#x2F;&#x2F;性能问题(如何优化&#x2F;&#x2F;&#x2F;二分查找)(丢数据?固定1234数据)(消息刷屏?并发池)\n前后端交互确定收发顺序相同(独立id)\n无线滚动如何大量数据清理和请求\n计网!!状态码\n空指针报错\n枚举报错??\n画出0.5px的线\n弹窗为什么放在body层级下&#x2F;&#x2F;组件的适用性和灵活度\n怎么手搓轮播图\n做项目为什么使用框架\n虚拟dom元素\nts泛型\nts的问号\nvue的diff算法中浅ref可以用freeza进行优化,冻结与解冻,&#x3D;&#x3D;&#x3D;&#x3D;&gt;写一篇文章\nvue_createVnode(‘div’,_createVNode(‘p’,123)),template模版其实是函数&#x3D;&#x3D;&gt;函数构建出来一个{\n tag: ‘div’,\n elememt: {\n }\n}类似这样的虚拟节点,然后根据这样的虚拟节点vue去更新dom更新页面\n像ref,onmounted等在vue的宏里面,可以不用引入,但是需要想办法关闭eslint的报错vue提供一个新的不莫名其妙的 useTemplateRef可以获取dom元素这个需要引入\njsdoc可以提供注释的语法高亮&#x2F;**@是快捷键另外不需要的插件需要关掉,否则占用插件进程,会慢,可以用修复来解决小报错\nsass依赖可以挪到开发依赖里面\nvite偶尔会有更新失误,原因是vite是通过websocke去通知浏览器来获取更新内容\noxclint新东西,字节刚研究出来的可以吹,比eslint快100x\nvue或者react底层原理可以不用深究但是研究diff算法还有虚拟dom的原理可以深度理解跨端框架\n"},{"title":"css动画1","url":"/2024/03/04/css%E5%8A%A8%E7%94%BB1/","content":"Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。\ntransform: none|transform-functions;变换函数\n\n\n\n值\n描述\n\n\n\nnone\n定义不进行转换。\n\n\nmatrix(n,n,n,n,n,n)\n定义 2D 转换，使用六个值的矩阵。\n\n\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)\n定义 3D 转换，使用 16 个值的 4x4 矩阵。\n\n\ntranslate(x,y)\n定义 2D 转换。\n\n\ntranslate3d(x,y,z)\n定义 3D 转换。\n\n\ntranslateX(x)\n定义转换，只是用 X 轴的值。\n\n\ntranslateY(y)\n定义转换，只是用 Y 轴的值。\n\n\ntranslateZ(z)\n定义 3D 转换，只是用 Z 轴的值。\n\n\nscale(x[,y]?)\n定义 2D 缩放转换。\n\n\nscale3d(x,y,z)\n定义 3D 缩放转换。\n\n\nscaleX(x)\n通过设置 X 轴的值来定义缩放转换。\n\n\nscaleY(y)\n通过设置 Y 轴的值来定义缩放转换。\n\n\nscaleZ(z)\n通过设置 Z 轴的值来定义 3D 缩放转换。\n\n\nrotate(angle)\n定义 2D 旋转，在参数中规定角度。\n\n\nrotate3d(x,y,z,angle)\n定义 3D 旋转。\n\n\nrotateX(angle)\n定义沿着 X 轴的 3D 旋转。\n\n\nrotateY(angle)\n定义沿着 Y 轴的 3D 旋转。\n\n\nrotateZ(angle)\n定义沿着 Z 轴的 3D 旋转。\n\n\nskew(x-angle,y-angle)\n定义沿着 X 和 Y 轴的 2D 倾斜转换。\n\n\nskewX(angle)\n定义沿着 X 轴的 2D 倾斜转换。\n\n\nskewY(angle)\n定义沿着 Y 轴的 2D 倾斜转换。\n\n\nperspective(n)\n为 3D 转换元素定义透视视图。\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-function\ncss动画两种实践方式1. 过渡动画transition 是最简单的动画实现方式，主要用于从一个状态平滑过渡到另一个状态(可以是不同伪元素之间的切换,:hover或者:active,或者通过js操作状态变化)。&#x2F;&#x2F;eg.hover触发和settimeOut添加类\n基本语法：transition: property duration timing-function delay;\n\n主要属性说明：\n\ntransition-property: 指定要过渡的 CSS 属性的名称。例如，color、background-color 等。\ntransition-duration: 指定过渡效果持续的时间，以秒或毫秒为单位。\ntransition-timing-function: 指定过渡效果的速度曲线。它可以是 linear（线性）、ease（渐入渐出）、ease-in（渐入）、ease-out（渐出）、ease-in-out（先渐入后渐出）等等。\n\n\n\nease：默认值，缓慢加速，然后缓慢减速的过渡效果。\nlinear：匀速过渡效果。\nease-in：缓慢加速的过渡效果。\nease-out：缓慢减速的过渡效果。\nease-in-out：先缓慢加速，再缓慢减速的过渡效果。\ncubic-bezier(n,n,n,n)：自定义的贝塞尔曲线函数，通过四个值来定义曲线的控制点，分别对应 x1、y1、x2、y2。\n\n\n\ntransition-delay: 指定过渡效果开始之前的延迟时间，以秒或毫秒为单位。\n\n示例：\n.button &#123;    background-color: blue;    transition: background-color 0.3s ease;&#125;.button:hover &#123;    background-color: red;&#125;\n\n2. animation 关键帧动画animation 提供了更强大的动画控制能力，可以通过设置关键帧来定义动画的具体内容。\n基本语法：animation: name duration timing-function delay iteration-count direction fill-mode play-state;\n\n主要属性说明：\n\nanimation-name：动画的名称（对应 @keyframes）\nanimation-duration：动画持续时间\nanimation-timing-function：动画的速度曲线\n\n\n\n\n值\n描述\n\n\n\nlinear\n动画从头到尾的速度是相同的。\n\n\nease\n默认。动画以低速开始，然后加快，在结束前变慢。\n\n\nease-in\n动画以低速开始。\n\n\nease-out\n动画以低速结束。\n\n\nease-in-out\n动画以低速开始和结束。\n\n\nsteps(int,start|end)\n指定了时间函数中的间隔数量（步长）。有两个参数，第一个参数指定函数的间隔数，该参数是一个正整数（大于 0）。 第二个参数是可选的，表示动画是从时间段的开头连续还是末尾连续。含义分别如下：start：表示直接开始。end：默认值，表示戛然而止。\n\n\ncubic-bezier(n,n,n,n)\n在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。\n\n\n\nanimation-delay：动画延迟时间\nanimation-iteration-count：动画重复次数\nanimation-direction：动画方向\n\n\n\n\n值\n描述\n\n\n\nnormal\n默认值。动画按正常播放。\n\n\nreverse\n动画反向播放。\n\n\nalternate\n动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。\n\n\nalternate-reverse\n动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。\n\n\ninitial\n设置该属性为它的默认值。\n\n\ninherit\n从父元素继承该属性。\n\n\n\nanimation-fill-mode：动画结束时的状态\n\n\n\n\n值\n描述\n\n\n\nnone\n默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。\n\n\nforwards\n目标将保留由执行期间遇到的最后一个关键帧计算值。最后一个关键帧取决于animation-direction和animation-iteration-count的值：\n\n\nbackwards\n动画将在应用于目标时立即应用第一个关键帧中定义的值，并在animation-delay期间保留此值。第一个关键帧取决于animation-direction的值：\n\n\nboth\n动画遵循 forwards 和 backwards 的规则。也就是说，动画会在两个方向上扩展动画属性。\n\n\ninitial\n设置该属性为它的默认值。\n\n\ninherit\n从父元素继承该属性。\n\n\n\nanimation-play-state：动画的运行状态\n\n\n\n\n值\n描述\n\n\n\npaused\n指定暂停动画\n\n\nrunning\n指定正在运行的动画\n\n\n常用动画效果实例标签定义及使用说明使用@keyframes规则，你可以创建动画。\n创建动画是通过逐步改变从一个CSS样式设定到另一个。\n在动画过程中，您可以更改CSS样式的设定多次。\n指定的变化时发生时使用％，或关键字”from”和”to”，这是和0％到100％相同。\n0％是开头动画，100％是当动画完成。\n1. 淡入淡出效果.fade &#123;    opacity: 1;    transition: opacity 0.3s ease;&#125;.fade:hover &#123;    opacity: 0;&#125;\n\n2. 放大缩小效果.scale &#123;    transform: scale(1);    transition: transform 0.3s ease;&#125;.scale:hover &#123;    transform: scale(1.2);&#125;\n\n3. 旋转效果@keyframes rotate &#123;    from &#123;        transform: rotate(0deg);    &#125;    to &#123;        transform: rotate(360deg);    &#125;&#125;.rotate &#123;    animation: rotate 2s linear infinite;&#125;\n\n4. 弹跳效果@keyframes bounce &#123;    0%, 100% &#123;        transform: translateY(0);    &#125;    50% &#123;        transform: translateY(-20px);    &#125;&#125;.bounce &#123;    animation: bounce 1s ease infinite;&#125;"},{"title":"算法","url":"/2025/09/02/%E7%AE%97%E6%B3%95/","content":"算法哈希表用空间换时间\n\n两数之和： 最简单的哈希表用法，在第一次遍历是把以往的查询结果全部记录下来。\n字母异位词： 比起上一个键是nums的数值，值是索引，多了一些小思考，一个是map的键是字符串排序后的结果，值是数组的引用。\n最长连续序列： 先对nums去重排序，这题没有使用map，而是使用了另一个等长的数组，在对应位置维护这个位置数的最长连续数，通过递推公式补充完整。\n\n双指针双指针非常灵活，并没有什么固定的模版，需要见机行事\n\n移动0： 本题的要求将0移动到原数组的末尾，可以采用左右指针，左指针顺次找0，右指针找第一个非0元素，将二者交换位置即可。\n盛水最多的容器： 这个题最重要的是想明白，从左右两侧像中间挪动的过程中，先挪动短板肯定不吃亏，那么双指针的逻辑就自然而然了，左指针和右指针分别代表两块杯壁\n三数之和： 这题稍微有点难，乍一看好像看不出双指针。首先这样的题目O(n）的循环肯定无法解决，而三重循环又难以解决重复问题，且时间复杂度很高。 因此我们先循环遍历第一个元素，然后对于第二个元素和第三个元素就是一个两数之和问题，可以用双指针解决。 理解了大致思路之后重要的就是如何保证没有重复结果，我们可以在第一个元素的遍历时，通过如果当前元素等于上一个元素就跳过，来避免第一个元素重复，接着防止二三元素重复可以用while(nums[left + 1] &#x3D;&#x3D;&#x3D; nums[left]) left++这样的语句跳到与下一个元素不同的元素，再执行左指针右移右指针左移。\n接雨水： 有点难，主要体现在有小巧思，掌握了这个小巧思就可以实现o（n），O（1）。 我们可以维护一个左侧最大值leftMax,和一个右侧最大值rightMax,分别让他们是高度数组第一个元素和最后元素的值，这么一看这两个最大值似乎毫无意义，因为他们只是首位元素，未经过遍历，并非实际的最大值。 但是对于序号为1的元素leftMax是真实的左侧最大值，假如leftMax &lt; rightMax(未必最大),那么限制序号1的水量的就是leftMax，假如leftMax &gt; rightMax(未必最大)，那么对于序号为 n - 2的元素，rightMax是真实的右侧最大值，限制序号n - 2的水量的就是rightMax。 因此，双指针的写法就自然而然出现了，可以用left，right 分别指示左侧和右侧计算到哪里即可。\n\n滑动窗口其实到现在也不明白滑动窗口啥意思，回头再写吧\n\n无重复字符的最长子串： 这种子串，可以用这个滑动窗口，右侧光管进入，左侧光管出去，右侧不管不顾的进入，然后左侧就往外出知道无重复为止。 问题困难在取舍边界，我写的是left是包含的最后一个，right是要添加的最新一个。两个都包含在内。\n找到字符串中所有的字母异位词： 还是滑动窗口，思路和上面的一样，右侧管进入左侧光出去，左侧是包含的最后一个，右侧是包含的，当长度与p相等比较即可。\n\n普通数组\n缺失的第一个正数： 不知道困难在哪，上来一个sort排序然后依次从1对比就行，有了就比2，比1大就返回1，比1小就下一个和1比\n\n技巧\n只出现一次的数字： 纯数学技巧了，0与任何数求或（^)都是它本身，任何数和另一个数取或两次都会回归它本身。\n多数元素： 猎奇，[n&#x2F;2]一定是众数，纯数学脑筋急转弯\n\n\n"},{"title":"计算机网络/25/8","url":"/2025/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-25-8/","content":"计算机网络网络设备\n网卡(有线、无线)：无线网卡有电磁信号频率。设备带宽bps：每秒传输1000m\n路由器：具有wifi功能。\n光猫：调制解调器，将光信号调制成电信号（光纤的）。运营商（ISP）安装，一般也自带wifi功能，但是信号不是很好，所以需要买一个路由器\n交换机：多用于企业中，有很多插口，可以提供多个终端设备上网\n核心交换机：更贵的交换机，负责链接其他底下的交换机。\n\n理解OSI七层协议最早期的电脑的交互，只能依靠两个主机之间插上双绞线。后来为了满足多台主机交互，设计出了集线器。\n而为了区分连接了集线器上的电脑，产生了mac地址。\n\nmac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）\n\n集线器通过广播，比对消息上的源目的mac地址，进行收发消息。\n但是规模变大后，依靠广播传递，会引起广播风暴，造成网络拥塞。于是产生了ip地址。\n\n例：10.100.122.0&#x2F;24\n\n网络号：/24表示就是 255.255.255.0 子网掩码，子网掩码与ip地址进行与运算，结果就是网络号\n主机号：将子网掩码取反后和ip地址进行按位与。\n\n然后寻址的过程中,先匹配到网络号—-找到同一子网   然后再找到对应的主机。\n\n集线器不能满足需求之后，将集线器升级成为了交换机带有DHCP功能，所有插入到这个交换机上的电脑会被单独分发一个ip地址，用来划分广播域。\n广播域被划分后，只能在自己的交换机内广播，为了能够发给别的交换机，产生了路由器来管理这些交换机，从此通过ip地址来进行寻找主机，发现不是同一网络段时，通过路由器转发到对应的地址段的交换机，（通过记录或者广播。\narp协议：到达交换机之后，交换机会记录mac地址和ip地址对应的缓存表，更新时交换机发送arp广播数据包，每一个主机都会将自己的mac地址发送给交换机。\nipv4 不够用了，随着主机数变多，ip地址不够用了，解决方式：\n\nipv6地址：修改起来比较困难\n采用内网ip和公网ip：给路由器一个公网ip地址，而连接路由器的设备分配私网ip地址，不能直接上网，都要通过路由器（NAT网络地址转换，数据包携带有目标ip地址，源ip地址，还有自己的私网ip地址）。\n\n接着数据包经过路由跳转，路由计算选择最佳跳转路径到达目的主机。服务器路由器可以做一个端口映射，找某端口就直接找响应的服务器主机。\n七层模型应用层表示层会话层传输层传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机吗，但是只找到主机有用吗，是不是程序之间进行的沟通啊像QQ、浏览器和京东服务器，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，\n那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。\n传输层功能：建立端口到端口的通信(端对端通信)\n补充：端口范围0-65535，0-1023为系统占用端口\ntcp协议：\nTCP 是面向连接的、可靠的、基于字节流的传输层通信协议。\n\n面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；\n可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；\n字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃\n\n(TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。)\n当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex，双方都可以收发消息) 的通信。\n这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。\n\n\n\n以太网头\nip 头\ntcp头\n数据\n\n\n\n\n\n20字节\n理论上可以无限长，但是为了保证效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割，在传输层进行分片。1460\n\n\n\n\n\n以太网头\nip头\nudp头\n数据\n\n\n\n\n\n8个字节\n总长度不超过65,535字节，正好放进一个IP数据包。\n\n\ntcp报文　　　　\n 序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。控制位：\n\nACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。\nRST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。\nSYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。\nFIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。  为什么需要 TCP 协议？ TCP 工作在哪一层？\n\nUDP报文\n\n\n目标和源端口：告诉UDP协议应该将报文发到哪个进程\n包长度：保存UDP总长度\n校验和：防止受损\n\nTCP与UDP的区别\nUDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。\n\nTCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。\n\n\n常用的端口号：\n\n\n\n应用程序\nFTP\nTFTP\nTELNET\nSMTP\nDNS\nHTTP\nSSH\nMYSQL\n\n\n\n熟知端口\n21,20\n69\n23\n25\n53\n80\n22\n3306\n\n\n传输层协议\nTCP\nUDP\nTCP\nTCP\nUDP\nTCP\n\n\n\n\ntcp三次握手和四次挥手三次握手：\n\nTCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；\nTCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN&#x3D;1的报文段）不能携带数据，但需要消耗掉一个序号。\nTCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。\nTCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。\n当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。\n\n四次挥手：\n数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。服务端也可以主动关闭，一个流程。\n\n客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n为什么客户端最后还要等待2MSL？ View Code\n\n如果已经建立了连接，但是客户端突然出现故障了怎么办？　　　　TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 \n　　　　\n 为什么三次握手但是四次挥手\n\n2.3.5 应用层　　　　应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 \n　　　　应用层功能：规定应用程序的数据格式。\n　　　　例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。\n 　　　\n 　　　\n　　　　\n2.3.6 socket　　　　我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。\n　　　　能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP&#x2F;IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n　　　　\n　　　　socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读&#x2F;写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。\n网络层接收、添加ip地址，遵循ip协议。IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。\n　IP协议：\n\n规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示\n范围0.0.0.0-255.255.255.255 (4个点分十进制，也就是4个8位二进制数)\n一个ip地址通常写成四段十进制数，例：172.16.10.1\n\n　　ipv6，通过上面可以看出，ip紧缺，所以为了满足更多ip需要，出现了ipv6协议：6个冒号分割的16进制数表示，这个应该是将来的趋势，但是ipv4还是用的最多的，因为我们一般一个公司就一个对外的IP地址，我们所有的机器上网都走这一个IP出口。\nip地址分成两部分\n\n网络部分：标识子网\n主机部分：标识主机\n\n注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网。\n\n例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网\n\n子网掩码\n所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。\n 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。\n\n例：已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？\n两者与子网掩码分别进行AND运算，\n　　172.16.10.1：10101100.00010000.00001010.000000001\n　　255255.255.255.0:11111111.11111111.11111111.00000000\n　　AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0\n　　172.16.10.2：10101100.00010000.00001010.000000010\n　　255.255.255.0:11111111.11111111.11111111.00000000\n　　AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0\n　　结果都是172.16.10.0，因此它们在同一个子网络。\n\nip数据包\nip数据包也分为head和data部分，直接放入以太网包的data部分 \n\n\n\n以太网头\nip 头\nip数据\n\n\n\n由数据链路层添加\n长度为20到60字节\n最长为65,515字节\n\n\n 而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。\n ARP协议\nARP协议的划分：按照5层模型属于网络层，按照七层模型属于数据链路层。\narp协议由来：计算机通信基本靠基于mac的广播方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送。计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议。\narp协议功能：广播的方式发送数据包，接收到数据包的目标主机发送自己的mac地址，并收录缓存表。然后在数据包上标上目标主机mac地址，进行广播发送。\n\n 协议工作方式：每台主机ip都是已知的（我只知道我的局域网ip地址，要给一个非同一网络的我不知道ip地址的电脑发消息，怎么办：NET穿透）\n例如：主机172.16.10.10&#x2F;24访问172.16.10.11&#x2F;24\n　　一：首先通过ip地址和子网掩码区分出自己所处的子网\n\n\n\n场景\n数据包地址\n\n\n\n同一子网\n目标主机mac，目标主机ip\n\n\n不同子网\n网关mac，目标主机ip\n\n\n二：分析172.16.10.10&#x2F;24与172.16.10.11&#x2F;24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)\n\n\n\n\n源mac\n目标mac\n源ip\n目标ip\n数据部分\n\n\n\n发送端主机\n发送端mac\nFF:FF:FF:FF:FF:FF\n172.16.10.10&#x2F;24\n172.16.10.11&#x2F;24\n数据\n\n\n三：这个包会以广播的方式在发送端所处的子网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac\n\n数据链路层数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思\n数据链路层的功能：定义了电信号的分组方式\n\n物理层解决信号转换问题，基本都是数字信号，二进制数据控制的电路信号，电磁信号。\n"},{"title":"计算机网络2","url":"/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/","content":"通过域名获取ip地址(待补充…)协议栈协议栈的内部分成多个部分,上级会委托下级工作\n应用程序 调用 socket库 来委托协议栈工作  \n上半部分:TCP UDP下班部分:ip协议控制收发操作(包含icmp协议 和 arp 协议)\n\nicmp协议 告知网络包传送过程中错误和控制信息\nARP 根据 IP 查询\n\nTCPtcp报文的头部\n\n源端口号和目标端口号—知道发给哪个应用\n序号 —– 解决包的乱序\n确认号 —— 没收到就重新发送,解决丢包问题\n状态位—- ( 首部长度 后的保留位 )\nsyn 链接\nack 回复\nrst 重新连接\nfin 结束\n\n\n窗口大小—双方各自标识的能够的处理能力\n\n3次握手—– 建立链接建立连接的过程中, 双方的状态位的时序图如下\n\n一切开始于服务端主动监听某个端口   处于listen状态\n\n当客户端发起连接  发送 syn \n服务端收到 链接  返回了 syn  并且对这个syn ack\n客户端收到 syn 和 ack 之后 发送 对syn 的ack 的 ack\n服务端收到之后—–链接成功建立\n\n切割数据如果超过了 mss 的长度, 这时候 TCP 会把 http 数据拆解成一块块的数据 \n\nMTU 一个网络包的最大长度\nMSS 除去头部之后,一个网络包能容纳的TCP数据的最大长度\n\n\n生成报文建立连接之后, 进行分包之后, 每一个数据包(tcp段)的数据部分 存放了http头 + 数据\n\n**至此,http报文 在传输层的处理结束 实现了可靠传输  **\nIP实际上, tcp 模块 在执行链接,收发,断开 这些阶段的操作时,都需要委托 IP 模块去封装成网络包 来发送\n上文中的链接  syn ack 等等的收发 都已经通过ip协议 发送过\nIP报文头部格式如下:\n\n\n原地址IP 和 目标地址IP :客户端输出的 IP 地址和 通过 DNS 域名解析得到的服务器IP\n协议号:用协议号标记经过什么协议传输,本例子中http经过tcp传输,所以协议号06(十六进制) —- 表示tcp\n源地址IP选择哪一个网卡的地址,需要根据 路由表 来判断  \n\n将路由表的不同条目的目的地(Destination)和子网掩码进行 与运算 结果与目标地址(服务器的)进行比较,符合的,匹配成功的网课的ip地址作为ip包头的源地址\n如果前面的条目都无法匹配,则自动匹配默认网关(0.0.0.0)后续发包给路由器\n完整版\n网卡网络包只是内存中的二进制数字信息,无法直接发送给对方,因此需要将数字信息转换成电信号,电信号才可以在网线上传输\n负责这一过程的是网卡,控制网卡还要网卡驱动程序\n网卡驱动获取网络包之后,将其复制到网卡内的缓存区,并在 开头加上报头和起始帧分界符,在末尾加上用于检测错误的帧校验序列(FCS)\n\n\n起始帧分界符—– 表示包起始位置的标记\nfcs 检查包传输过程是否损坏\n至少含有接收方(路由器的mac地址),mac头部有什么? 待补充\n\n最后网卡将包转换成电信号,通过网线发出\n交换机交换机的设计是将网络包 原样转发到目的地 交换机工作在mac层(网络链路层) , 也称为 二层网络设备\n\n电信号到达网线接口 , 交换机的模块 进行接受,并将电信号转换为数字信号\n通过FCS校验错误,没问题就放到缓冲区,此步骤和计算机网卡相同,但是工作方式不同  计算机的网卡本身具有mac地址,可以核对包的接收方的mac地址来判断是不是发给自己的  交换机的端口不核对,直接接收所有的包并存放到缓冲区\n进入缓冲区后,查询接收方的mac地址是否已经在mac地址表有记录\n\n\nmac地址表的两个信息:\n\n设备的mac地址\n设备连接在交换机哪一个端口上\n\n\n曾经发送到某mac地址的设备,当时走的端口会被记录在这个mac记录表里面\n\n如果因为清理或者没发过,mac表内不含mac地址的信息,就会将包转发到除了源端口的所有端口,听起来不负责任,但是以太网本来就是这么设计的,将包发送到整个网络,只有接收者才接收\n并且广播地址也会发给所有端口\n路由器与交换机的区别\n因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；\n而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。\n\n\n但是工作原理类似,都是查表判断包转发的目标\n\n基本原理路由器的端口有mac地址和ip地址,转发时会接受以太网包,然后从 路由表 查询转发目标, 从乡音端口发送\n包接收操作和计算机相同:检查接收方的mac地址,查看是否是自己的包,是的话放进缓冲区\n查询路由表确定输出端口完成了包接收操作之后,路由器会去掉mac头部( mac头部的作用就是将包送达路由器),其中的接收方mac地址就是路由器端口的mac地址\n接下来路由器根据mac头部后方的ip头部起作用进行包的转发操作\n\n首先查询路由表判断转发目标\n每个条目的子网掩码和ip做与运算得到结果与目标地址进行匹配,匹配则转发,实在没有匹配则走默认路由\n\n\n路由器的发送操作根据路由表的网关列判断对方 的地址\n\n如果网关是ip地址—-此ip是转发地址, 未抵达终点,需要继续由路由器转发\n如果网关为空,则包里ip头部写的ip地址就是转发的目标地址,说明已经到达终点(终点路由器)\n\n从路由器转发的过程\n知道了对方的ip地址之后(从路由表网关列得知),需要通过arp协议根据ip地址查询mac地址,并根据查询结果作为接收方的mac地址,路由器有ARP缓存,先在ARP缓存中查询,找不到就发送ARP查询请求\n发送方的mac地址字段填写输出端口的mac地址,(因为原来的mac头部已经被丢弃了)\n以太类型字段填写0800 表示ip协议\n完成后转换成电信号通过端口(由网卡完成 发出去\n网络包经过交换机到达下一个路由器\n\n至此,数据包通过多个路由器,抵达了最后一个路由器,最后一个路由器,经过交换机,到达具体的接收方的网卡\n\n服务端与客户端经过上面步骤数据包抵达了服务器,开始拆解数据包\n\n\n首先拆mac头部,查看和自己的mac地址是否符合,符合将包收起来\n接着拆解ip头部,发现ip地址符合,根据ip头部里面的协议项,(06的那个十六进制数),得知自己的上层是tcp协议\n拆解tcp头部,获取序列包,(确定是自己需要的),是就返回一个ack,再查看里面的端口号,而接收方(这个服务器正在监听这个端口号,之前写过的, 一切始于这个服务端主动的监听某一个端口)\n服务器端口得到这个数据包之后,知道他应该被交给Http进程,发送过去之后,将返回的内容,(比如要访问的网页)封装在Http的响应报文里面,\n而相应报文再接着套上TCP,IP,MAC头部\n从网卡发出,经由交换机转发到路由器,调到客户端最近的路由器发给,内部的交换机,再转发给客户端,\n最后客户端拆解头部得到http相应报文,交给浏览器渲染\n最后客户端发起了四次挥手,至此双方连接断开\n\n"},{"title":"计算机网络3","url":"/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/","content":"Linux系统如何收发网络包网络模型为了各种设备能够通过网络相互通信,解决不同设备在网络互联中的兼容性问题,制定了 开放式系统互联通信参考模型 OSI网络模型\n共七层,应用层,表示层,会话层,传输层,网络层,数据链路层,以及物理层\n\n应用层: 给程序提供统一接口\n表示层: 数据转换成兼容另一个系统的格式\n会话层: 建立管理和终止表示层实体之间的通信会话\n传输层: 负责端到端的数据传输\n网络层: 负责数据的路由,转发,分片\n数据链路层: 负责数据的封帧和差错检测,以及MAC寻址\n物理层:负责在物理网络中传输数据帧\n\n但是它过于复杂,分层也是是概念和理论,其实没有具体实现方案\n实际上常见且实用的是四层模型,TCP&#x2F;IP模型\n\n应用层: 提供应用程序,如HTTP,DNS,FTP等  (http报文的响应头啊,方法啊啥的)\n传输层: 负责端到端的通信,TCP,UDP  (头部含端口号,负责对应的端口)\n网络层: 网络包的封装,分片,路由,转发等,例如 IP, ICMP等  (包含分片数据包,协议号,还有源ip地址和目标ip地址,实现这些内容交给了IP协议这样的东西)\n网络接口层: 负责网络包在屋里网络中的传输,例如 网络包的封帧, MAC寻址,差错检测,以及网卡传输网络帧等  (这部分)\n\nHTTP面试题\nhttp的基本概念\nget与post\nhttp特性\nhttp缓存技术\nhttps和http\n1.1&#x2F;2&#x2F;3的区别\n\n\n\nHTTP基本概念http超文本传输协议\n\n超文本: 超越了普通文本,是混合体\n传输: 双向协议,是专门用来在两点之间传输数据的约定和规范,允许中间有中转或接力,只要不打扰基本数据传输\n协议: 使用计算机能够理解的语言确立计算机间交流通信的规范,以及相关的各种控制和错误处理方式\n\n\n因此HTTP是计算机世界里专门进行[两点]之间[传输]文字图片音频等[超文本]数据的[约定和规范]\n\nhttp状态码\n\n\n1xx : 提示信息, 协议处理的中间状态,很少使用\n\n2xx : 服务器成功处理了客户端请求\n\n[ 200 ok ] 一切正常 (非head请求会带有body数据) 看不懂,待补充\n[ 204 no content] 响应头没有body数据\n[ 206 partial content] http分块下载或断点续传,表示相应返回的body并非全部\n\n\n3xx : 客户端请求的资源发生了变动,需要客户端用新的url重新发送请求获取, 即 重定向\n\n[ 301 moved permanently] 永久重定向,资源已经不存在了\n[ 302 found ] 临时重定向,资源存在,但是需要另一个url访问\n\n  都会在响应头使用Location字段,知名后续跳转,可以自动重定向到新的\n\n4xx : 表示客户端发送到报文有误,服务器无法处理,错误码\n\n[ 400 bad request ] 报文有错,\n[ 403 Forbidden ] 服务器禁止访问资源\n[ 404 not found ] 请求的资源在服务器上不存在未找到\n\n\n5xx : 报文正确,但是 服务器处理事内部发生了错误,是服务端的错误码\n\n500 通用\n[ 501 not implemente] 功能还不支持\n[ 502 bad gateway ] 服务器作为网关或者代理时返回的错误码,自身正常,后端服务器发生错误\n[ 503 service unavailable ] 服务器很忙暂时无法响应\n\n\n\nHTTP常见字段\nHost  制定服务器域名,可以发往 同一台 服务器的不同网站\ncontent-length  服务器返回数据时,表明本次回应的数据长度,浏览器可以以这个字段的长度找到 HTTP body 的边界 而httphead的便捷靠回车或换行——解决了”粘包” 待补充\nconnection  用于客户端要求服务器使用 http长连接 机制, 以便其他请求复用  只要忍一段没有明确提出断开连接,就保持TCP的链接状态\ncontent-type  服务器回应时告诉客户端,本次是什么格式;什么编码  而客户端请求的时候可以使用 Accept 字段声明自己可以接受那些数据格式\ncontent-encoding  数据的压缩方法,表示服务器端使用了什么压缩格式  对应客户端 accept-encoding\n\nGET 和 POST区别根据 RFC规范 get和post 有 语义上的区别\n\nGET : 从服务器获取指定资源, 参数写在URL中(query参数,在浏览器地址栏里面,浏览器也会对url有限制)\nPOST : 根据 请求负荷 对指定资源做出处理,(body参数) body可以是任意格式的数据\n\n都是安全和幂等的吗?\n安全 : 该请求方法不会 破坏 服务器上的资源\n幂等 : 执行多次相同的操作,结果都是 相同 的\n\n如果按照了RFC规范定义的语义:\n\nGET是安全且幂等的，  因此浏览器可以对GET请求的数据作缓存,这个缓存可以做到避免浏览器发请求,或者做到代理上   代理什么意思?? 待补充\nPOST 是不安全的，不冪等的，\n\n\nRFC规范并没有规定GET请求不能带body, 但是因为语义上不需要用到body,所以基本不用\n\nHTTP缓存技术有哪些实现方式?强制缓存浏览器判断缓存没有过期,就直接使用浏览器的本地缓存—– 由浏览器决定\n\n\n强缓存由http头部的两个字段实现,表示资源在客户端缓存的有效期\n\ncache-control : 相对时间 优先级更高, 设置更加精细\n第一次访问服务器资源师,服务器会在返回这个资源的同时,在响应头部加上这个字段,设置了过期时间的大小\n再次访问时, 浏览器会根据请求资源的时间和时间大小计算出是否过期,过期重新请求\n再次收到后就更新\n\n\nexpires : 绝对时间\n\n协商缓存某些请求的响应码是 304 , 这个是告诉浏览器 可以使用本地缓存的资源 , 这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存\n\n\n协商缓存基于两种头部来实现\n第一种 请求头部中的 If-Modified-Since 字段 和响应头部中的 Last-Modified 字段实现\n\nlast-modified : 标志着这个响应资源的最后修改时间, (服务端)\nfi-modified-since : 当资源过期了,发现响应头中有 (之前返回的时候带着的) 最后修改时间的声明 ,那么发请求的时候带上这个   最后修改时间 (放在这个 是否修改时间 if这个字段里面) 服务器发现有这个字段之后,与最后的修改时间进行对比,如果被改动过,就返回最新的,如果没修改,那么就响应 http 304 走缓存\n\n第二种 请求头中的 If-None-Match 和 响应头中的 ETag 字段\n\nif -none-match : 当资源过期时,浏览器发现响应头里有Etag,再次向服务器发起请求,会将这个值设置成etag的值,服务器收到请求后进行对比,如果资源没有变化就返回304,如果资源变化了就返回200\netag : 唯一标识响应资源\n\n后者是基于一个唯一标识实现,比起时间更为准确,因此etag的优先级更高\n因为它能够解决几个时间难以处理的问题:\n\n没有修改文件内容的情况下,时间也可能改变\n有些文件是秒级以内修改,但是最后修改时间现查不到\n有的服务器不能精确获取最后修改文件时间\n\n都需要配合cache-control 使用,未命中强制缓存时, (  即过期时间已经超过了 ) 这时候才会发起带有协商缓存字段的请求\nHTTP特性HTTP&#x2F;1.1 的优点\n简单 : 基本报文格式是 header +body 头部信息是 key-value 的简单文本形式,易于理解\n灵活和易于扩展 : 各类请求方法, URI&#x2F;URL, 状态码 , 头字段没有被固定死,允许自定 作用在应用层,下层可以随意变化\nHTTPS 就是在http和tcp之间增加了ssl&#x2F;tsl安全传输层\n而http&#x2F;1.1 http&#x2F;2.0 使用tcp协议, 3.0改用udp协议\n\n\n应用广泛 可以跨平台\n\n缺点"},{"title":"Ts整理","url":"/2024/09/18/vueAndTs/","content":"\n参考博客https://typescript.p6p.net/typescript-tutorial/tuple.html\n\n类型动态类型:没有使用限制，运算符可以接受各种类型的值。在语法上，JavaScript 属于动态类型语言。\n静态类型:TypeScript 的作用，就是为 JavaScript 引入这种静态类型特征。类型:number,string,any,unknown,never,boolean,bigint,symbol,object(包含对象数组函数).undefined,null\nTypeScript 对五种原始类型分别提供了大写和小写两种类型。\n\nBoolean 和 boolean\nString 和 string\nNumber 和 number\nBigInt 和 bigint\nSymbol 和 symbol\n\n其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。\n类型系统基础使用\n自动推断:、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是any。\n\n值类型:\n\nTypeScript 规定，单个值也是一种类型，称为“值类型”。\n let x: &quot;hello&quot;;x = &quot;hello&quot;; // 正确x = &quot;world&quot;; // 报错遇到`const`命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。\n\n联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。\n 联合类型A|B表示，任何一个类型只要属于A或B，就属于联合类型A|B。可以在某个函数内部进行类型缩小\n\n交叉类型:交叉类型A&amp;B表示，任何一个类型必须同时属于A和B，才属于交叉类型A&amp;B，即交叉类型同时满足A和B的特征。\n\ntype命令:type命令用来定义一个类型的别名。类型有块级作用域\n\ntypeof:在ts中可以推断类型,它的参数只能是标识符\n\n类型兼容:存在父子类型的概念\n\n\n数组类型数组TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。\n写法:\n\n在数组成员的类型后面，加上一对方括号。如果数组成员的类型比较复杂，可以写在圆括号里面。\n let arr: number[] = [1, 2, 3];let arr: (number | string)[];\n\n使用 TypeScript 内置的 Array 接口。这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。\n let arr: Array&lt;number | string&gt;;\n\n只读数组JavaScript 规定，const命令声明的数组变量是可以改变成员的。(只有值改变地址没有改)TypeScript 允许声明只读数组，方法是在数组类型前面加上readonly关键字。TypeScript 将readonly number[]与number[]视为两种不一样的类型，后者是前者的子类型。\n这是因为只读数组没有pop()、push()之类会改变原数组的方法，所以number[]的方法数量要多于readonly number[]，这意味着number[]其实是readonly number[]的子类型。\n注意，readonly关键字不能与数组的泛型写法一起使用。\n实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。\nconst a1: ReadonlyArray&lt;number&gt; = [0, 1];const a2: Readonly&lt;number[]&gt; = [0, 1];\n\n元组它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。\n元组必须明确声明每个成员的类型。\nconst s: [string, string, boolean] = [&quot;a&quot;, &quot;b&quot;, true];\n\n上面示例中，元组s的前两个成员的类型是string，最后一个成员的类型是boolean。\n元组类型的写法，与上一章的数组有一个重大差异。数组的成员类型写在方括号外面（number[]），元组的成员类型是写在方括号里面（[number]）。\nTypeScript 的区分方法是，成员类型写在方括号里面的就是元组，写在外面的就是数组。\n元组成员的类型可以添加问号后缀（?），表示该成员是可选的。\nlet a: [number, number?] = [1];\n\n使用扩展运算符（...），可以表示不限成员数量的元组。\ntype NamedNums = [string, ...number[]];const a: NamedNums = [&quot;A&quot;, 1, 2];const b: NamedNums = [&quot;B&quot;, 1, 2, 3];\n\n元组也可以是只读的，不允许修改，有两种写法。\n// 写法一type t = readonly [number, string];// 写法二type t = Readonly&lt;[number, string]&gt;;\n\n上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型Readonly&lt;T&gt;。\nsymbol类型待补充…\n函数类型对象interface&#x2F;&#x2F;施工中\n类泛型","categories":["vue"]},{"title":"vue2->3的改变11","url":"/2025/09/16/vue3/","content":"proxy VS definePropertydefineProperty通过defineProperty 两个属性，get及set\n\nget\n\n属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值\n\nset\n\n属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined\nfunction update() &#123;    app.innerText = obj.foo&#125;function defineReactive(obj, key, val) &#123;    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                val = newVal                update()            &#125;        &#125;    &#125;)&#125;\n\n在对象存在多个key情况下，需要进行遍历\nfunction observe(obj) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        return    &#125;    Object.keys(obj).forEach(key =&gt; &#123;        defineReactive(obj, key, obj[key])    &#125;)&#125;\n\n如果存在嵌套对象的情况，还需要在defineReactive中进行递归\nfunction defineReactive(obj, key, val) &#123;    observe(val)    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                val = newVal                update()            &#125;        &#125;    &#125;)&#125;\n\n存在的问题\n进行删除与添加属性操作，无法劫持到\n当我们对一个数组进行监听的时候，监听不到APi方法\n如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题\n\n所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写\nproxyProxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了\n下面通过代码进行展示：\n定义一个响应式方法reactive\nfunction reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;,        set(target, key, value, receiver) &#123;            const res = Reflect.set(target, key, value, receiver)            console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)            return res        &#125;,        deleteProperty(target, key) &#123;            const res = Reflect.deleteProperty(target, key)            console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;    &#125;)    return observed&#125;\n\n这个方法应对添加修改删除都可以，但是不能处理嵌套\n如果要解决，需要在get之上再进行一层代理\nfunction reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return isObject(res) ? reactive(res) : res        &#125;,    return observed&#125;\n\n\nProxy可以直接监听数组的变化（push、shift、splice）\nProxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的\n正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）\n\nES6的proxy详解Proxy 用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）\n用法Proxy为 构造函数，用来生成 Proxy实例\nvar proxy = new Proxy(target, handler)\n\ntarget表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））\nhandler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为\nReflect若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API\n基本特点：\n\n只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在\n修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false）\n让Object操作都变成函数行为\n\nhandler解析\nget(target,propKey,receiver)：拦截对象属性的读取\nset(target,propKey,value,receiver)：拦截对象属性的设置\nhas(target,propKey)：拦截propKey in proxy的操作，返回一个布尔值\ndeleteProperty(target,propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值\nownKeys(target)：拦截Object.keys(proxy)、for...in等循环，返回一个数组\ngetOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象\ndefineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc），返回一个布尔值\npreventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值\ngetPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象\nisExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值\nsetPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值\napply(target, object, args)：拦截 Proxy 实例作为函数调用的操作\nconstruct(target, args)：拦截 Proxy 实例作为构造函数调用的操作\n\n例子var person = &#123;  name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123;  get: function(target, propKey) &#123;    return Reflect.get(target,propKey)  &#125;&#125;);proxy.name // &quot;张三&quot;\n\n\n\n组合式 VS 选项式通常使用Vue2开发的项目，普遍会存在以下问题：\n\n代码的可读性随着组件变大而变差\n每一种代码复用的方式，都存在缺点\nTypeScript支持有限\n\n以上通过使用Composition Api都能迎刃而解\n小结\n在逻辑组织和逻辑复用方面，Composition API是优于Options API\n因为Composition API几乎是函数，会有更好的类型推断。\nComposition API对 tree-shaking 友好，代码也更容易压缩\nComposition API中见不到this的使用，减少了this指向不明的情况\n如果是小型组件，可以继续使用Options API，也是十分友好的\n\nTreeshaking就是在保持代码运行结果不变的前提下，去除无用的代码.\n在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到\nimport Vue from &#x27;vue&#x27; Vue.nextTick(() =&gt; &#123;&#125;)\n\n而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中\nimport &#123; nextTick, observable &#125; from &#x27;vue&#x27; nextTick(() =&gt; &#123;&#125;)\n\n如何使用Tree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量\nTree shaking无非就是做了两件事：\n\n编译阶段利用ES6 Module判断哪些模块已经加载\n判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n详解ES6模块module模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。\n如果没有模块化，我们代码会怎样？\n\n变量和方法不容易维护，容易污染全局作用域\n加载资源的方式通过script标签从上到下。\n依赖的环境主观逻辑偏重，代码较多就会比较复杂。\n大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃\n\ncommenjs// a.jsmodule.exports=&#123; foo , bar&#125;// b.jsconst &#123; foo,bar &#125; = require(&#x27;./a.js&#x27;)\n\n// CommonJS模块let &#123; stat, exists, readfile &#125; = require(&#x27;fs&#x27;);// 等同于let _fs = require(&#x27;fs&#x27;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;\n\n其有如下特点：\n\n所有代码都运行在模块作用域，不会污染全局作用域\n模块是同步加载的，即只有加载完成，才能执行后面的操作\n模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存\nrequire返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值\n\nES6的moduleES6 在语言标准的层面上，实现了Module。CommonJS 和AMD 模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。\nES6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量\n// ES6模块import &#123; stat, exists, readFile &#125; from &#x27;fs&#x27;;\n\n上述代码，只加载3个方法，其他方法不加载，即 ES6 可以在编译时就完成模块加载\n由于编译加载，使得静态分析成为可能。包括现在流行的typeScript也是依靠静态分析实现功能\n","categories":["vue"]},{"title":"同源策略","url":"/2025/09/16/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/","content":"跨域本质是浏览器基于同源策略的一种安全手段\n同源策略（Same-Origin Policy）是浏览器的一种安全策略，用于限制一个网页中的文档或脚本只能与来自相同源（相同的协议、域名和端口号）的资源进行交互。这个策略的存在是为了防止恶意网站通过脚本等手段获取用户的敏感信息，保护用户的隐私和安全。\n同源策略限制的操作\nCookie、localStorage、indexDB等存储内容\nDOM操作：一个网页只能操作属于自己的窗口中的 DOM，不能操作其他窗口的 DOM。这意味着跨域的网页无法通过常规的 DOM 方法获取或修改其他网页的内容。\nAJax请求\n跨窗口通信：通过 postMessage 进行的跨窗口通信也受到同源策略的限制，消息只能被发送到同一域中的窗口。\n\n\nwindow.postMessage() 方法安全地实现了跨源通信，可以在不同的 Window 对象之间进行通信；例如，页面与其嵌入的 iframe 之间。\n\n防止CSRF（跨站请求伪造），防止隐私泄露\n解决跨域的方法\nCORS：后端设置响应头，access-control-allow-origin允许指定源访问。\nJSONP：只支持GET，已经过时了\nProxy\nPostMessage\n\nProxy允许客户端通过网络代理与服务器进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击\n如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象\n通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域\n在vue.config.js文件，新增以下代码\namodule.exports = &#123;    devServer: &#123;        host: &#x27;127.0.0.1&#x27;,        port: 8084,        open: true,// vue项目启动时自动打开浏览器        proxy: &#123;            &#x27;/api&#x27;: &#123; // &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的                target: &quot;http://xxx.xxx.xx.xx:8080&quot;, //目标地址，一般是指后台服务器地址                changeOrigin: true, //是否跨域                pathRewrite: &#123; // pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替                    &#x27;^/api&#x27;: &quot;&quot;                 &#125;            &#125;        &#125;    &#125;&#125;\n\n通过axios发送请求中，配置请求的根路径\naxios.defaults.baseURL = &#x27;/api&#x27;\n\n","categories":["vue"],"tags":["js","vue","浏览器"]},{"url":"/2025/09/25/%E9%92%88%E5%AF%B9%E6%80%A7%E4%BD%9B%E8%84%9A/","content":"\n \n针对性佛脚\n \n\n同源策略是什么？   是浏览器限制不同源之间的交互的安全策略。规定了只有协议，域名，端口三者都相同时，网页脚本才可以访问另一个网页内容。\n同源策略的使用场景？ 防止CSRF（跨站请求伪造），防止隐私泄露\n解决跨域的方法？\nCORS：后端设置响应头，access-control-allow-origin允许指定源访问。\nJSONP：好像是只支持GET已经过时了\n配置反向代理\n\n\n\n\n\n \n\n \n\\\n\n \n\n \n 同源策略是什么  \\2. 同源策略使用场景  \\3. jsonp 及其不足  \\4. CDN 一般放什么数据  \\5. 同源策略在什么场景下有限制  \\6. 页面嵌入 iframe 有什么限制  \\7. MVVM  \\8. MVVM 和 MVP 区别  \\9. 还有什么模型  \\10. HTML 常用标签  \\11. src 和 href 的区别  \\12. 常用布局方式  \\13. 网页中右下角固定  \\14. flex 一行五个卡片 最后一个不占用空间  \\15. js 数据类型  \\16. vue 双向绑定原理？对于数组呢？  \\17. 先执行父组件的生命周期还是 mixin 的生命周期  \\18. mixin 定义相同变量以哪个为主\n\n\n\n\n \nPromise.all\\1. 是什么\\2. 入参顺序与出参顺序为什么相同  \\5. Vue\\1. Vue2 与 Vue3 的区别\\2. 不同版本所使用的状态管理库的区别\\3. 为什么不学 React（他觉得 Vue 很简单）  \\6. Node 会吗，不会  \\7. 循环\\1. 有哪些循环，区别是什么\\2. 哪些可以 break，为什么可以，为什么不可以  \\8. 什么时候能来，能实习多久\n\n \n作者：daisy9542  链接：https://www.nowcoder.com/feed/main/detail/b13a70f2970f4b09b1670a8ca5d16f6f?sourceSSR=search  来源：牛客网\n\n \nCSS 垂直居中有哪些方法？追问：如果有两个 div，一个设置了 [display: block](https://zhida.zhihu.com/search?content_id=263136352&amp;content_type=Article&amp;match_order=1&amp;q=display%3A+block&amp;zhida_source=entity)，另一个怎么让它占满整个容器？\n\n \n\\2. px、rem、vw 有什么区别？\n\n \n\\3. 深拷贝和浅拷贝有什么区别？\n\n \n\\4. 怎么把一个一维数组转换成树形结构？\n\n \n\\5. 怎么取消一个定时器？\n\n \n\\6. git pull 和 [git fetch](https://zhida.zhihu.com/search?content_id=263136352&amp;content_type=Article&amp;match_order=1&amp;q=git+fetch&amp;zhida_source=entity) 有什么区别？\n\n \n\\7. 你同事在一个他自己的分支上写好了一个通用方法，你怎么用 git 把这个方法拿到你的分支上用？\n\n \n自我介绍（简要描述项目经历，重点是前端框架的选择）\n\n \n讲一下你对MVVM和MVC模式的理解，以及两者的区别\n\n \nReact的生命周期有哪些？请你举例说明\n\n \n你在前端性能优化方面有哪些经验？如何减少页面加载时间？\n\n \n什么是事件委托？可以举个例子说明吗？\n\n \n手写一个简单的防抖函数，如何避免多个请求发出？\n\n \n你如何理解异步编程？Promise和async&#x2F;await的区别是什么？\n\n \n作者：张不惑_  链接：https://www.nowcoder.com/feed/main/detail/49b9f253e193472ca89fc05ca59dc5a5?sourceSSR=enterprise  来源：牛客网\n\n \nvue2和vue3区别\n\n \n2.了解跨端吗，RN和taro，说一下他们底层原理（怎么实现跨端的）\n\n \n3.react和vue区别\n\n \n4.讲解一下react中常用hook\n\n \n5.为什么react要用hook而不用之前那种类的方式\n\n \n6.讲解一下304状态码\n\n \n7.强缓存和协商缓存\n\n \n8.cache control有哪些常见字段\n\n \n9.跨域有哪些常见字段（access control allow-*一系列）\n\n \n10.跨域怎么携带cookie（with Credentials），还有其他方式嘛\n\n \n11.有哪些常见的跨域方式\n\n \n12.怎么减少包大小，有哪些常见做法（分包和把图片部署到网络上CDN加速）\n\n \n13.了解webpack嘛，还知道其他构建工具吗，讲解一下他们的区别\n\n \n\n \n作者：许愿赢在转折点  链接：https://www.nowcoder.com/discuss/800076643397021696?sourceSSR=enterprise  来源：牛客网\n\n \n\n \n接触前端开发有多长时间？为什么在三月份从上一段实习离开？\n\n \n英语六级分数是多少？平时看英文文档还是中文文档？\n\n \n请介绍一下 Promise，它是什么？Promise 有几种状态？Promise.then() 是做什么用的？\n\n \n（代码场景题）给定一个状态为 fulfilled 的 Promise P1，当 .then() 的回调函数分别正常返回、抛出错误、返回 null、返回一个新的 Promise P3 时，新的 Promise P2 的状态和值分别是什么？\n\n \n（代码场景题）给定一个状态为 rejected 的 Promise P1，当 .then() 的回调函数分别正常返回、抛出错误、返回 null、返回一个新的 Promise 时，新的 Promise P2 的状态和值&#x2F;原因分别是什么？\n\n \n用过 React 18 吗？用过哪些 React Hooks？\n\n \n（场景题）对于一个翻页器组件，有哪些属性可以用 useMemo 来进行计算缓存？\n\n \n对 Redux 的使用达到了什么程度？用过 Redux Toolkit 吗？\n\n \n看过 Redux 的源码吗？底层是如何实现的？\n\n \nRedux 中 Reducer 的入参和出参分别是什么？\n\n \n编写 Reducer 时需要注意什么？可以在 Reducer 中执行有副作用的操作（如弹窗）吗？\n\n \nRedux 是如何通过一个根 Reducer (rootReducer) 来合并管理多个状态切片 (slice) 的？（考察 combineReducers，没答出来\n\n \nRedux Middleware 是用来做什么的？什么情况下需要用到中间件？\n\n \n（TypeScript 问题）如何提取一个函数类型的返回类型？了解哪些 TypeScript 的工具类型函数？\n\n \n在 any 和 unknown 之间，会如何选择来为一个变量声明类型？\n\n \n\n \n作者：等 offer 时刷了会儿抖音  链接：https://www.nowcoder.com/discuss/799035047452942336?sourceSSR=enterprise  来源：牛客网\n\n \n\n \n1.cesium绘制动效效果，飞线，图形类型  2.状态管理pinia，路由vue-router  3.v-if和v-show的区别  4.元素在视窗范围内不可见的方法  5.visibility和opacity两者有何区别  6.display：none会引起页面重绘还是重排  7.你在开发一个页面时候，有哪些方法可以减少重排和重绘？（减少DOM操作）  8.前端路由有哪几种方式  9.导航首位如何实现  10.Webpack 和Vite的区别，为什么Vite快？  11.Vite通过什么编译  12.Webpack有使用过吗  13.实现图片懒加载方式？如何判断滚动到这个图片资源？  14.有了解过intersectionObserve这个API吗  15.http状态码301、302  16.前后端交互中，数据请求部分如何实现？是用了第三方库实现的吗？具体用什么来发送请求  17.项目中对于视频可视化，逐帧转你是通过什么实现的？  18.视频处理工具FFmpeg有了解过吗？  19.视频帧有哪几种？视频上传过程？  20.Promise中有哪些方法？  21.localstorage  22.如何实现子元素水平垂直居中？  23.Grid布局中1fr表示什么  24.rem，em有什么区别？宽度设置50vw表示什么？  25.页面加载优化方式有哪些？  26.服务端渲染相比普通渲染的优势？  27.假如需要你新学习一个技术栈和框架的使用，你会哪几个方面规划你的学习路径，比如说你的学习时间很短只有一周时间  28.小程序了解过吗？  29.AI开发工具，如何帮助学习？\n\n \n作者：面的都会  链接：https://www.nowcoder.com/feed/main/detail/6398116ff5f44486802577d125dbdbc7?sourceSSR=enterprise  来源：牛客网\n\n \n\n \n\\1. 项目拷打  \\2. css 常见的定位方式  \\3. 如何实现水平垂直居中  \\4. js 闭包应用场景  \\5. js 事件循环  \\6. 讲一下 promise  \\7. react key 的作用，什么时候用 key 比较好  \\8. react 虚拟 dom 的作用  \\9. react 生命周期  \\10. 常见的打包工具  \\11. 前端如何应对高并发请求  \\12. 线上故障怎么排查与处理，具体流程是什么  \\13. 前端如何与后端和测试协作，排期冲突怎么办\n\n \n作者：山长水远_  链接：https://www.nowcoder.com/feed/main/detail/32eb646ab6944f0c8730afe93766e905?sourceSSR=enterprise  来源：牛客网\n\n\n1.js数据类型2.flex布局有哪些属性3.es6相关的方法4.防抖节流的区别5.同时调用三个接口怎么处理 promise.all6.深拷贝浅拷贝的区别7.常用的深拷贝的方法8.以前实习的时候的工作内容9.项目是自己独立做的吗\n作者：在迎接offer的小山竹很想退休链接：https://www.nowcoder.com/feed/main/detail/6423c482e5cc433a9701cb9683e0d753?sourceSSR=search来源：牛客网\n"},{"title":"JS：闭包、作用域链、原型链","url":"/2025/09/17/JS%EF%BC%9A%E9%97%AD%E5%8C%85%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"闭包一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包（closure）\n也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域\nfunction init() &#123;    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() &#123; // displayName() 是内部函数，一个闭包        alert(name); // 使用了父函数中声明的变量    &#125;    displayName();&#125;init();\n\n注意事项在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响\n作用域链作用域作用域，即变量和函数生效的区域或集合\n换句话说，作用域决定了代码区块中变量和其他资源的可见性\n全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问\n// 全局变量var greeting = &#x27;Hello World!&#x27;;function greet() &#123;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();\n\n函数作用域如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问\nfunction greet() &#123;  var greeting = &#x27;Hello World!&#x27;;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量\n&#123;  // 块级作用域中的变量  let greeting = &#x27;Hello World!&#x27;;  var lang = &#x27;English&#x27;;  console.log(greeting); // Prints &#x27;Hello World!&#x27;&#125;// 变量 &#x27;English&#x27;console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\nJS采用静态作用域词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域\nvar a = 2;function foo()&#123;    console.log(a)&#125;function bar()&#123;    var a = 3;    foo();//是2不是3&#125;bar()\n\n作用域链当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域\n如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错\nvar sex = &#x27;男&#x27;;function person() &#123;    var name = &#x27;张三&#x27;;    function student() &#123;        var age = 18;        console.log(name); // 张三        console.log(sex); // 男     &#125;    student();    console.log(age); // Uncaught ReferenceError: age is not defined&#125;person();\n\n原型、原型链JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象\n当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。\n原型链的构成\n任意函数都有自己的原型对象（prototype），任意对象都有自己的隐式原型（proto)\n\n任意对象的隐式原型指向其构造函数的原型对象\n\n原型对象的constructor属性指向函数本身\n\n\n\n注意\nObject.prototype原型对象的—proto—指向null\nFunction.prototype的—proto—指向本身，（Function 看做由Function构造\n\n相关操作1. instanceof：\ninstanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置\ninstanceof操作符左边是一个对象，右边是一个构造函数，在左边对象的原型链上查找，知道找到右边构造函数的prototype属性就返回true，或者查找到顶层null（也就是Object.prototype.__proto__），就返回false。\n\ninstanceof与typeof的区别：\ntypeof 操作符返回一个字符串，表示未经计算的操作数的类型\ntypeof与instanceof都是判断数据类型的方法，区别如下：\n\ntypeof会返回一个变量的基本类型，instanceof返回的是一个布尔值\n\ninstanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型\n\n而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断\n  如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串\n\n\n\n2. object.create:\nObject.create()方法，会创建一个新对象，第一个参数接收一个对象，将会作为新创建对象的隐式原型，第二个可选参数是属性描述符\nfunction createObj(proto) &#123;    function F() &#123;&#125;    F.prototype = proto    return new F()&#125;\n\n3. new操作符：\n当我们使用new时，做了些什么？\n\n创建一个全新对象，并将其__proto__属性指向构造函数的prototype属性。\n将构造函数调用的this指向这个新对象，并执行构造函数。\n如果构造函数返回对象类型Object(包含Functoin, Array, Date, RegExg, Error等)，则正常返回，否则返回这个新的对象。\n\n依然来模拟实现一下：\nfunction newOperator(func, ...args) &#123;    if (typeof func !== &#x27;function&#x27;) &#123;        console.error(&#x27;第一个参数必须为函数，您传入的参数为&#x27;, func)        return    &#125;    // 创建一个全新对象，并将其`__proto__`属性指向构造函数的`prototype`属性    let newObj = Object.create(func.prototype)    // 将构造函数调用的this指向这个新对象，并执行构造函数    let result = func.apply(newObj, args)    // 如果构造函数返回对象类型Object，则正常返回，否则返回这个新的对象    return (result instanceof Object) ? result : newObj&#125;\n","categories":["js"],"tags":["js"]},{"title":"JS：存储、泄露、垃圾回收","url":"/2025/09/18/JS%EF%BC%9A%E5%AD%98%E5%82%A8%E3%80%81%E6%B3%84%E9%9C%B2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","content":"存储javaScript本地缓存的方法我们主要讲述以下四种：\n\ncookie\nsessionStorage\nlocalStorage\nindexedDB\n\ncookieCookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题\n作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成\n但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站\n&#x2F;&#x2F;以下仅做了解\n关于cookie常用的属性如下：\n\nExpires 用于设置 Cookie 的过期时间\n\nExpires=Wed, 21 Oct 2015 07:28:00 GMT\n\n\nMax-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高）\n\nMax-Age=604800\n\n\nDomain指定了 Cookie 可以送达的主机名\nPath指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部\n\nPath=/docs   # /docs/Web/ 下的资源会带 Cookie 首部\n\n\n标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端\n\n通过上述，我们可以看到cookie又开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存\n关于cookie的使用如下：\ndocument.cookie = &#x27;名字=值&#x27;;\n\n关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie\nSet-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置document.cookie =name=bb; domain=aa.net; path=/  # 客户端设置\n\n最后cookie的删除，最常用的方法就是给cookie设置一个过期的事件，这样cookie过期后会被浏览器删除\nlocalstorageHTML5新方法，IE8及以上浏览器都兼容\n\n生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的\n存储的信息在同一域中是共享的\n当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。\n大小：5M（跟浏览器厂商有关系）\nlocalStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n受同源策略的限制\n\n下面再看看关于localStorage的使用\n设置\nlocalStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;);\n\n获取\nlocalStorage.getItem(&#x27;username&#x27;)\n\n获取键名\nlocalStorage.key(0) //获取第一个键名\n\n删除\nlocalStorage.removeItem(&#x27;username&#x27;)\n\n一次性清除所有存储\nlocalStorage.clear()\n\nlocalStorage 也不是完美的，它有两个缺点：\n\n无法像Cookie一样设置过期时间\n只能存入字符串，无法直接存对象\n\nlocalStorage.setItem(&#x27;key&#x27;, &#123;name: &#x27;value&#x27;&#125;);console.log(localStorage.getItem(&#x27;key&#x27;)); // &#x27;[object, Object]&#x27;\n\nsessionStoragesessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据\n扩展的前端存储方式indexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用索引来实现对该数据的高性能搜索\n虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案\n#优点：\n储存量理论上没有上限\n所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时\n原生支持储存JS的对象\n是个正经的数据库，意味着数据库能干的事它都能干\n\n#缺点：\n操作非常繁琐\n本身有一定门槛\n\n关于indexedDB的使用基本使用步骤如下：\n\n打开数据库并且开始一个事务\n创建一个 object store\n构建一个请求来执行一些数据库操作，像增加或提取数据等。\n通过监听正确类型的 DOM 事件以等待操作完成。\n在操作结果上进行一些操作（可以在 request对象中找到）\n\n关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度\n内存泄露的情况内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存\n并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费\n程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存\n对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃\n垃圾回收机制Javascript 具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存\n原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存\n通常情况下有两种实现方式：\n\n标记清除\n引用计数\n\n标记清除JavaScript最常用的垃圾收回机制\n当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“\n垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉\n在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了\n随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存\n举个例子：\nvar m = 0,n = 19 // 把 m,n,add() 标记为进入环境。add(m, n) // 把 a, b, c标记为进入环境。console.log(n) // a,b,c标记为离开环境，等待垃圾回收。function add(a, b) &#123;  a++  var c = a + b  return c&#125;\n\n引用计数语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放\n如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏\nconst arr = [1, 2, 3, 4];console.log(&#x27;hello world&#x27;);\n\n上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存\n如果需要这块内存被垃圾回收机制释放，只需要设置如下：\narr = null\n\n通过设置arr为null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收\n常见情况意外的全局变量\nfunction foo(arg) &#123;    bar = &quot;this is a hidden global variable&quot;;&#125;\n\n另一种意外的全局变量可能由 this 创建：\nfunction foo() &#123;    this.variable = &quot;potential accidental global&quot;;&#125;// foo 调用自己，this 指向了全局对象（window）foo();\n\n上述使用严格模式，可以避免意外的全局变量\n定时器也常会造成内存泄露\nvar someResource = getData();setInterval(function() &#123;    var node = document.getElementById(&#x27;Node&#x27;);    if(node) &#123;        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    &#125;&#125;, 1000);\n\n如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放\n包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放\nfunction bindEvent() &#123;  var obj = document.createElement(&#x27;XXX&#x27;);  var unused = function () &#123;    console.log(obj, &#x27;闭包内引用obj obj不会被释放&#x27;);  &#125;;  obj = null; // 解决方法&#125;\n\n没有清理对DOM元素的引用同样造成内存泄露\nconst refA = document.getElementById(&#x27;refA&#x27;);document.body.removeChild(refA); // dom删除了console.log(refA, &#x27;refA&#x27;); // 但是还存在引用能console出整个div 没有被回收refA = null;console.log(refA, &#x27;refA&#x27;); // 解除引用\n\n包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听\n","categories":["js"]},{"title":"JS：异步、promise","url":"/2025/09/26/JS%EF%BC%9A%E5%BC%82%E6%AD%A5/","content":"Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大。\npromise解决异步操作的优点：\n\n链式操作减低了编码难度\n代码可读性明显增强\n\n下面我们正式来认识promise：\n状态promise对象仅有三种状态\n\npending（进行中）\nfulfilled（已成功）\nrejected（已失败）\n\n特点\n对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态\n一旦状态改变（从pending变为fulfilled和从pending变为rejected），就不会再变，任何时候都可以得到这个结果\n\n用法Promise对象是一个构造函数，用来生成Promise实例\nconst promise = new Promise(function(resolve, reject) &#123;&#125;);\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”\nreject函数的作用是，将Promise对象的状态从“未完成”变为“失败”\n\n实例方法Promise构建出来的实例存在以下方法：\n\nthen()\ncatch()\nfinally()\n\n#then()then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数\nthen方法返回的是一个新的Promise实例，也就是promise能链式书写的原因\ngetJSON(&quot;/posts.json&quot;).then(function(json) &#123;  return json.post;&#125;).then(function(post) &#123;  // ...&#125;);\n\n#catchcatch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数\ngetJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123;  // ...&#125;).catch(function(error) &#123;  // 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#x27;发生错误！&#x27;, error);&#125;);\n\nPromise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\ngetJSON(&#x27;/post/1.json&#x27;).then(function(post) &#123;  return getJSON(post.commentURL);&#125;).then(function(comments) &#123;  // some code&#125;).catch(function(error) &#123;  // 处理前面三个Promise产生的错误&#125;);\n\n一般来说，使用catch方法代替then()第二个参数\n#finally()finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作\npromise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;);\n\n构造函数方法Promise构造函数存在以下方法：\n\nall()\nrace()\nallSettled()\nresolve()\nreject()\ntry()\n\nall()Promise.all()方法用于将多个 Promise实例，包装成一个新的 Promise实例\nconst p = Promise.all([p1, p2, p3]);\n\n接受一个数组（迭代对象）作为参数，数组成员都应为Promise实例\n实例p的状态由p1、p2、p3决定，分为两种：\n\n只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数\n只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数\n\n注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法\nconst p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;hello&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123;  throw new Error(&#x27;报错了&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了]\n\n如果p2没有自己的catch方法，就会调用Promise.all()的catch方法\nconst p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;hello&#x27;);&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123;  throw new Error(&#x27;报错了&#x27;);&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了\n\nrace()Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例\nconst p = Promise.race([p1, p2, p3]);\n\n只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变\n率先改变的 Promise 实例的返回值则传递给p的回调函数\nconst p = Promise.race([  fetch(&#x27;/resource-that-may-take-a-while&#x27;),  new Promise(function (resolve, reject) &#123;    setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000)  &#125;)]);p.then(console.log).catch(console.error);\n\nallSettled()Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例\n只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束\nconst promises = [  fetch(&#x27;/api-1&#x27;),  fetch(&#x27;/api-2&#x27;),  fetch(&#x27;/api-3&#x27;),];await Promise.allSettled(promises);removeLoadingIndicator();\n\nresolve()将现有对象转为 Promise对象\nPromise.resolve(&#x27;foo&#x27;)// 等价于new Promise(resolve =&gt; resolve(&#x27;foo&#x27;))\n\n参数可以分成四种情况，分别如下：\n\n参数是一个 Promise 实例，promise.resolve将不做任何修改、原封不动地返回这个实例\n参数是一个thenable对象，promise.resolve会将这个对象转为 Promise对象，然后就立即执行thenable对象的then()方法\n参数不是具有then()方法的对象，或根本就不是对象，Promise.resolve()会返回一个新的 Promise 对象，状态为resolved\n没有参数时，直接返回一个resolved状态的 Promise 对象\n\nreject()Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejectedconst p = Promise.reject(&#x27;出错了&#x27;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))p.then(null, function (s) &#123;  console.log(s)&#125;);// 出错了\n\nPromise.reject()方法的参数，会原封不动地变成后续方法的参数\nPromise.reject(&#x27;出错了&#x27;).catch(e =&gt; &#123;  console.log(e === &#x27;出错了&#x27;)&#125;)// true\n\n使用场景将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化\nconst preloadImage = function (path) &#123;  return new Promise(function (resolve, reject) &#123;    const image = new Image();    image.onload  = resolve;    image.onerror = reject;    image.src = path;  &#125;);&#125;;\n\n通过链式操作，将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题\n// 各司其职getInfo().then(res=&gt;&#123;    let &#123; bannerList &#125; = res    //渲染轮播图    console.log(bannerList)    return res&#125;).then(res=&gt;&#123;        let &#123; storeList &#125; = res    //渲染店铺列表    console.log(storeList)    return res&#125;).then(res=&gt;&#123;    let &#123; categoryList &#125; = res    console.log(categoryList)    //渲染分类列表    return res&#125;)\n\n通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可\nfunction initLoad()&#123;    // loading.show() //加载loading    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;        console.log(res)        loading.hide() //关闭loading    &#125;).catch(err=&gt;&#123;        console.log(err)        loading.hide()//关闭loading    &#125;)&#125;//数据初始化    initLoad()\n\n通过race可以设置图片请求超时\n//请求某个图片资源function requestImg()&#123;    var p = new Promise(function(resolve, reject)&#123;        var img = new Image();        img.onload = function()&#123;           resolve(img);        &#125;        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;    &#125;);    return p;&#125;//延时函数，用于给请求计时function timeout()&#123;    var p = new Promise(function(resolve, reject)&#123;        setTimeout(function()&#123;            reject(&#x27;图片请求超时&#x27;);        &#125;, 5000);    &#125;);    return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123;    console.log(results);&#125;).catch(function(reason)&#123;    console.log(reason);&#125;);\n\n\n\n\nhttps://es6.ruanyifeng.com/#docs/promise\n\n","categories":["js"],"tags":["js"]},{"title":"JS：继承、this、执行上下文","url":"/2025/09/17/JS%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81this%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"继承继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码\n在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。\n实现方式原型链继承修改子构造函数的原型对象为父类的实例，\n让我们来实现一下：\nfunction Parent() &#123;  this.name = &#x27;fedaily&#x27;&#125;Parent.prototype.getName = function() &#123;  return this.name;&#125;function Child() &#123;&#125;// 这里也可以直接写出Child.prototype = Parent.prototype// 但是这样就不能访问到父类的构造函数的属性了，即this.nameChild.prototype = new Parent()var child = new Child()child.getName() // fedaily\n\n缺点：\n\n创建实例时不能传参数\n从父类继承的属性值都在子类构造函数的原型对象上，并非单个子类实例拥有。\n\n构造函数继承构造函数继承其实就是通过修改父类构造函数this实现的继承。我们在子类构造函数中执行父类构造函数，同时修改父类构造函数的this为子类的this。\n我们直接看如何实现：\nfunction Parent() &#123;  this.name = [&#x27;fedaily&#x27;]&#125;function Child() &#123;  Parent.call(this)&#125;var child = new Child()child.name.push(&#x27;fe&#x27;)var child2 = new Child() // child2.name === [&#x27;fedaily&#x27;]\n\n子类每一个实例都会拥有自己的 name属性，可以接受参数。\n缺点：\n没有实现子类和父类原型对象上的关联，子类实例无法访问父类函数原型对象上的方法。\n如果要实现方法继承，方法则必须在构造函数中定义，产生了多个函数的副本，失去复用性。\n组合继承同时结合原型链继承、构造函数继承就是组合继承了。\nfunction Parent() &#123;  this.name = &#x27;fedaily&#x27;&#125;Parent.prototype.getName = function() &#123;  return this.name&#125;function Child() &#123;  Parent.call(this)  this.topic = &#x27;fe&#x27;&#125;Child.prototype = new Parent()// 需要重新设置子类的constructor，Child.prototype = new Parent()相当于子类的原型对象完全被覆盖了Child.prototype.constructor = Child\n\n结合前两个的优点，实现了父类的属性继承，并且可以访问到父类构造函数原型对象上的方法。\n缺点：\n调用了两次父类构造函数，子类实例自身和子类原型对象上都会存在父类继承来的属性，造成了一定程度的浪费。\n寄生组合继承寄生组合继承其实就是在组合继承的基础上，解决了父类构造函数调用两次的问题。我们来看下如何解决的：\nfunction Parent() &#123;  this.name = &#x27;fedaily&#x27;&#125;Parent.prototype.getName = function() &#123;  return this.name&#125;function Child() &#123;  Parent.call(this)  this.topic = &#x27;fe&#x27;&#125;// 仔细看这个函数的实现inherit(Child, Parent)function inherit(child, parent) &#123;  var prototype = object.create(parent.prototype)  prototype.constructor = child  child.prototype = prototype&#125;// 这个函数的作用可以理解为复制了一份父类的原型对象// 如果直接将子类的原型对象赋值为父类原型对象// 那么修改子类原型对象其实就相当于修改了父类的原型对象function object(o) &#123;  function F() &#123;&#125;  F.prototype = o;  return new F();&#125;//实现一个最基础的object.create\n\n核心在于inherit函数的实现，避免使用new关键字调用父类构造函数，转而实现其中的关键部分，凭空捏造一个适当的原型对象给子类，而非创造实例。\n用object.create创建一个原型是父类原型对象的对象，并添加constructor属性\nES6继承ES6提供了class语法糖，同时提供了extends用于实现类的继承。这也是项目开发中推荐使用的方式。\n使用class继承很简单，也很直观：\nclass Parent &#123;  constructor() &#123;    this.name = &#x27;fedaily&#x27;  &#125;  getName() &#123;    return this.name  &#125;&#125;class Child extends Parent &#123;  constructor() &#123;    // 这里很重要，如果在this.topic = &#x27;fe&#x27;后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明    super()    this.topic = &#x27;fe&#x27;  &#125;&#125;const child = new Child()child.getName() // fedaily\n\nthis函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。\n在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）\nthis 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象。\n同时，this在函数执行过程中，this一旦被确定了，就不可以再更改。\n绑定规则\n默认绑定  全局环境中定义person函数，全局对象、undefined、取决于是否是严格模式\n\n隐式绑定  函数还可以作为某个对象的方法调用，这时this就指这个上级对象。  若是再次赋值则会发生隐式丢失现象。\n\nnew绑定  通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象  new过程遇到return一个对象，此时this指向为返回的对象\n\n显示绑定  apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。  \n\n\n\n把null或者undefined（没有包装类，不能直接new一个新对象）作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则（DMZ对象）\n软绑定\n\n//软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到objfunction foo() &#123;  console.log(&quot;name: &quot; + this.name);&#125;var obj = &#123; name: &quot;obj&quot; &#125;,  obj2 = &#123; name: &quot;obj2&quot; &#125;,  obj3 = &#123; name: &quot;obj3&quot; &#125;;var fooOBJ = foo.softBind(obj);fooOBJ(); // name: objfooOBJ.call(obj3); // name: obj3\n\n\n箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局作用域来决定this\n\n执行上下文、执行栈执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中\n执行上下文的类型分为三种：\n\n全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象\n函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文\nEval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用\n\n生命周期执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段\n创建阶段创建阶段即当函数被调用，但未执行任何其内部代码之前\n创建阶段做了三件事：\n\n确定 this 的值，也被称为 This Binding\nLexicalEnvironment（词法环境） 组件被创建\nVariableEnvironment（变量环境） 组件被创建\n\n执行阶段在这阶段，执行变量赋值、代码执行\n如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值\n回收阶段执行上下文出栈等待虚拟机回收执行上下文\n执行栈执行栈，也叫调用栈，用于存储在代码执行期间创建的所有执行上下文\n当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中\n每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中\n引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文\n","categories":["js"]},{"title":"vue：SPA（单页面应用）","url":"/2025/09/15/vue%EF%BC%9ASPA%EF%BC%88%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%89/","content":"什么是SPASPA（single-page application），翻译过来就是单页应用。SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，避免了页面之间切换打断用户体验。在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要动态装载适当的资源并添加到页面页面。在任何时间点都不会重新加载，也不会将控制转移到其他页面。\n我们熟知的JS框架如react,vue,angular,ember都属于SPA\n与MPA的区别多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载\n页应用与多页应用的区别\n\n\n\n单页面应用（SPA）\n多页面应用（MPA）\n\n\n\n组成\n一个主页面和多个页面片段\n多个主页面\n\n\n刷新方式\n局部刷新\n整页刷新\n\n\nurl模式\n哈希模式\n历史模式\n\n\nSEO搜索引擎优化\n难实现，可使用SSR方式改善\n容易实现\n\n\n数据传递\n容易\n通过url、cookie、localStorage等传递\n\n\n页面切换\n速度快，用户体验良好\n切换加载资源，速度慢，用户体验差\n\n\n维护成本\n相对容易\n相对复杂\n\n\n实现SPA原理：简单来说，就是通过JS监听到URL的变化，从而对页面进行处理。\nHistory模式原本的浏览器：\nhttps://www.bing.com/                //初始状态https://www.bing.com/test          //URL改变，页面刷新，显示目标页面\n\n要实现的效果：\nhttps://www.bing.com/                //初始状态https://www.bing.com/test          //URL改变，页面不刷新，显示目标页面    \n\n\n\n// 定义 Router  class Router &#123;      constructor () &#123;          this.routes = &#123;&#125;;          this.listerPopState()      &#125;            init(path) &#123;          history.replaceState(&#123;path: path&#125;, null, path);          this.routes[path] &amp;&amp; this.routes[path]();      &#125;            route(path, callback)&#123;          this.routes[path] = callback;  //跳转成功，url修改之后做处理来动态更新页面    &#125;            push(path) &#123;          history.pushState(&#123;path: path&#125;, null, path);          this.routes[path] &amp;&amp; this.routes[path]();      &#125;            listerPopState () &#123;          window.addEventListener(&#x27;popstate&#x27; , e =&gt; &#123;              const path = e.state &amp;&amp; e.state.path;  //监听回退，回退之后触发state这个栈栈顶的那条历史记录的处理            this.routers[path] &amp;&amp; this.routers[path]()          &#125;)      &#125;  &#125;    // 使用 Router    window.miniRouter = new Router();  miniRouter.route(&#x27;/&#x27;, ()=&gt; console.log(&#x27;page1&#x27;))  miniRouter.route(&#x27;/page2&#x27;, ()=&gt; console.log(&#x27;page2&#x27;))    // 跳转  miniRouter.push(&#x27;/page2&#x27;)  // page2  \n\nHash模式原本的浏览器：\nhttps://www.bing.com/#                //初始状态https://www.bing.com/#/test          //URL改变，页面不刷新    \n\n要实现的效果：\nhttps://www.bing.com/#                    //初始状态https://www.bing.com/test/#/test          //URL改变，页面刷新    \n\n该模版不完全，实际意思就是可以直接对页面hashChange进行监听，改变就直接触发refresh函数\n// 定义 Router  class Router &#123;      constructor () &#123;          this.routes = &#123;&#125;; // 存放路由path及callback          this.currentUrl = &#x27;&#x27;;                    // 监听路由change调用相对应的路由回调          window.addEventListener(&#x27;load&#x27;, this.refresh, false);          window.addEventListener(&#x27;hashchange&#x27;, this.refresh, false);      &#125;            route(path, callback)&#123;          this.routes[path] = callback;      &#125;            push(path) &#123;          this.routes[path] &amp;&amp; this.routes[path]()      &#125;  &#125;    // 使用 router  window.miniRouter = new Router();  miniRouter.route(&#x27;/&#x27;, () =&gt; console.log(&#x27;page1&#x27;))  miniRouter.route(&#x27;/page2&#x27;, () =&gt; console.log(&#x27;page2&#x27;))    miniRouter.push(&#x27;/&#x27;) // page1  miniRouter.push(&#x27;/page2&#x27;) // page2  \n\nSPA首屏加载慢原因：\n\n网络延时问题\n资源文件体积是否过大\n资源是否重复发送请求去加载了\n加载脚本的时候，渲染内容堵塞了\n\n解决方案：常见的几种SPA首屏优化方式：\n\n减小入口文件体积\n静态资源本地缓存\nUI框架按需加载\n图片资源的压缩\n组件重复打包\n开启GZip压缩\n使用SSR\n\n减小入口文件体积常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n在vue-router配置路由的时候，采用动态加载路由的形式\nroutes:[     path: &#x27;Blogs&#x27;,    name: &#x27;ShowBlogs&#x27;,    component: () =&gt; import(&#x27;./components/ShowBlogs.vue&#x27;)]\n\n以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件\n静态资源本地缓存后端返回资源问题：\n\n采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头\n采用Service Worker离线缓存\n\n前端合理利用localStorage\nUI框架按需加载组件重复打包假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载\n解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置\nminChunks: 3\n\nminChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件\n图片资源的压缩图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素\n对于所有的图片资源，我们可以进行适当的压缩\n对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力\n","categories":["vue"]},{"title":"vue：v-show、v-if","url":"/2025/09/15/vue%EF%BC%9Av-show%E3%80%81v-if/","content":"v-show和v-if有什么区别共同点都能控制元素在页面是否显示\n在用法上也是相同的\n&lt;Model v-show=&quot;isShow&quot; /&gt;&lt;Model v-if=&quot;isShow&quot; /&gt;\n\n\n当表达式为true的时候，都会占据页面的位置\n当表达式都为false时，都不会占据页面位置\n\n区别\n控制手段不同\n编译过程不同\n编译条件不同\n\n控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除\n编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换\n编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染\n\nv-show 由false变为true的时候不会触发组件的生命周期\nv-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法\n\n性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n原理分析\n将模板template转为ast结构的JS对象\n用ast得到的JS对象拼装render和staticRenderFns函数\nrender和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息\nvm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点\n\nv-show// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement&gt; = &#123;  beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123;      //保存初始display属性，便于后续恢复    el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display    if (transition &amp;&amp; value) &#123;        // 如果有过渡效果且需要显示（value为true），则执行过渡前的准备      transition.beforeEnter(el)    &#125; else &#123;        //否则直接设置元素显示状态      setDisplay(el, value)    &#125;  &#125;,  mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123;    if (transition &amp;&amp; value) &#123;      transition.enter(el)    &#125;  &#125;,  updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123;    // ...  &#125;,  beforeUnmount(el, &#123; value &#125;) &#123;    setDisplay(el, value)  &#125;&#125;\n\nv-if考虑到还要执行else else-if，更复杂\n返回一个node节点，render函数通过表达式的值来决定是否生成DOM\n（看不懂，暂时跳过了\nexport const transformIf = createStructuralDirectiveTransform(  /^(if|else|else-if)$/,  (node, dir, context) =&gt; &#123;    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123;      // ...      return () =&gt; &#123;        if (isRoot) &#123;          ifNode.codegenNode = createCodegenNodeForBranch(            branch,            key,            context          ) as IfConditionalExpression        &#125; else &#123;          // attach this branch&#x27;s codegen node to the v-if root.          const parentCondition = getParentCondition(ifNode.codegenNode!)          parentCondition.alternate = createCodegenNodeForBranch(            branch,            key + ifNode.branches.length - 1,            context          )        &#125;      &#125;    &#125;)  &#125;)\n\n","categories":["vue"]},{"title":"vue：vi-if、v-for","url":"/2025/09/16/vue%EF%BC%9Avi-if%E3%80%81v-for/","content":"v-if、v-for优先级问题作用v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染\nv-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名\n在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化\n优先级v-if与v-for都是vue模板系统中的指令\n在vue模板编译的时候，会将指令系统转化成可执行的render函数\n示例编写一个p标签，同时使用v-if与 v-for\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt;        &#123;&#123; item.title &#125;&#125;    &lt;/p&gt;&lt;/div&gt;\n\n创建vue实例，存放isShow与items数据\nconst app = new Vue(&#123;  el: &quot;#app&quot;,  data() &#123;    return &#123;      items: [        &#123; title: &quot;foo&quot; &#125;,        &#123; title: &quot;baz&quot; &#125;]    &#125;  &#125;,  computed: &#123;    isShow() &#123;      return this.items &amp;&amp; this.items.length &gt; 0    &#125;  &#125;&#125;)\n\n模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数\nƒ anonymous() &#123;  with (this) &#123; return     _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;,     _l((items), function (item)     &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\\n&quot; + _s(item.title) + &quot;\\n&quot;)]) : _e() &#125;), 0) &#125;&#125;\n\n_l是vue的列表渲染函数，函数内部都会进行一次if判断\n初步得到结论：v-for优先级是比v-if高\n再将v-for与v-if置于不同标签\n&lt;div id=&quot;app&quot;&gt;    &lt;template v-if=&quot;isShow&quot;&gt;        &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;    &lt;/template&gt;&lt;/div&gt;\n\n再输出下render函数\nƒ anonymous() &#123;  with(this)&#123;return     _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,    [(isShow)?[_v(&quot;\\n&quot;),    _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;&#125;\n\n这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染\n我们再在查看下vue源码\n源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js\nexport function genElement (el: ASTElement, state: CodegenState): string &#123;  if (el.parent) &#123;    el.pre = el.pre || el.parent.pre  &#125;  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;    return genStatic(el, state)  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;    return genOnce(el, state)  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;    return genFor(el, state)  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;    return genIf(el, state)  &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;    return genChildren(el, state) || &#x27;void 0&#x27;  &#125; else if (el.tag === &#x27;slot&#x27;) &#123;    return genSlot(el, state)  &#125; else &#123;    // component or element    ...&#125;\n\n在进行if判断的时候，v-for是比v-if先进行判断\n最终结论：v-for优先级比v-if高\nvue3的优化当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：\ntemplate\n&lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义--&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;  &#123;&#123; todo.name &#125;&#125;&lt;/li&gt;\n\n在外先包装一层 &lt;template&gt; 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)：\ntemplate\n&lt;template v-for=&quot;todo in todos&quot;&gt;  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;    &#123;&#123; todo.name &#125;&#125;  &lt;/li&gt;&lt;/template&gt;\n","categories":["vue"]},{"title":"vue：vue实例挂载","url":"/2025/09/15/vue%EF%BC%9Avue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD/","content":"Vue实例挂载的过程new Vue()这个过程中究竟做了些什么？\n过程中是如何完成数据的绑定，又是如何将数据渲染到视图的？\n分析","categories":["vue"]},{"title":"vue：声明式、mvvm、虚拟dom","url":"/2025/09/10/vue%EF%BC%9A%E5%A3%B0%E6%98%8E%E5%BC%8F%E3%80%81mvvm%E3%80%81%E8%99%9A%E6%8B%9Fdom/","content":"vue是一个用于构建用户界面的，渐进式框架。vue的核心库只关心图层。\n1.1 声明式框架需求：记住上一次的登录用户名\n\n命令式：UI的更新是由程序员使用代码主动刷新，UI与数据并无必然的映射关系，这种我们称之为命令式UI\n  //基于JQuery的实现const lastLoginUsername = localstorage.getItem(&quot;lastLoginUsername&quot;)$(&quot;#username&quot;).val(lastLoginUsername);//主动刷新UI \n\n声明式：UI的更新并非由程序员使用代码来主动刷新，而是由后面隐藏机制来负责维护UI的刷新，UI与数据有映射关系，这种我们就称之为声明式UI\n  //代码做了删减，只保留了有关的部分export const LoginView = observer(() =&gt; &#123;  const [username, setUsername] = useState(localStorage.getItem(&#x27;login_username&#x27;));  return (&lt;Input className=&quot;input_username&quot; value=&#123;username&#125; onChange=&#123;e =&gt; setUsername(e.target.value)&#125; /&gt;);&#125;);\n\n因此声明式的UI会更加简单。\n1.2 MVVM模式如何设计一个程序的结构，这是一门专门的学问，叫做”架构模式”（architectural pattern），属于编程的方法论。\n\nMVC：MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。  应用程序的数据、业务逻辑和用户界面进行分离，使得每个组件的职责更加明确，代码更易于组织和维护。  当用户与View进行交互时，View会将事件通知给Controller，Controller根据事件的类型和用户输入处理相关的业务逻辑，并更新Model中的数据。然后，Controller将更新后的数据传递给View，使得View可以展示最新的数据给用户。\n\n\n最顶层，直接面向最终用户的 “视图层”。\n中间层，“控制层”，根据用户从“视图”输入的指令，选取“数据”，进行操作，产生结果。\n最低层，核心“数据层”。\n\n\n  后来由于需求越来越庞大，controller层越来越复杂，因此隐藏了controller的MVVM模型出现了。\n\nMVVM：  本质是解耦。将应用程序的UI与其底层数据模型分离，通过数据绑定实现数据和UI的自动同步，从而降低代码的耦合度，提高应用程序的可维护性和可测试性。  在传统的MVVM模式中，数据和视图的绑定是必须的。但是vue并没有完全遵循MVVM模型，例如，vue中类似ref的api可以操作数据。\n\n\nV：“视图层”，面向用户的界面。\nVM：“视图模型”，视图和视图模型的数据应该同步连接，二者共同变化，自动更新。\nM: ”模型&#x2F;数据层“。\n\n\n\n\n1.3 采用虚拟dom\n为什么需要虚拟dom\n\n操作DOM的代价是非常昂贵的，频繁的操作会造成页面卡顿，影响用户的体验。传统原生api和jQuery去操作dom时，浏览器会从构建dom树开始从头到尾执行一遍渲染流程。如果多次更新，那么这个流程也会被执行多次。\n\nvue虚拟dom的好处\n\n通过vnode，更新dom时，现将更新的diff内容保存到js对象中，再一次性更新dom树。但是，虚拟dom最大的优势是抽象了原来的渲染过程，给予了框架跨平台的能力。\n1.4 区分编译时和运行时vue渲染的核心是调用render方法将虚拟dom渲染成真是dom。&#x2F;&#x2F;待补充？？\n1.5 组件化\n什么是组件化？\n\n一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式。\n\n优势？\n\n\n降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现\n调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单\n提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级\n\n参考：\n\n深入理解MVVM\n虚拟dom\n\n","categories":["vue"]},{"title":"vue：生命周期","url":"/2025/09/15/vue%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"生命周期Vue中实例从创建到销毁的过程就是生命周期。\n即指从创建、初始化数据、编译模板、挂载Dom\n→渲染、更新\n→渲染、卸载等一系列过程\n有哪些？Vue生命周期总共可以分为8个阶段：\n创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期\n\n\n\n生命周期\n描述\n\n\n\nbeforeCreate\n组件实例被创建之初\n\n\ncreated\n组件实例已经完全创建\n\n\nbeforeMount\n组件挂载之前\n\n\nmounted\n组件挂载到实例上去之后\n\n\nbeforeUpdate\n组件数据发生变化，更新之前\n\n\nupdated\n组件数据更新之后\n\n\nbeforeDestroy\n组件实例销毁之前\n\n\ndestroyed\n组件实例销毁之后\n\n\nactivated\nkeep-alive 缓存的组件激活时\n\n\ndeactivated\nkeep-alive 缓存的组件停用时调用\n\n\nerrorCaptured\n捕获一个来自子孙组件的错误时被调用\n\n\n新生命周期\nsetup() : 开始创建组件之前，在 beforeCreate 和 created 之前执行，创建的是 data 和 method\nonBeforeMount() : 组件挂载到节点上之前执行的函数；\nonMounted() : 组件挂载完成后执行的函数；\nonBeforeUpdate(): 组件更新之前执行的函数；\nonUpdated(): 组件更新完成之后执行的函数；\nonBeforeUnmount(): 组件卸载之前执行的函数；\nonUnmounted(): 组件卸载完成后执行的函数；\nonActivated(): 被包含在 中的组件，会多出两个生命周期钩子函数，被激活时执行\nonDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行；\nonErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。\n\n","categories":["vue"]},{"title":"JS：事件模型","url":"/2025/09/18/JS%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/","content":"事件与事件流javascript中的事件，可以理解就是在HTML文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等\n由于DOM是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念\n事件流都会经历三个阶段：\n\n事件捕获阶段(capture phase)\n\n处于目标阶段(target phase)\n\n事件冒泡阶段(bubbling phase)\n  在 JavaScript 中，大部分事件会沿着 DOM 树向上冒泡（从触发元素到祖先元素），但有一些事件不会冒泡。以下是常见的不会冒泡的事件：\n\nfocus：元素获得焦点时触发\nblur：元素失去焦点时触发\nmouseenter：鼠标进入元素时触发（与 mouseover 不同，后者会冒泡）\nmouseleave：鼠标离开元素时触发（与 mouseout 不同，后者会冒泡）\nload：资源（如图片、脚本）加载完成时触发\nunload：资源卸载完成时触发\nerror：发生错误时触发（如图片加载失败）\nabort：资源加载被中断时触发\nscroll：元素滚动时触发（虽然不会冒泡，但可以通过 window 监听）\nresize：窗口或元素大小改变时触发\n\n  这些事件之所以不冒泡，通常是因为它们与特定元素的状态或资源加载过程相关，不需要在 DOM 树中向上传播。例如，focus 和 blur 仅与当前获得 &#x2F; 失去焦点的元素相关，而 mouseenter&#x2F;mouseleave 设计为不冒泡是为了避免父元素重复触发事件。\n  需要注意的是，虽然 focus 和 blur 本身不冒泡，但可以通过 focusin 和 focusout 事件来监听类似行为，这两个事件是会冒泡的。\n\n\n事件模型事件模型可以分为三种：\n\n原始事件模型（DOM0级）\n标准事件模型（DOM2级）\nIE事件模型（基本不用）\n\n&#x2F;&#x2F;没遇见过，暂时不管了\n事件代理事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素\n事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素\n如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件\n&lt;ul id=&quot;list&quot;&gt;  &lt;li&gt;item 1&lt;/li&gt;  &lt;li&gt;item 2&lt;/li&gt;  &lt;li&gt;item 3&lt;/li&gt;  ......  &lt;li&gt;item n&lt;/li&gt;&lt;/ul&gt;\n\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的\n// 获取目标元素const lis = document.getElementsByTagName(&quot;li&quot;)// 循环遍历绑定事件for (let i = 0; i &lt; lis.length; i++) &#123;    lis[i].onclick = function(e)&#123;        console.log(e.target.innerHTML)    &#125;&#125;\n\n这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素\n// 给父层元素绑定事件document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;    // 兼容性处理    var event = e || window.event;    var target = event.target || event.srcElement;    // 判断是否匹配目标元素    if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;        console.log(&#x27;the content is: &#x27;, target.innerHTML);    &#125;&#125;);\n","categories":["js"],"tags":["js","html"]},{"title":"CSS：布局","url":"/2025/09/17/CSS%EF%BC%9A%E5%B8%83%E5%B1%80/","content":"flex布局flex是加在容器上的属性,用于指定这个容器为flex布局—-此时的floatclear vertical align都不再起效\n容器的属性\n\n\n\n容器属性\n作用\n值\n\n\n\nflex-direction\n决定主轴方向\nrow &#x2F;row-reverse&#x2F;column&#x2F;column-reverse\n\n\nflex-wrap\n如果一行装不下如何换行\nnowrap&#x2F;wrap&#x2F;wrap-reverse\n\n\nflex-flow\n是direction和wrap的简写形式\n同上\n\n\njustify-ontent\n项目在主轴上的对齐方式\nflex-start&#x2F;flex-end&#x2F;center&#x2F;space-between&#x2F;space-around\n\n\nalign-items\n定义在交叉轴上如何对齐\nflex-start&#x2F;flex-end&#x2F;center&#x2F;strench&#x2F;baseline\n\n\nalign-content\n定义多根轴线的对齐方式(一根主轴时该属性不起作用)\nflex-start&#x2F;flex-end&#x2F;center&#x2F;strench&#x2F;space-between&#x2F;space-around\n\n\n\n\n\n项目的属性\n定义\n值\n\n\n\norder\n项目的排列顺序,数值越小排列越靠前\n默认为0\n\n\nflex-grow\n项目的放大比例(如果有剩余空间放大项目等比例放大)\n默认为0\n\n\nflex-shrink\n缩小比例(如果空间不足,缩小项目等比例缩小)\n默认值为1(即默认都会缩小)\n\n\nflex-basis\n分配多余空间之前,项目占据的主轴空间,浏览器根据该属性计算是否有剩余空间\n默认值为auto项目本身大小\n\n\nflex\ngrow,shrink,basis的简写\n默认值(01auto) auto(11auto) none(00auto)\n\n\nalign-self\n允许单个项目有与其他项目不同的对齐方式,可以覆盖align-items属性\n\n\n\n","categories":["css"],"tags":["css布局"]},{"title":"JS：节流、防抖","url":"/2025/09/26/JS%EF%BC%9A%E8%8A%82%E6%B5%81%E3%80%81%E9%98%B2%E6%8A%96/","content":"节流防抖本质上是优化高频率执行代码的一种手段\n如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能\n为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率\n定义\n节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时\n\n一个经典的比喻:\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应\n假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制\n电梯第一个人进来后，15秒后准时运送一次，这是节流\n电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖\n代码实现节流事件上绑定，trottled1执行的返回函数\n使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行\nfunction throttled1(fn, delay = 500) &#123;    let oldtime = Date.now()    return function (...args) &#123;        let newtime = Date.now()        if (newtime - oldtime &gt;= delay) &#123;            fn.apply(null, args)            oldtime = Date.now()        &#125;    &#125;&#125;\n\n使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行\nfunction throttled2(fn, delay = 500) &#123;    let timer = null    return function (...args) &#123;        if (!timer) &#123;            timer = setTimeout(() =&gt; &#123;                fn.apply(this, args)                timer = null            &#125;, delay);        &#125;    &#125;&#125;\n\n可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下\nfunction throttled(fn, delay) &#123;    let timer = null    let starttime = Date.now()    return function () &#123;        let curTime = Date.now() // 当前时间        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间        let context = this        let args = arguments        clearTimeout(timer)        if (remaining &lt;= 0) &#123;            fn.apply(context, args)            starttime = Date.now()        &#125; else &#123;            timer = setTimeout(fn, remaining);        &#125;    &#125;&#125;\n\n防抖简单版本的实现\nfunction debounce(func, wait) &#123;    let timeout;    return function () &#123;        let context = this; // 保存this指向        let args = arguments; // 拿到event对象        clearTimeout(timeout)        timeout = setTimeout(function()&#123;            func.apply(context, args)        &#125;, wait);    &#125;&#125;\n\n防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：\nfunction debounce(func, wait, immediate) &#123;    let timeout;    return function () &#123;        let context = this;        let args = arguments;        if (timeout) clearTimeout(timeout); // timeout 不为null        if (immediate) &#123;            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发            timeout = setTimeout(function () &#123;                timeout = null;            &#125;, wait)            if (callNow) &#123;                func.apply(context, args)            &#125;        &#125;        else &#123;            timeout = setTimeout(function () &#123;                func.apply(context, args)            &#125;, wait);        &#125;    &#125;&#125;\n","categories":["js"]},{"title":"JS：变量、数据类型","url":"/2024/02/28/JS%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"变量我们可以使用 var、let 或 const 声明变量来存储数据。\n\nvar声明的变量既是全局变量，也是顶层变量，也是全局对象上的属性  存在变量提升：  变量会在所有代码执行前被声明，没赋值。  能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明。  函数提升优先级高于变量，且函数声明不会被变量声明覆盖；但是会被变量赋值覆盖；\n\nlet是ES6新增的命令，用来声明变量。所声明的变量，只在let命令所在的代码块内有效。  声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误，这个现象成为暂时性死区。\n  let不允许在相同作用域中重复声明。\n\nconst声明一个只读的常量，一旦声明，常量的值就不能改变。\n  const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n  如果之前用var或let声明过变量，再用const声明同样会报错\n\n\n合理的分配内存,先提前变量&amp;函数,提前预留空间。\njavascript标识符所有 JavaScript 变量必须以唯一的名称的标识。\n这些唯一的名称称为标识符。\n构造变量名称（唯一标识符）的通用规则是：\n\n名称可包含字母、数字、下划线和美元符号\n名称也可以 以字母，$ 和 _ 开头\n名称对大小写敏感（y 和 Y 是不同的变量）\n保留字无法用作变量名称\n\n命名规范:驼峰命名法:maxLength类名会使用大驼峰命名法:MaxLength常量的字母全大写MAX_LENGTH\n数据类型与处理JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。\n&#x3D;&#x3D;我们可以通过 typeof 运算符查看存储在变量中的数据类型&#x3D;&#x3D;(值的类型,变量没有类型)\n\n两种形式：typeof x 或者 typeof(x)。\n\n以字符串的形式返回类型名称，例如 “string”。\n\nNumber \n\n用于任何类型的数字：整数或浮点数，在 ±(253-1) 范围内的整数。\ninfinity(数字超出范围后显示,数字一种)\nNaN,特殊数值,非法数字\n0b-2 0o-8 0x-16  可以这么创建,输出还是十进制\n\n\nBigint \n\n用于任意长度的整数。使用n结尾,无限大(内存)不能混合计算\n\n\nString \n\n用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。\n模版字符串aaaaa$&#123;变量&#125;\n\n\nBoolean \n\n用于 true 和 false。\ntrue不一定等于1,false不一定等于0。\n\n\nNull \n\n用于未知的值 —— 只有一个 null 值的独立类型。\nnull是表示一个空对象指针。\ntypeof null 会返回 “object” —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 object。\n\n\nUndefined \n\n用于未定义的值 —— 只有一个 undefined 值的独立类型。\n在使用var 声明变量但未对其加初始化时，这个变量就是undefined。\n\n\nSymbol \n\n用于唯一的标识符。\nlet c&#x3D;symbol()\n\n\nObject \n\n用于更复杂的数据结构，比如 function、Array、Date。\n\n\n\n前七为原始数据,是不可变类型\n\n一旦创建,不可修改,修改变量,只是改变指向的地址,使其指向新创建的原始数据\n值的比较\n运算符\n\n\n\n\n等值检测运算符\n说明\n\n\n\n&#x3D;&#x3D;（相等）\n比较两个操作数的值是否相等\n\n\n!&#x3D;（不相等）\n比较两个操作数的值是否不相等\n\n\n&#x3D;&#x3D;&#x3D;（全等）\n比较两个操作数的值是否相等，同时检测它们的类型是否相同\n\n\n!&#x3D;&#x3D;（不全等）\n比较两个操作数的值是否不相等，同时检测它们的类型是否不相同\n\n\n\n\n\n\n比较规则\n\n比较运算符始终返回布尔值。\n非数值进行关系运算时,将其转换为数值比较,\n同时两个字符串的比较，不转换数值,会按照“词典”顺序逐字符地比较大小。\n在相等运算中，应注意以下几个问题：\n如果操作数是布尔值，则先转换为数值，其中 false 转为 0，true 转换为 1。\n如果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。\n如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。\n如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。\n如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。\n\n\n在非严格相等 &#x3D;&#x3D; 下，null 和 undefined 相等且各自不等于任何其他的值。\nNaN与任何值都不相等，包括它自己。任何操作数与NaN比较，都是false\n在使用 &gt; 或 &lt; 进行比较时，需要注意变量可能为 null&#x2F;undefined 的情况。比较好的方法是单独检查变量是否等于 null&#x2F;undefined。\n\n类型转换\n显式类型转换\n\n将其他数据类型转换成String类型\n\ntoString()\n\n   该方法&#x3D;&#x3D;不会影响到原变量，它会将转换的结构返回&#x3D;&#x3D;。但是注意，Null和Undefined没有toString()方法，如果调用它们的方法，则会报错。\n\nString()\n\n\n\n   将被转换的数据作为参数传递给函数。使用String函数做类型强制转换时，对于Number和Boolean就是调用toString()方法，对于null和undefined，就不会调用toString()方法，它会将null直接转换成”null”，将undefined转换成”undefined”。 2. 将其他的数据类型转换为Number类型\n - Number()\n     - 如果是纯数字的字符串，则直接将其转换为数字。\n     - 如果字符串中有非数字的内容，则转换为NaN。\n     - 布尔类型转换成数字：Ture转成1；False转成0。\n     - Null转成数字0。\n     - Undefined转成数字NaN。\n\n - parseInt()，parseFloat()\n     - 针对字符串转换成数字\n\n     - parseInt()把一个字符串转换为一个整数，**只取整数部分**；\n     - parseFloat()把一个字符串转换为一个浮点数，可获得有效小数;\n     - 对非String使用parseInt()或parseFloat()，它会将其转换为String\n\n\n将其他的数据类型转换为Boolean类型\n\nBoolean()\n\n对于数字，0和NaN是false，其余的都是true。\n对于字符串，空串是false，其余的都是true。\n对于null和undefined，都是false。\n对于对象，都是true\n所有表示空性质,错误的,没有的转换为false\n\n\n\n\n\n\n隐式类型转换\n\n转换为String类型\n为任意的数据加一个空串\n\n\n\n\n\n\t\nvar a = 123;a = a + ‘’;//a:&quot;123&quot;\n\n\n\n\n转换为Number类型\n在数据前面放个+\n\n\n\n var a = &#x27;123&#x27;a = +a;//a:123\n\n转换为Boolean类型\n\n为任意的数据取两次反  var a = 10;\n\n\n数组与字符串字符串JS中的字符串是基本数据类型中的一种。字符串可以用双引号包裹，也可以用单引号包裹，JS中的字符串是动态的，不需要去为他设置长度。\nlength：查看当前字符串中字符的数量，就算其中包括双字符也会按照单字符计算：\n\nstr长度按理来讲正常会为5，为6的原因是“😧”是进行增补过编码的字符，length属性按照16位码元作为一个字符去处理字符串，但是“😧”会占32位，所以他会被当成“😧”两个字符看待。\nconcat用于连接（合并&#x2F;拼接）字符串，使用方法为:&#x3D;&#x3D;也可以拼接数组&#x3D;&#x3D;\nlet str = &quot;hello&quot;;let str2 = str.concat(&quot; world&quot;, &quot; qwq&quot;);console.log(str); console.log(str2); \n\n字符串也可以使用加运算符来拼接：\nlet str = &quot;hello&quot; + &quot; world&quot;;console.log(str); // hello world\n\n实际开发中更倾向于使用+运算符进行字符串拼接\nslice、substr、substring切片方法，顾名思义，就是将字符串切成某一段的一片：\n他接受两个参数，第一个参数是开始的位置（必传），第二个参数是结束的位置&#x3D;&#x3D;数组同,并且可以实行数组浅拷贝&#x3D;&#x3D;\n当传入负数时，按照从末位开始算，-1表示倒数第一位\nlet str = &quot;一二三四五六七八&quot;;let strSplice = str.slice(0,6);console.log(strSplice);\n\nsubstr substring也有一样的效果，只是传参和应用场景不同，这部分留作作业写在作业里面。\ntrim返回一个新字符串，删除了左右的所有空格。\n在实际开发中会用到这个方法进行用户输入数据的处理\nsplit字符串打成数组\nlet str = &quot;一二三四五六七八&quot;;let engStr = &quot;hello world you qwq&quot;;console.log(str.split(&quot;&quot;));console.log(engStr.split(&quot; &quot;));\n\ntoLowerCase、toUpperCase大小写转换。\nincludes用来检查字符串是否包含某些内容\nstartwith endwith检查字符串是否以指定内容开头结尾\npadstart end补充内容控制长度\nreplace&#x2F;replaceAll用xxx替换字符串中xxx返回字符串\n数组一种复杂的数据类型，存储在堆中。\n在JS的数组中，可以任意的存放各种类型的数据（这点和大多数其他语言不同），并且JS的数组是动态的，他会自动为你扩充大小。\n在开发中，数组有时候也会存入一系列对象，这在JS中是被允许的，而且也会有遍历的方法，详见下文\nlength和字符串的属性类似，数组会有一个length属性供我们查看数组中有多少个元素。\njoin其实在JS中，数组也是一种特殊的对象，所有对象都会拥有toString方法用于返回一个和该对象有关的字符串，数组也不例外，他可以返回一个用逗号相连的字符串。\nlet arr = [&quot;a&quot;, &quot;b&quot;, 1, 2, &quot;qwq&quot;];console.log(arr.toString());\n\n使用join方法可以直接返回一个以传入参数为分隔连接起来的字符串\nlet arr = [&quot;a&quot;, &quot;b&quot;, 1, 2, &quot;qwq&quot;];console.log(arr.join(&quot;&quot;));\n\n不推荐使用toString方法，因为toString方法在任何对象（包括各种数组以外的对象）join方法相对更好用。\npush：向数组的最后推入一项,或多项,并返回新的长度\npop：移除并返回数组的最后一项\n使用push向末尾推入新的一项，用pop删除最后一项，这样的操作方式和栈的工作原理一致\nshift：移除数组的第一项\n使用shift和push方法可以构建类似队列的处理方式，使用push推入最后一项，使用shift删除最前面的一项。\nunshift：向数组最前方推入一项或多项,并返回数组长度\nsplice:可以删除,添加,插入,替换,数组中的元素,\n- 删除的起始位置\n- 删除的数量\n- 要插入的元素(放入切片的地方)\n- 返回被删除的元素\n\nreverse:反转数组\n数组的迭代方法forof:(处理可迭代对象) for(let value of arr){}\nforin(处理对象)\nforEach：forEach是不带有返回值的方法：\nlet arr = [1, 2, 3, 4, 5, 6];arr.forEach((item) =&gt; &#123;  console.log(item);&#125;);\n\nmap方法：map是带有返回值的方法，并且map方法比forEach要更快，他会返回一个新的数组；\nlet arr = [1, 2, 3, 4, 5, 6];let arrNew = arr.map((item) =&gt; &#123;  return item + 1;&#125;);console.log(arr);console.log(arrNew);\n\n并且，map方法可以方便进行链式调用\nlet arr = [1, 2, 3, 4, 5, 6];let arrNew = arr  .map((item，index) =&gt; &#123;    return item + 1;  &#125;)  .filter((item) =&gt; &#123;    return item &gt; 2 ? item : undefined;  &#125;);console.log(arr);console.log(arrNew);\n\n在实际开发中，由于map拥有这样可以返回新数组、运行效率高、可以链式调用的特性，我们通常使用map而不是forEach方法\nfilterfilter方法用于对数组进行过滤。它会创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。\nvar arr = [2,3,4,5,6]var result = arr.filter(function (number) &#123;    return number &gt; 3&#125;)console.log(result);\n\n上述代码中，filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。\nindexOfarray.indexOf(item,start)方法可返回数组中某个指定的元素位置。该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。如果在数组中没找到指定元素则返回 -1。\n let fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];let index = fruits.indexOf(&quot;Apple&quot;);console.log(index);\n\nlastindof 同上从后往前查\nmapMap类型是键值对的有序列表，而键和值都可以是任意类型\nMap本身是一个构造函数，用来生成 Map 数据结构。\n增删改查\nsize:map中属性的数量\nmap.set：添加与修改\nmap.get：获取\nmap.has:检查是否存在\nmap.delete:删除\nmap.cleat():清空\narry.from(map)：能将map转数组\n\n遍历Map结构原生提供三个遍历器生成函数和一个遍历方法：\n\nkeys()：返回键名的遍历器\nvalues()：返回键值的遍历器\nentries()：返回所有成员的遍历器\nforEach()：遍历 Map 的所有成员\n\n遍历顺序就是插入顺序\nconst map = new Map([  [&#x27;F&#x27;, &#x27;no&#x27;],  [&#x27;T&#x27;,  &#x27;yes&#x27;],]);for (let key of map.keys()) &#123;  console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123;  console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123;  console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123;  console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) &#123;  console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;map.forEach(function(value, key, map) &#123;  console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;);\n\nsetSet是es6新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合\n增删改查\nsize获取数量\nadd添加\ndelete删除\nhas检查\n\n遍历关于遍历的方法，有如下：\n\nkeys()：返回键名的遍历器\nvalues()：返回键值的遍历器\nentries()：返回键值对的遍历器\nforEach()：使用回调函数遍历每个成员\n\nSet的遍历顺序就是插入顺序\nkeys方法、values方法、entries方法返回的都是遍历器对象\n函数函数内容\n函数是什么？\n\n函数是在其中有一组代码的逻辑构件，用来执行特定任务。实际上为了易于调试和维护，函数允许以更有组织的方式去编写代码。函数还允许代码重用。\n在JavaScript里，函数实际上是对象， 每个函数都是Function类型的实例， 而Function也有属性和方法。因为函数是对象， 所以函数名就是指向函数对象的指针\n\n\n如何创建一个函数？\n\n使用Function构造函数创建函数\n\n在这种方法中，函数是在“函数”的构造函数的帮助下创建的。从技术上讲，这种方法比使用函数表达式语法和函数声明语句语法去声明函数的方法效率要低。\n\n const sum2 = new Function(&quot;a1&quot;, &quot;a2&quot;, &quot;return a1 + a2&quot;)\n \n console.log(sum2(1, 3));\n \t2. 使用函数表达式\t1.   通常这种方法与变量分配相同。简而言之，函数主体被视为一个表达式，并且该表达式被分配给一个变量。使用这种语法定义的函数可以是命名函数或匿名函数。\t2. ```JavaScript\t\tconst sum = function (a1, a2) &#123;\t\t    return a1 + a2\t\t&#125;\t\tlet a = sum(1, 2)\t\tconsole.log(a) \n\n\n\n\n使用函数声明\n\n这种方法是 JavaScript 中常用的老派方法。在关键字“function”之后，你必须指定函数的名称。之后，如果函数接受多个参数或参数，也需要提及它们。虽然这部分是完全可选的。\n\n&#x3D;&#x3D;函数提升&#x3D;&#x3D; 使用函数声明创建的函数会在其它代码执行前被创建\n\n function 函数名(参数1, 参数2) &#123;\n console.log(&quot;我是一个函数&quot;)\n &#125;\n 例 ： \n function sum(a1 , a2) &#123;\n return a1 + a2\n &#125;\n let a=sum(1,2);\n \t4. 箭头函数\t\t1.   箭头函数相当于是函数表达式创建函数的更短的版本，但是相对于函数声明，不能使用 arguments，super，也不能用作构造函数，也没有prototype属性\t\t2. ```JavaScript\t\tlet 函数名 = (参数1, 参数2) =&gt; &#123;\t\t&#125;\t\tconst frontEnd = (frontEnd) =&gt; &#123;\t\t    console.log(frontEnd + &#x27; yyds&#x27;)\t\t&#125;\t\tfrontEnd(&#x27;frontEnd&#x27;)\t\t//如果只有一个参数，甚至可以省略圆括号，使代码更短\t\tconst fe = a =&gt; a + 1\t\t//如果没有参数，圆括号将是空的（但圆括号应该保留）\t\tlet sayHi = () =&gt; alert(&quot;Hello!&quot;);\t\t//箭头函数的返回值可以直接写在箭头后面,设置对象作为返回值用()括起来\n\n\n立即执行函数(IIFE) 匿名函数,只会调用一次,可以避免变量冲突\n\n\n\n\n\n函数参数\n\n函数重载\n\n函数通过参数的个数和类型不同来创建不同的函数签名，通过调用函数时传入的参数个数和参数类型来进行命名参数的验证。\n但是 ， 在js中后声明的同名函数会对前面声明的函数进行一个覆盖\n\n\n默认函数值\n\n在有默认参数的函数中，调用arguments arguments 是一个对应于传递给函数的参数的类数组对象\n\n函数的默认参数只有在函数被调用的时候才会求值，不会在函数定义时求值\n\n函数每次调用都会重新创建默认值\n\n计算默认值的函数只有在调用函数但未传相应参数时才会被调用\n\n function names(name = &#39;frontEnd&#39;) &#123;\n   console.log(name);\n &#125;\n names()//frontend\n \n function log() &#123;\n   console.log(&#39;我被调用了&#39;);\n   return 2;\n &#125;\n function al(l = log()) &#123;\n   console.log(l);\n &#125;\n al(1);//1\n al();//我被调用了 2\n \t3. 类数组arguments对象\t1. 如果一个函数传递了三个参数，你可以以如下方式引用他们：\t\t- ```JavaScript\t\t\targuments[0]\t\t\targuments[1]\t\t\targuments[2]\n\n - ```JavaScript\n     var fun = function () &#123;\n         console.log(arguments);\n         console.log(arguments[0]);\n     &#125;\n     fun(1, 2, 3, 4, 5)\n     \t\t- ![img](js基础/-17091188883801.png)\t\t- \t4. this\t![image-20240229162438981](js基础/image-20240229162438981.png)\t箭头函数的this\t![image-20240229162805185](js基础/image-20240229162805185.png)\t4. 传递实参是传递不是变量本身,而是变量中储存的值,\t4. 将函数当做参数\t\t1. 顾名思义，就是某个函数的参数是另一个函数\t\t- ```JavaScript\t\t\tfunction callSomeFunction(someFunction, someArgnment) &#123;\t\t\t  return someFunction(someArgnment)\t\t\t&#125;\t\t\t\t\t\tfunction add(number) &#123;\t\t\t  return number + 10\t\t\t&#125;\t\t\t\t\t\tfunction sayHello(name) &#123;\t\t\t  return &#x27;Hello &#x27; + name\t\t\t&#125;\t\t\t\t\t\tlet result = callSomeFunction(add, 10)\t\t\t\t\t\tconsole.log(result);\t\t\t\t\t\tlet result2 = callSomeFunction(sayHello, &#x27;xiaobb&#x27;)\t\t\t\t\t\tconsole.log(result2);\n\n\n\n\n\n\n回调函数\n\n什么是回调函数？\nmdn官腔：回调函数是作为参数传给另一个函数的函数，然后通过在外部函数内部调用该回调函数以完成某种操作。\n人话：回调函数是一个函数，将会在另一个函数完成执行后立即执行。回调函数是一个作为参数传给另一个 JavaScript 函数的函数。这个回调函数会在传给的函数内部执行。\n\n\n\n\n高阶函数 函数也可以作为返回值 函数作为返回值是可以,动态生成新函数\n 闭包:可以将不想被看到的内容,放到两个函数之间\n\n\n通过call和apply调用函数\ncall&amp;apply:\n\n第一个参数,会成为函数的this\n\n\ncall的实参直接在第一个参数后一个个列出\n\napply得失参需要通过数组传递\n\n\nbind用来创建一个新的函数,可以指定this并且绑定参数\n但是箭头函数无法由call,apply bind指定\n面向对象思想\n面向过程，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步步实现，使用时在一个个调用函数就行了\n面向对象，就是把事务分解成一个个对象，然后由对象之间分工合作完成。面向对象是以对象功能来划分问题\n\n举个最简单点的例子，就是把大象放进冰箱。\n面向过程的思路\n打开冰箱门把大象塞进冰箱关冰箱门\n面向对象的思路，是赋予冰箱开门关门的操作，给大象进门的操作，然后冰箱和大象两个对象合作完成任务；\n面向过程的优点：性能比面向对象高，比较适合和硬件联系紧密的东西\n面向对象的优点：易维护、易复用、易扩展、更适合多人合作的大项目。\n类\n\n构造函数\n封装\n多态\n继承可以通过重写父类内容修改\n重写构造函数时,第一行代码是super(),并且可以使用super调用父类方法\n对象的内存结构\n对象自身中\n\n直接通过对象本身添加\n通过类来添加的属性\n\n\n原型对象__proto__(属性)\n\n当访问属性,先找对象自身,找不到再去原型中寻找\n\n\n\n原型对象也有原型, \n\n\n\n对象：对象（object）是大括号定义的无序的数据集合，由键值对构成\n对象也是变量。但是对象包含很多值。\n这段代码把多个值（20230001, 21, 张三）赋给名为 student的变量：\nvar student= &#123;id:&quot;20230001&quot;, age:21, name:&quot;张三&quot;&#125;;\n\n 值以名称:值对（即键值对）的方式来书写（名称和值由冒号分隔）。\nJavaScript 对象是被命名值的容器。\n对象属性（JavaScript 对象中的）名称:值对被称为属性。\n我们也可以理解为对象的状态或对象的数据\nvar student =&#123;    status:true&#125;\n\n对象方法对象也可以有方法。\n方法是在对象上执行的动作。\n方法以函数定义被存储在属性中。\nvar student =&#123;    sayhello:function()&#123;        console.log(&quot;hello&quot;)    &#125;，    // 简写    sayhi()&#123;        console.log(&quot;hi&quot;)    &#125;&#125;\n\n\n实例var person = &#123;  firstName: &quot;Bill&quot;,  lastName : &quot;Gates&quot;,  id       : 678,  fullName : function() &#123;    return this.firstName + &quot; &quot; + this.lastName;  &#125;&#125;;\n\n访问对象属性objectName.propertyName\n\n或者,当名称过于特殊不能直接使用\nobjectName[&quot;propertyName&quot;]//中括号可以放变量\n\n也可以使用symbol创建属性,不希望被外界访问的属性(不常用)\n\n也可以通过”in”运算符检查对象是否有某属性\n访问对象方法objectName.methodName()\n\n对象的声明方式\n声明字面量对象\n通过Object类创建对象 // 创建空对象\t\tlet obj1 = &#123;&#125;\t\tlet obj2 = new Object();\t\t// 添加属性\t\tobj1.key1 = &quot;value1&quot;\t\tobj2.key2 = 12\t\tobj1[&quot;key&quot;] = false\t\t// 添加方法\t\tobj2.hi=function()&#123;\t\t    console.log(&quot;hi&quot;)\t\t&#125;\n\n​\t\n枚举属性for in语句  符号添加的属性是不可枚举的\n\n可变类型\n\n两个变量同时修改\nwindow对象\n向window对象添加的属性会自动成为全局变量\n使用var设置的全局变量,都会作为window对象的属性保存(let不会,而是存在???,增加了变量的安全性)\n使用function声明的函数都会作为window对象的方法保存\ninstanceof hasown\ninstanceof检查一个对象是否是一个类的实例,实际是检查该对象的原型链是否有改父类实例. object是所有对象的原型,object自己也有原型\nin原型和自身都检查,hasown检查自身是否含有某属性\n\nnew运算符\n解构赋值定义：允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构\nfunction foo() &#123;  return [1,2,3];&#125;var tmp = foo(),a = tmp[0], b = tmp[1], c = tmp[2];console.log(a, b, c);\n\n上例可以看到，我们进行一个手动赋值，把foo()返回数组中的值赋给独立变量a,b,c ，为了实现这一点我们需要一个临时变量tmp。\n1）数组解构 let [a, b, c，d] = foo(); console.log(a)//1 console.log(b)//2 console.log(c)//3//如果解构不成功，变量的值为undefined\n\n2）对象解构 let person = &#123; name: &#x27;zhangsan&#x27;, age: 20 &#125;;  let &#123; name, age &#125; = person; console.log(name); // &#x27;zhangsan&#x27;  console.log(age); // 20//注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；//而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n我们还可以指定其他的属性名\nlet &#123;name: myName, age: myAge&#125; = person; // myName myAge 属于别名console.log(myName); // &#x27;zhangsan&#x27; console.log(myAge); // 20\n\n这实际上说明，对象的解构赋值是下面形式的简写\nfunction bar() &#123;    return &#123;        x: 4,        y: 5,        z: 6    &#125;;&#125;var &#123; x: x, y: y, z: z &#125; = bar();console.log(x, y, z);\n\n如果属性名和要赋值的变量名相同，这种语法可以更简短一些\nfunction bar() &#123;    return &#123;        x: 4,        y: 5,        z: 6    &#125;;&#125;var &#123; x, y, z &#125; = bar();console.log(x, y, z);\n\n3）小结\n解构赋值就是把数据解构分解，然后给变量进行赋值\n如果解构不成功，变量跟数值个数不匹配的时候，变量的值为**undefined**\n数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开\n利用解构赋值能够让我们方便的去取对象的属性跟方法\n以上只是一些基本的用法，我们还可以在解构的同时指定参数的默认值，对数组对象进行多次解构等。\n\n对象字面量属性的简洁表示法ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。在大括号里面，就可以直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\nconst age = 12;const name = &quot;Amy&quot;;const person = &#123;age, name&#125;;\n\n 方法名也可以简写\nconst person = &#123;  sayHi()&#123;    console.log(&quot;Hi&quot;);  &#125;&#125;person.sayHi();  //&quot;Hi&quot;// 等同于const person = &#123;  sayHi: function() &#123;    console.log(&quot;Hi&quot;);  &#125;&#125;;\n\n属性名表达式ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。\nconst obj = &#123; [&quot;he&quot;+&quot;llo&quot;]()&#123;   return &quot;Hi&quot;;  &#125;&#125;obj.hello();  //&quot;Hi&quot;\n\n注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错。\nlet str = &#x27;hello&#x27;let obj = &#123; [str] &#125;console.log(obj);\n\n对象的拓展运算符拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。\n基本用法let person = &#123;name: &quot;Amy&quot;, age: 15 &#125;;let someone = &#123; ...person &#125;;\n\n可用于合并两个对象let age = &#123;age: 15&#125;;let name = &#123;name: &quot;Amy&quot;&#125;;let person = &#123;...age, ...name&#125;;\n\n同样，对于数组也有扩展运算符，用法基本一致。\n4. \n正则表达式定义一个字符串的规则,检查字符串是否符合规则\n","categories":["js"]},{"title":"面试：自我介绍、项目经验汇总","url":"/2025/09/27/%E9%9D%A2%E8%AF%95%EF%BC%9A%E9%80%9A%E7%94%A8%E5%87%86%E5%A4%87/","content":"自我介绍各位面试官大家好！我叫hjh。我是天津理工大学信息安全专业的学生，在校期间，我学习了许多与web前端开发相关的知识和技术。我熟练使用HTML、CSS和JavaScript，还熟练使用vue及Typescript并应用于开发，也对react框架有一定的了解。在校内用vue和ts开发过用于动态多渠道发送消息的Saber消息分发平台，以及用于新生技术培训的Elite后台管理平台。我非常喜欢前端开发这个职业，也很渴望学习新技术和新工具，在学习的过程中我也做了归纳整理，搭建了我自己的博客。应聘贵公司前端实习生，我希望能够在您的团队中贡献自己的力量，并学到更多宝贵的经验。感谢您对我的关注和机会。谢谢！\n项目Saber这个项目是我加入的院级组织创新实践中心为了满足分发各种考试考核的通知，搭建的一个支持自主配置消息模板，动态填入信息因子的消息系统。\n我主要负责的是蕴含动态因子的消息模版的编辑、创建、展示、删除等核心模块。\n这个项目的难点在于消息模版蕴含着可能含有很复杂的逻辑的信息因子，如何尽可能简单直观的让使用者完成模版配置，并且能完整准确的将模版以及因子的的逻辑关系传递给后端。\n我最终实现的效果是：用户输消息模版，当需要输入因子时，输入&#x2F;，自动添加被大括号包裹的新建因子字样，并在下方弹出配置框，让用户进行选项配置。\n难点：\n\n模版内容的处理，拆解成不同的dom元素\n因子配置项的无限嵌套，顶级因子配置框和子因子配置框，支持返回上一级因子的配置框，将因子信息维护在一个Map里面。\n组件间的消息通信，使用了vue3.4开始支持的v-model绑定组件，用watch深度监视，监视map的变化\n与后端之间数据结果的传递。。\n\n","categories":["面试"]},{"title":"JS：文件上传","url":"/2025/10/09/JS%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"在大文件的上传中，有很多因素可能影响用户体验。\n\n服务器处理数据的能力\n请求超时\n网络波动\n\n可能面临：上传时间长，多次上传失败，失败后重新上传等等。\n分片上传客户端将要上传的文件按照一定大小分割成多个数据块进行上传。服务端对所有上传的文件进行汇总整合成原始文件。\n流程：\n\n将上传的文件分割成等大数据块。\n初始化分片上传任务，返回本次上传唯一标识符\n串行或者并行的发送各个分片数据块\n服务端判断是否完整，完整则合成原始文件。\n\n断点续传断点续传指的是在下载或上传时，任务被人为划分成几个部分。每个部分采用一个线程进行上传或下载。如果遇到问题可以从已经上传或下载的地方继续进行，而不用从头开始，从而节省了时间。\n实现方式：\n\n服务端返回从哪里开始\n浏览器端自行处理、\n\n上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可。\n如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可\n实现思路文件框和提交钮\nconst input = document.getElementById(&quot;input&quot;)const btn = document.getElementById(&quot;btn&quot;)input.addEventListener(&quot;change&quot;, handleFileChange)btn.addEventListener(&quot;click&quot;, handleUpload)\n\n获取大文件：\nfunction handleFileChange(e) &#123;      console.log(e.target.files);      const [file] = e.target.files      fileObj = file    &#125;\n分隔文件的函数：\nfunction createChunk(file, size = 5 * 1024 * 1024) &#123;      const chunkList = []      let cur = 0      while(cur &lt; file.size) &#123;        // slice 切割        chunkList.push(&#123;file: file.slice(cur, cur + size)&#125;)        cur += size      &#125;      return chunkList    &#125;\n\n构建发送请求的数组：\nfunction handleUpload() &#123;      if (!fileObj) return       const chunkList = createChunk(fileObj)//上一段的分割函数      const chunks = chunkList.map((&#123;file&#125;, index) =&gt; &#123;        return &#123;          file,          size: file.size,          percent: 0,          chunkName: `$&#123;fileObj.name&#125;-$&#123;index&#125;`,          fileName: fileObj.name,          index        &#125;      &#125;)      // 发请求      uploadChunks(chunks)    &#125;\n\n发送请求：\nfunction uploadChunks(chunks) &#123;    // 这个数组中的元素是对象，对象中有 Blob类型的文件对象      const formChunks = chunks.map((&#123;file, fileName, index, chunkName&#125;) =&gt; &#123;        const formData = new FormData()        formData.append(&#x27;file&#x27;, file)        formData.append(&#x27;fileName&#x27;, fileName)        formData.append(&#x27;chunkName&#x27;, chunkName)        return &#123;formData, index&#125;      &#125;)      // 转换为后端能识别的类型，并依次发送片段      const requestList = formChunks.map((&#123; formData, index &#125;) =&gt; &#123;         return axios.post(&#x27;http://localhost:3000/upload&#x27;, formData, () =&gt; &#123;        &#125;)      &#125;)      Promise.all(requestList).then(res =&gt; &#123;        console.log(res, &#x27;所有的片段都传输成功&#x27;)        mergeChunks()      &#125;)    &#125;\n\n未结问题\n\n切片上传失败怎么办\n上传过程中刷新页面怎么办\n如何进行并行上传\n切片什么时候按数量切，什么时候按大小切\n如何结合 Web Worker 处理大文件上传\n如何实现秒传\n\nFormData对象FormData 是 Ajax2.0 对象用以将数据编译成键值对，可以使用该对象来模拟和处理表单，方便进行文件上传操作。\n主要用途：\n使用方法\n\nappend方法添加数据，get方法获取数据\n  var formData = new FormData();formData.append(&quot;username&quot;, &quot;username&quot;);formData.get(&#x27;username&#x27;)//‘username’\n\n可以与原生的Form标签绑定，方便获取值。\n  &lt;form id=&quot;myForm&quot; action=&quot;&quot; name=&quot;myForm&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;  &lt;/div&gt;&lt;/form&gt;\n\n  注意任何元素都需要有name属性，否则无法访问到值\n  // 获取表单dom元素var form = document.getElementById(&quot;myForm&quot;);// 用表单初始化FormData对象var formData = new FormData(form);// 根据 name 属性来访问对象中的字段var username = formData.get(&quot;username&quot;);// 在此基础上添加其它数据formData.append(&quot;token&quot;,&quot;abcdefghijklmnopqrstuvwxyz&quot;);\n\n原型链上还有这些属性\n  \n\n","categories":["js"],"tags":["js","网络"]},{"title":"TS：基础","url":"/2025/10/10/TS%EF%BC%9A%E5%9F%BA%E7%A1%80/","content":"TypeScript 是 JavaScript 的类型的超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。 \n是静态类型检查的语言，提供了类型注解，在编译阶段就可以检查出数据类型的错误。\n特性\n类型批注和编译时类型检查 ：在编译时批注变量类型\n类型推断：ts 中没有批注变量类型会自动推断变量的类型\n类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除\n接口：ts 中用接口来定义对象类型\n枚举：用于取值被限定在一定范围内的场景\nMixin：可以接受任意类型的值\n泛型编程：写代码时使用一些以后才指定的类型\n名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突\n元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组\n\n类型批注数据类型：\n\nboolean（布尔类型）\n\nnumber（数字类型）\n\nstring（字符串类型）\n\narray（数组类型）\n  let arr:string[] = [&#x27;12&#x27;, &#x27;23&#x27;];//类型[]let arr:Array&lt;number&gt; = [1, 2];//数组泛型\n\ntuple（元组类型）  表示已知元素数量和类型的数组，类型不必相同\n  let tupleArr:[number, string, boolean];tupleArr = [12, &#x27;34&#x27;, true]; //oktypleArr = [12, &#x27;34&#x27;] // no ok\n\nenum（枚举类型）\n  enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green;\n\nany（任意类型）\n\nnull 和 undefined 类型\n\nvoid 类型  没有返回值\n\nnever 类型\n\nobject 对象类型\n\n\n自动推断\n发生在初始化变量和成员，设置默认参数和决定函数返回值时\n接口\n描述对象的类型\ninterface Person &#123;  name？: string;  age: number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,&#125;;\n\n类TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等。提供了基础类型中的类型支持，还有抽象类、修饰符等。\n基础定义：\nclass Car &#123;    engine:string;    constructor(engine:string) &#123;        this.engine = engine    &#125;    // 方法    disp():void &#123;        console.log(&quot;发动机为 :   &quot;+this.engine)    &#125;&#125;\n\n继承与重写：\nclass Animal &#123;    move(distanceInMeters: number = 0) &#123;        console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);    &#125;&#125;class Dog extends Animal &#123;    bark() &#123;        console.log(&#x27;Woof! Woof!&#x27;);    &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark();\n\n子类可以访问父类的方法，也可以对父类方法进行重写，也可以用super关键字调用父类方法。\nclass PrinterClass &#123;   doPrint():void &#123;      console.log(&quot;父类的 doPrint() 方法。&quot;)   &#125;&#125;class StringPrinter extends PrinterClass &#123;   doPrint():void &#123;      super.doPrint() // 调用父类的函数      console.log(&quot;子类的 doPrint()方法。&quot;)   &#125;&#125;\n\n静态属性：\n属性存在于类本身上面而不是类的实例上，在ts和js中都有\n修饰符\n公共Public：可以自由的访问类程序里定义的成员\n私有Private：只能够在该类的内部进行访问\n受保护Protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\nclass Animal &#123;  // public 修饰符（默认）：可以在任何地方访问  public name: string;  // private 修饰符：只能在当前类内部访问  private age: number;  // protected 修饰符：可以在当前类和子类中访问  protected weight: number;  constructor(name: string, age: number, weight: number) &#123;    this.name = name;    this.age = age;    this.weight = weight;  &#125;  // 类内部可以访问所有修饰符的成员  public getAnimalInfo(): string &#123;    return `Name: $&#123;this.name&#125;, Age: $&#123;this.age&#125;, Weight: $&#123;this.weight&#125;`;  &#125;&#125;class Dog extends Animal &#123;  // 子类可以访问父类的 public 和 protected 成员  public getDogInfo(): string &#123;    // 可以访问 public 成员    const dogName = this.name;        // 可以访问 protected 成员    const dogWeight = this.weight;        // 错误：无法访问父类的 private 成员    // const dogAge = this.age;        return `Dog Name: $&#123;dogName&#125;, Weight: $&#123;dogWeight&#125;`;  &#125;&#125;// 创建实例const animal = new Animal(&quot;动物&quot;, 5, 20);const dog = new Dog(&quot;小狗&quot;, 3, 10);// 访问 public 成员（允许）console.log(animal.name); // 输出: &quot;动物&quot;console.log(dog.name);    // 输出: &quot;小狗&quot;// 访问 private 成员（错误）// console.log(animal.age); // 访问 protected 成员（错误）// console.log(animal.weight);// console.log(dog.weight);// 通过类的方法访问内部成员console.log(animal.getAnimalInfo()); // 输出: &quot;Name: 动物, Age: 5, Weight: 20&quot;console.log(dog.getDogInfo());       // 输出: &quot;Dog Name: 小狗, Weight: 10&quot;\n\n抽象类不能被直接实例化，只能当做父类使用。\nabstract class Animal &#123;    abstract makeSound(): void;    move(): void &#123;        console.log(&#x27;roaming the earch...&#x27;);    &#125;&#125;class Cat extends Animal &#123;    makeSound() &#123;        console.log(&#x27;miao miao&#x27;)    &#125;&#125;const cat = new Cat()cat.makeSound() // miao miaocat.move() // roaming the earch...\n\n函数ts为js函数添加了许多额外功能。\n自动推断类型\n桉树进行了初始化，已指定参数类型，ts编译器可以推断出函数类型\n显示指定函数类型\n// 方式一type LongHand = &#123;  (a: number): number;//对象字面量形式，支持重载&#125;;// 方式二type ShortHand = (a: number) =&gt; number;//纯函数形式，不支持重载\n\n可选参数\n当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下：\nconst add = (a: number, b?: number) =&gt; a + (b ? b : 0)\n\n这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以\n剩余参数类型\n剩余参数与JavaScript的语法类似，需要用 ... 来表示剩余参数\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\nconst add = (a: number, ...rest: number[]) =&gt; rest.reduce(((a, b) =&gt; a + b), a)\n\n函数重载\n支持一个函数可以实现多种功能，例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n// 上边是声明function add (arg1: string, arg2: string): stringfunction add (arg1: number, arg2: number): number// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字// 下边是实现function add (arg1: string | number, arg2: string | number) &#123;  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2  if (typeof arg1 === &#x27;string&#x27; &amp;&amp; typeof arg2 === &#x27;string&#x27;) &#123;    return arg1 + arg2  &#125; else if (typeof arg1 === &#x27;number&#x27; &amp;&amp; typeof arg2 === &#x27;number&#x27;) &#123;    return arg1 + arg2  &#125;&#125;\n\n工具类型Partial将 T 的所有属性变为可选（相当于添加 ? 修饰符）。场景：适用于部分更新对象的场景（如表单提交）。\ninterface User &#123;  id: number;  name: string;&#125;type PartialUser = Partial&lt;User&gt;;// 等价于 &#123; id?: number; name?: string; &#125;\n\nRequired将 T 的所有属性变为必选（移除 ? 修饰符）。场景：确保对象属性必须存在。\ninterface PartialUser &#123;  id?: number;  name?: string;&#125;type RequiredUser = Required&lt;PartialUser&gt;;// 等价于 &#123; id: number; name: string; &#125;\n\nReadonly将 T 的所有属性变为只读（添加 readonly 修饰符）。场景：创建不可变对象。\ninterface User &#123;  id: number;  name: string;&#125;type ReadonlyUser = Readonly&lt;User&gt;;// 等价于 &#123; readonly id: number; readonly name: string; &#125;\n\nRecord创建一个对象类型，其键为 K，值为 T。场景：定义键值对结构或枚举映射。\ntype UserRoles = &quot;admin&quot; | &quot;user&quot;;type RolePermissions = Record&lt;UserRoles, boolean&gt;;// 等价于 &#123; admin: boolean; user: boolean; &#125;\n\nPick从 T 中选取指定的属性 K（K 是 T 的键的子集）。场景：仅需对象的部分属性。\ninterface User &#123;  id: number;  name: string;  age: number;&#125;type UserBasicInfo = Pick&lt;User, &quot;id&quot; | &quot;name&quot;&gt;;// 等价于 &#123; id: number; name: string; &#125;\n\nOmit从 T 中排除指定的属性 K（K 是 T 的键的子集）。场景：排除不需要的属性。\ninterface User &#123;  id: number;  name: string;  age: number;&#125;type UserWithoutAge = Omit&lt;User, &quot;age&quot;&gt;;// 等价于 &#123; id: number; name: string; &#125;\n\nExclude从联合类型 T 中排除可分配给 U 的类型。场景：过滤联合类型的成员。\ntype T = string | number | boolean;type NumericOrBoolean = Exclude&lt;T, string&gt;; // number | boolean\n\nExtractExtract 类型的作用与 Exclude 正好相反，Extract 主要用来从联合类型中提取指定的类型，类似于操作接口类型中的 Pick 类型。\njs 体验AI代码助手 代码解读复制代码type Extract&lt;T, U&gt; = T extends U ? T : never;type T = Extract&lt;&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;, &#x27;a&#x27;&gt;; // =&gt; &#x27;a&#x27;\n\n我们发现 Extract 类型相当于取出两个联合类型的交集。\n此外，我们还可以基于 Extract 实现一个获取接口类型交集的工具类型，\njs 体验AI代码助手 代码解读复制代码type Intersect&lt;T, U&gt; = &#123;  [K in Extract&lt;keyof T, keyof U&gt;]: T[K];&#125;;interface Person &#123;  name: string;  age?: number;  weight?: number;&#125;interface NewPerson &#123;  name: string;  age?: number;&#125;type T = Intersect&lt;Person, NewPerson&gt;;// 相当于type T = &#123;  name: string;  age?: number;&#125;;\n\n我们使用了 Extract 类型来提取两个接口类型属性的交集，并使用映射类型生成了一个新的类型。Extract 类型的作用与 Exclude 正好相反，Extract 主要用来从联合类型中提取指定的类型，类似于操作接口类型中的 Pick 类型。\njs 体验AI代码助手 代码解读复制代码type Extract&lt;T, U&gt; = T extends U ? T : never;type T = Extract&lt;&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27;, &#x27;a&#x27;&gt;; // =&gt; &#x27;a&#x27;\n\n我们发现 Extract 类型相当于取出两个联合类型的交集。\n此外，我们还可以基于 Extract 实现一个获取接口类型交集的工具类型，\njs 体验AI代码助手 代码解读复制代码type Intersect&lt;T, U&gt; = &#123;  [K in Extract&lt;keyof T, keyof U&gt;]: T[K];&#125;;interface Person &#123;  name: string;  age?: number;  weight?: number;&#125;interface NewPerson &#123;  name: string;  age?: number;&#125;type T = Intersect&lt;Person, NewPerson&gt;;// 相当于type T = &#123;  name: string;  age?: number;&#125;;\n\n我们使用了 Extract 类型来提取两个接口类型属性的交集，并使用映射类型生成了一个新的类型。从联合类型 T 中提取可分配给 U 的类型。场景：筛选联合类型的成员。\ntype T = string | number | boolean;type StringOrNumber = Extract&lt;T, string | number&gt;; // string | number\n\nNonNullable从 T 中排除 null 和 undefined。场景：确保值非空。\ntype T = string | null | undefined;type NonNullableT = NonNullable&lt;T&gt;; // string\n\nConstructorParameters获取构造函数类型 T 的参数类型的元组。场景：提取类的构造函数参数类型。\nclass User &#123;  constructor(id: number, name: string) &#123;&#125;&#125;type ConstructorParams = ConstructorParameters&lt;typeof User&gt;; // [id: number, name: string]\n\nParameters获取函数类型 T 的参数类型的元组。场景：提取函数参数类型。\ntype Fn = (a: number, b: string) =&gt; void;type Params = Parameters&lt;Fn&gt;; // [a: number, b: string]\n\nReturnType获取函数类型 T 的返回值类型。场景：提取函数返回值类型。\ntype Fn = () =&gt; &#123; id: number &#125;;type Return = ReturnType&lt;Fn&gt;; // &#123; id: number &#125;\n\nThisParameterType获取函数类型 T 的 this 参数类型。场景：提取函数的 this 类型。\nfunction fn(this: &#123; id: number &#125;) &#123;&#125;type ThisType = ThisParameterType&lt;typeof fn&gt;; // &#123; id: number &#125;\n\nThisType标记对象字面量中的 this 类型（需启用 --noImplicitThis）。场景：在对象字面量中明确 this 类型。\ntype User = &#123;  name: string;  greet: () =&gt; string;&#125;;const user: ThisType&lt;User&gt; = &#123;  name: &quot;Alice&quot;,  greet() &#123;    return `Hello, $&#123;this.name&#125;`; // this 指向 User 类型  &#125;,&#125;;\n\nOmitThisParameter移除函数类型 T 的 this 参数。场景：忽略函数的 this 类型。\nfunction fn(this: &#123; id: number &#125;) &#123;&#125;type NoThisFn = OmitThisParameter&lt;typeof fn&gt;; // () =&gt; void\n\n","categories":["ts"]},{"title":"TS：进阶","url":"/2025/10/11/TS%EF%BC%9A%E8%BF%9B%E9%98%B6/","content":"本篇包含 泛型、高级类型、装饰器、命名空间。\n泛型不预先定义好具体的类型，而在使用的时候在指定类型的一种特性，并非参数的类型，而是类型的参数\n假设我们用一个函数，它可接受一个 number 参数并返回一个number 参数，如下写法：\nfunction returnItem (para: number): number &#123;    return para&#125;\n\n如果我们打算接受一个 string 类型，然后再返回 string类型，则如下写法：\nfunction returnItem (para: string): string &#123;    return para&#125;\n\n上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高\n这种情况就可以使用泛型，如下所示：\nfunction returnItem&lt;T&gt;(para: T): T &#123;    return para&#125;\n\n可以看到，泛型给予开发者创造灵活、可重用代码的能力。\n函数中使用function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;    return [tuple[1], tuple[0]];&#125;swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7]\n\n接口中使用interface ReturnItemFn&lt;T&gt; &#123;    (para: T): T&#125;\n\n那么当我们想传入一个number作为参数的时候，就可以这样声明函数:\nconst returnItem: ReturnItemFn&lt;number&gt; = para =&gt; para\n\n类中使用class Stack&lt;T&gt; &#123;    private arr: T[] = []    public push(item: T) &#123;        this.arr.push(item)    &#125;    public pop() &#123;        this.arr.pop()    &#125;&#125;\n\n使用方式如下：\nconst stack = new Stacn&lt;number&gt;()\n\n高级类型通过简短的运算符号运算出的新类型：\n\n交叉类型\n联合类型\n类型别名\n类型索引\n类型约束\n映射类型\n条件类型\n\n交叉 &amp;function extend&lt;T , U&gt;(first: T, second: U) : T &amp; U &#123;    let result: &lt;T &amp; U&gt; = &#123;&#125;    for (let key in first) &#123;        result[key] = first[key]    &#125;    for (let key in second) &#123;        if(!result.hasOwnProperty(key)) &#123;            result[key] = second[key]        &#125;    &#125;    return result&#125;\n\n联合 |联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系\n语法如下：\nT | U\n\n别名 type可以使用 type SomeName = someValidTypeAnnotation的语法来创建类型别名：\ntype some = boolean | stringconst b: some = true // okconst c: some = &#x27;hello&#x27; // okconst d: some = 123 // 不能将类型“123”分配给类型“some”\n\n索引 keyofkeyof 类似于 Object.keys ，用于获取一个接口中 Key 的联合类型。（感觉意义不明\ninterface Button &#123;    type: string    text: string&#125;type ButtonKeys = keyof Button// 等效于type ButtonKeys = &quot;type&quot; | &quot;text&quot;\n\n约束 extend通过关键字 extend 进行约束，不同于在 class 后使用 extends 的继承作用，泛型内使用的主要作用是对泛型加以约束\ntype BaseType = string | number | boolean// 这里表示 copy 的参数// 只能是字符串、数字、布尔这几种基础类型function copy&lt;T extends BaseType&gt;(arg: T): T &#123;  return arg&#125;\n\n映射 in通过 in 关键字做类型的映射，遍历已有接口的 key 或者是遍历联合类型，如下例子：\ntype Readonly&lt;T&gt; = &#123;    readonly [P in keyof T]: T[P];&#125;;interface Obj &#123;  a: string  b: string&#125;type ReadOnlyObj = Readonly&lt;Obj&gt;\n\n条件 ？：条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。\nT extends U ? X : Y\n\n装饰器装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。在不改变原类和使用继承的情况下，动态地扩展对象功能。\n装饰类（没用过，留着备用\n例如声明一个函数 addAge 去给 Class 的属性 age 添加年龄.\nfunction addAge(constructor: Function) &#123;  constructor.prototype.age = 18;&#125;@addAgeclass Person&#123;  name: string;  age!: number;  constructor() &#123;    this.name = &#x27;huihui&#x27;;  &#125;&#125;let person = new Person();console.log(person.age); // 18\n\n上述代码，实际等同于以下形式：\nPerson = addAge(function Person() &#123; ... &#125;);\n\n上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 constructor.prototype.age 就是在每一个实例化对象上面添加一个 age 属性\n装饰方法、属性类似Object.defineProperty，接收三个参数：\n\ntarget：对象的原型\npropertyKey：名称\ndescriptor：属性描述符\n\n// 声明装饰器修饰方法/属性function method(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;  console.log(target);  console.log(&quot;prop &quot; + propertyKey);  console.log(&quot;desc &quot; + JSON.stringify(descriptor) + &quot;\\n\\n&quot;);  descriptor.writable = false;&#125;;function property(target: any, propertyKey: string) &#123;  console.log(&quot;target&quot;, target)  console.log(&quot;propertyKey&quot;, propertyKey)&#125;class Person&#123; @property name: string; constructor() &#123;   this.name = &#x27;huihui&#x27;; &#125; @method say()&#123;   return &#x27;instance method&#x27;; &#125; @method static run()&#123;   return &#x27;static method&#x27;; &#125;&#125;const xmz = new Person();// 修改实例方法sayxmz.say = function() &#123; return &#x27;edit&#x27;&#125;\n\n参数装饰接收3个参数，分别是：\n\ntarget ：当前对象的原型\npropertyKey ：参数的名称\nindex：参数数组中的位置\n\nfunction logParameter(target: Object, propertyName: string, index: number) &#123;  console.log(target);  console.log(propertyName);  console.log(index);&#125;class Employee &#123;  greet(@logParameter message: string): string &#123;      return `hello $&#123;message&#125;`;  &#125;&#125;const emp = new Employee();emp.greet(&#x27;hello&#x27;);\n\n命名空间、模块命名空间一个最明确的目的就是解决重名问题。\n命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。\n这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。\nTypeScript 中命名空间使用 namespace 来定义，语法格式如下：\nnamespace SomeNameSpaceName &#123;   export interface ISomeInterfaceName &#123;      &#125;   export class SomeClassName &#123;      &#125;&#125;\n\n以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加 export 关键字\n使用方式如下：\nSomeNameSpaceName.SomeClassName\n\n不建议使用\n","categories":["ts"]}]